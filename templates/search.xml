<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Replay</title>
      <link href="/2025/08/07/%E6%B8%B8%E6%88%8F/%E6%9C%BA%E5%88%B6/SuperHot/2Replay/"/>
      <url>/2025/08/07/%E6%B8%B8%E6%88%8F/%E6%9C%BA%E5%88%B6/SuperHot/2Replay/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目已经传到 github 上了 <a href="https://github.com/zong4/SuperHot%EF%BC%8C3D">https://github.com/zong4/SuperHot，3D</a> 版本的会在后续上传。</p><p>3D 的版本已经上传好了，推荐阅读 3D 版本的代码，更加优美和完善。</p><hr><p>回放的话其实不外乎两种方法，分别对应了服务器的两种状态同步方式：帧同步和状态同步。</p><p>帧同步的话就是每一帧都记录所有玩家的输入，然后回放时重新执行一遍。</p><p>状态同步的话就是每一帧都记录所有玩家的状态，然后回放时直接把状态设置过去。</p><p>因此我们也可以同样的通过记录每一帧各角色的信息或者输入来实现回放，但是由于帧同步就意味着要重新模拟一遍世界，所以我这边现用了实现起来简单的状态同步。</p><h1 id="ControllerManager"><a href="#ControllerManager" class="headerlink" title="ControllerManager"></a>ControllerManager</h1><p>那不管是哪种方法，我们都需要一个 ControllerManager 来管理所有的角色。</p><p>我这边由于是状态同步，所以记录信息的任务就统一交给 ControllerManager 来做，在 LateUpdate 中收集所有角色的信息并保存。</p><p>其中 Action 中的 Time 是为了在实现 wait 的，从而保证回放时的时间间隔和录制时一致，这里我为了方便才把它放在 Action 结构体中的，按理说应该以帧的单位存储。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Action</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Time;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID;</span><br><span class="line">    <span class="keyword">public</span> Vector3 Position;</span><br><span class="line">    <span class="keyword">public</span> Vector3 Direction;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Fire;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ControllerManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ControllerManager _instance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Data</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _nextId;</span><br><span class="line">        <span class="keyword">public</span> List&lt;Controller&gt; controllers = <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Action&gt;&gt; Actions = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Player</span></span><br><span class="line">        <span class="keyword">public</span> GameObject player;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">this</span>;</span><br><span class="line">                DontDestroyOnLoad(gameObject);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Instantiate(player);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ReplayManager.IsReplaying())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process actions</span></span><br><span class="line">            <span class="keyword">var</span> actions = <span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> controller <span class="keyword">in</span> controllers)</span><br><span class="line">            &#123;</span><br><span class="line">                actions.Add(<span class="keyword">new</span> Action</span><br><span class="line">                &#123;</span><br><span class="line">                    Time = Time.time,</span><br><span class="line">                    ID = controller.ID,</span><br><span class="line">                    Position = controller.transform.position,</span><br><span class="line">                    Direction = controller.transform.forward,</span><br><span class="line">                    Fire = Input.GetButton(<span class="string">&quot;Fire1&quot;</span>) <span class="comment">// Example input check</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Actions.Add(actions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ControllerManager Instance</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _instance = <span class="keyword">new</span> GameObject(<span class="string">&quot;ControllerManager&quot;</span>).AddComponent&lt;ControllerManager&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> _instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterController</span>(<span class="params">Controller controller</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (controller == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            controller.ID = _nextId++;</span><br><span class="line">            controllers.Add(controller);</span><br><span class="line">            Debug.Log(<span class="string">$&quot;Controller <span class="subst">&#123;controller.ID&#125;</span> registered.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Controller <span class="title">GetController</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> controllers[id];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Action&gt; <span class="title">GetActions</span>(<span class="params"><span class="built_in">int</span> time</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Actions[time];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ReplayManager"><a href="#ReplayManager" class="headerlink" title="ReplayManager"></a>ReplayManager</h1><p>ReplayManager 主要负责回放的逻辑。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> Controllers;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReplayManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Singleton instance</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReplayManager _instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Data</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> _isReplaying;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _instance = <span class="keyword">this</span>;</span><br><span class="line">            DontDestroyOnLoad(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReplayManager Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> GameObject(<span class="string">&quot;ReplayManager&quot;</span>).AddComponent&lt;ReplayManager&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartReplay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _isReplaying = <span class="literal">true</span>;</span><br><span class="line">        TimeScaleManager.ResetTimeScale();</span><br><span class="line"></span><br><span class="line">        StartCoroutine(ReplayCoroutine());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerator <span class="title">ReplayCoroutine</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ControllerManager.Instance.Actions.Count &amp;&amp; _isReplaying; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> time = ControllerManager.Instance.Actions[i];</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> action <span class="keyword">in</span> time)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> controller = ControllerManager.Instance.GetController(action.ID);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (controller != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    controller.transform.position = action.Position;</span><br><span class="line">                    controller.transform.forward = action.Direction;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (action.Fire)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// controller.Fire();</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; ControllerManager.Instance.Actions.Count - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Wait for the next action time</span></span><br><span class="line">                <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">ControllerManager.Instance.Actions[i + <span class="number">1</span>][<span class="number">0</span>].Time - time[<span class="number">0</span>].Time</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Last action, wait for a short duration before stopping</span></span><br><span class="line">                <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.1f</span></span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopReplay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _isReplaying = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Additional logic to stop replaying</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsReplaying</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _isReplaying;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于缩放的回放"><a href="#基于缩放的回放" class="headerlink" title="基于缩放的回放"></a>基于缩放的回放</h1><p>之前的回放有点问题，慢的还是慢，快的还是快，就像录屏一样。</p><p>但是我们可以计算一下假设一秒10帧，每一帧可以移动1cm。</p><ul><li>那么正常速度下一秒动 10cm，速度是 10cm&#x2F;s。</li><li>将 TimeScale 改成 0.1 后，就意味着每一帧的利用率只有 10%，所以一帧移动 0.1cm，一秒移动 1cm，速度是 1cm&#x2F;s，正好是 TimeScale 的值。</li><li>回放时由于我们记录的是 Time.deltatime，所以等于我们每一帧的时间是 0.6s（1s 里由 100帧），每一帧移动的距离是 0.1cm，所以总共移动了 10cm，速度就是 10cm&#x2F;s。</li></ul><p>但是很奇怪的是，明明速度一样（打印出来也是一样），但是人眼确觉得回放时比正常速度慢，这就涉及到人眼的机制，在这里不具体展开，总之就是人眼对时间的感知是非线性的。</p><p>那要怎么解决上面这个问题呢，很简单，就是抽帧，我这边就是根据我设定的 TimeScale 来将每 10次 状态是站立（慢速）的帧合并在一起，从而让肉眼看上去与政策速度别无二致。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerator <span class="title">ReplayCoroutine</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ControllerManager.Instance.playerControllerMessages.Count &amp;&amp; _isReplaying; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> deltaTime = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">while</span> (ControllerManager.Instance.playerControllerMessages[i].state == Controller.ControllerState.Idle &amp;&amp;</span><br><span class="line">               i &lt; ControllerManager.Instance.playerControllerMessages.Count - <span class="number">1</span> &amp;&amp; cnt &lt; <span class="number">10</span>) <span class="comment">//todo</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">            deltaTime += ControllerManager.Instance.playerControllerMessages[i].deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Player</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> playerMessage = ControllerManager.Instance.playerControllerMessages[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> playerController = ControllerManager.Instance.playerController;</span><br><span class="line">            <span class="keyword">if</span> (playerController)</span><br><span class="line">            &#123;</span><br><span class="line">                playerController.transform.position = playerMessage.position;</span><br><span class="line">                playerController.transform.forward = playerMessage.direction;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (playerMessage.state == Controller.ControllerState.Attack)</span><br><span class="line">                &#123;</span><br><span class="line">                    playerController.Attack();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// All other controllers</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> allControllerMessages = ControllerManager.Instance.allControllersMessages[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> controllerMessage <span class="keyword">in</span> allControllerMessages)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> controller = ControllerManager.Instance.GetController(controllerMessage.id);</span><br><span class="line">                <span class="keyword">if</span> (controller)</span><br><span class="line">                &#123;</span><br><span class="line">                    controller.transform.position = controllerMessage.position;</span><br><span class="line">                    controller.transform.forward = controllerMessage.direction;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (controllerMessage.state == Controller.ControllerState.Attack)</span><br><span class="line">                    &#123;</span><br><span class="line">                        controller.Attack();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">deltaTime</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 机制 </category>
          
          <category> SuperHot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Time Manipulate</title>
      <link href="/2025/08/07/%E6%B8%B8%E6%88%8F/%E6%9C%BA%E5%88%B6/SuperHot/1TimeManipulate/"/>
      <url>/2025/08/07/%E6%B8%B8%E6%88%8F/%E6%9C%BA%E5%88%B6/SuperHot/1TimeManipulate/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人认为 SuperHot 的核心是时间控制和回放，一个一个实现。</p><p>试了一下发现时间控制实现起来挺简单的，因为 Unity 已经提供了时间尺度（时间流速）的接口，所以只需要包装一下就好了。</p><p>代码暂时先不传，等后面的回放做完再一起传吧。</p><h1 id="TimeScaleManager"><a href="#TimeScaleManager" class="headerlink" title="TimeScaleManager"></a>TimeScaleManager</h1><p>由于 UnityEngine.Time.timeScale 是 static 的，所以我这边用单例模式进行管理。</p><p>之后如果做成联机，让每个玩家都是独立的话，不知道难度怎么样。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimeScaleManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Singleton instance</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TimeScaleManager _instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Data</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> _timeScale = <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TimeScaleManager Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> TimeScaleManager();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetTimeScale</span>(<span class="params"><span class="built_in">float</span> scale</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (scale &lt; <span class="number">0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentOutOfRangeException(<span class="keyword">nameof</span>(scale), <span class="string">&quot;Time scale cannot be negative.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Instance._timeScale = scale;</span><br><span class="line">        UnityEngine.Time.timeScale = scale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetTimeScale</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Instance._timeScale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetTimeScale</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Instance._timeScale = <span class="number">1f</span>;</span><br><span class="line">        UnityEngine.Time.timeScale = <span class="number">1f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Controller2D"><a href="#Controller2D" class="headerlink" title="Controller2D"></a>Controller2D</h1><p>这里主要是加了个 PlayerState 来表示玩家的状态，这样的话就可以根据状态来决定具体如何操控时间。</p><p>我这里的话就是实现到只有静止的时候才会减慢时间流速，其他时候都保持正常速度。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Controller2D</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">enum</span> PlayerState</span><br><span class="line">    &#123;</span><br><span class="line">        Idle,</span><br><span class="line">        Walking,</span><br><span class="line">        Shooting,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PlayerState _playerState = PlayerState.Idle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Walking</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> _moveSpeed = <span class="number">5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        TimeScaleManager.Instance.SetTimeScale(<span class="number">1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Escape))</span><br><span class="line">        &#123;</span><br><span class="line">            Application.Quit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OnMove();</span><br><span class="line">        OnAttack();</span><br><span class="line"></span><br><span class="line">        OnPlayerStateChange();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnMove</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> movement = <span class="keyword">new</span> Vector3(Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>), Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>), <span class="number">0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (movement.magnitude &gt; <span class="number">0.1f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _playerState = PlayerState.Walking;</span><br><span class="line">            transform.Translate(movement * (_moveSpeed * Time.deltaTime));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _playerState = PlayerState.Idle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAttack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>)) <span class="comment">// Left mouse button</span></span><br><span class="line">        &#123;</span><br><span class="line">            _playerState = PlayerState.Shooting;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Player is shooting.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnPlayerStateChange</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Handle player state changes</span></span><br><span class="line">        <span class="keyword">if</span> (_playerState == PlayerState.Idle)</span><br><span class="line">        &#123;</span><br><span class="line">            TimeScaleManager.Instance.SetTimeScale(<span class="number">0.1f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TimeScaleManager.Instance.ResetTimeScale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 机制 </category>
          
          <category> SuperHot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏机制设计师详解</title>
      <link href="/2025/04/08/%E6%B8%B8%E6%88%8F/%E6%9C%BA%E5%88%B6/%E6%B8%B8%E6%88%8F%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/04/08/%E6%B8%B8%E6%88%8F/%E6%9C%BA%E5%88%B6/%E6%B8%B8%E6%88%8F%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><ol><li><strong>构建作品集与在线影响力</strong>  <ul><li>在GitHub或ArtStation发布项目代码与设计文档，撰写技术博客分析经典游戏机制（如《塞尔达》的物理交互、《文明》的资源平衡），吸引潜在雇主注意。</li></ul></li></ol><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><h4 id="1-理论基础：从设计原则到数学模型"><a href="#1-理论基础：从设计原则到数学模型" class="headerlink" title="1. 理论基础：从设计原则到数学模型"></a>1. <strong>理论基础：从设计原则到数学模型</strong></h4><ul><li><strong>核心概念</strong>  </li><li><strong>推荐学习材料</strong>  <ul><li>搜索到的《游戏平衡性设计原则》PPT（网页2）详细拆解了平衡性设计的方法论，如通过玩家反馈、数据分析和A&#x2F;B测试发现问题。</li><li>《游戏设计心得——实现游戏平衡性的技巧》（网页8）提出“模块化设计”和“复杂性控制”原则，例如将游戏要素功能单一化以简化调整流程。</li></ul></li></ul><h4 id="2-技术工具：数据分析与快速迭代"><a href="#2-技术工具：数据分析与快速迭代" class="headerlink" title="2. 技术工具：数据分析与快速迭代"></a>2. <strong>技术工具：数据分析与快速迭代</strong></h4><ul><li><strong>数据分析工具</strong><br>学习使用游戏引擎内置的Analytics工具（如Unity Analytics）或第三方平台（如GameAnalytics），分析玩家行为数据（如胜率、资源消耗、流失节点），定位平衡问题。</li><li><strong>数学建模工具</strong><br>结合计算机背景，用Excel或Python建立平衡性模型。例如，通过马尔可夫链模拟玩家决策路径，或利用博弈论优化多人对战的经济系统。</li></ul><h4 id="3-实践方法：从原型到测试"><a href="#3-实践方法：从原型到测试" class="headerlink" title="3. 实践方法：从原型到测试"></a>3. <strong>实践方法：从原型到测试</strong></h4><ul><li><strong>小型项目实践</strong><br>设计一款简单游戏（如卡牌对战或平台跳跃），聚焦单一机制（如技能冷却时间或伤害数值）的平衡性调整。记录每次迭代的数据变化和玩家反馈。</li><li><strong>经典案例拆解</strong><br>分析成功游戏的平衡策略：<ul><li>《暗黑破坏神2》通过装备掉落率的“抽奖式设计”维持玩家动力。</li><li>《AFK Arena》通过简化策略层级（如站位调整）实现“轻松挂机”的核心体验。</li></ul></li></ul><h4 id="4-行业资源与社区参与"><a href="#4-行业资源与社区参与" class="headerlink" title="4. 行业资源与社区参与"></a>4. <strong>行业资源与社区参与</strong></h4><ul><li><strong>在线课程与论坛</strong><br>关注GDC（游戏开发者大会）演讲，如《平衡性设计的艺术与科学》（Art and Science of Game Balance）。参与Reddit的r&#x2F;gamedesign或TIGSource论坛讨论实际案例。</li><li><strong>书籍延伸阅读</strong>  <ul><li>《游戏机制：高级游戏设计技术》（Game Mechanics: Advanced Game Design）：系统讲解机制与平衡的关系。</li><li>《平衡之道：游戏设计中的数学与心理学》（Balancing Game Design）：结合数学建模与玩家心理分析。</li></ul></li></ul><hr><h3 id="三、如何结合哥德堡大学资源？"><a href="#三、如何结合哥德堡大学资源？" class="headerlink" title="三、如何结合哥德堡大学资源？"></a>三、如何结合哥德堡大学资源？</h3><ol><li><strong>选修相关课程</strong><br>虽然课程未直接涉及平衡性，但可旁听“系统设计”“玩家心理学”或“人工智能与游戏代理”课程，理解底层逻辑。</li></ol><hr><h3 id="四、长期能力提升建议"><a href="#四、长期能力提升建议" class="headerlink" title="四、长期能力提升建议"></a>四、长期能力提升建议</h3><ul><li><strong>跨学科知识融合</strong><br>学习经济学（如供需模型）和心理学（如玩家动机理论），提升对平衡性设计的宏观把控。</li></ul><hr><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><hr><h3 id="一、理解「机制创新」的本质"><a href="#一、理解「机制创新」的本质" class="headerlink" title="一、理解「机制创新」的本质"></a><strong>一、理解「机制创新」的本质</strong></h3><ol><li><p><strong>机制≠规则堆砌，而是「交互逻辑」的质变</strong>  </p><ul><li><strong>核心差异</strong>：传统机制优化是改良（如调整技能数值），创新机制是颠覆（如《Superhot》的“时间随动作流动”）。  </li><li><strong>关键问题</strong>：如何用机制创造玩家未曾体验过的认知冲突？例如《The Witness》通过环境与谜题一体化设计，重构玩家对“解谜”的认知。</li></ul></li><li><p><strong>创新机制的分类与方向</strong>  </p><ul><li><strong>物理交互创新</strong>：如《Human: Fall Flat》的软体物理、《Teardown》的体素破坏。  </li><li><strong>规则系统创新</strong>：如《Loop Hero》的循环世界生成规则、《Turing Complete》用游戏机制教授计算机原理。  </li><li><strong>叙事与机制融合</strong>：如《Her Story》的碎片化搜索叙事、《Inscryption》的卡牌与Meta叙事结合。</li></ul></li></ol><hr><h3 id="二、系统性学习路径"><a href="#二、系统性学习路径" class="headerlink" title="二、系统性学习路径"></a><strong>二、系统性学习路径</strong></h3><h4 id="1-创意方法论：从灵感捕捉到逻辑闭环"><a href="#1-创意方法论：从灵感捕捉到逻辑闭环" class="headerlink" title="1. 创意方法论：从灵感捕捉到逻辑闭环"></a><strong>1. 创意方法论：从灵感捕捉到逻辑闭环</strong></h4><ul><li><strong>逆向设计法</strong>：从目标体验反推机制。例如：  <ul><li>想创造“失控感”→ 设计角色移动速度随玩家操作失误指数级增长（类似《Getting Over It》）。  </li><li>想传递“协作≠信任”→ 设计双角色共享生命值但目标冲突（如《Keep Talking and Nobody Explodes》）。</li></ul></li><li><strong>跨界移植法</strong>：  <ul><li>将现实科学原理转化为机制：如量子纠缠（《Quantum Chess》）、分形几何（《Miegakure》的4D空间）。  </li><li>其他艺术形式启发：如戏剧的“第四面墙”打破（《Undertale》《Doki Doki Literature Club》）。</li></ul></li></ul><h4 id="2-工具与原型开发"><a href="#2-工具与原型开发" class="headerlink" title="2. 工具与原型开发"></a><strong>2. 工具与原型开发</strong></h4><ul><li><strong>快速原型工具链</strong>：  <ul><li><strong>Unity&#x2F;Unreal</strong>：适合复杂物理或AI驱动的机制（如《Boneworks》的拟真物理）。  </li><li><strong>Godot</strong>：开源引擎，适合实验性机制（如《Cruelty Squad》的怪异交互逻辑）。</li></ul></li><li><strong>编程能力的关键作用</strong>：  <ul><li>计算机背景是你的优势！用代码实现非常规交互，例如：  <ul><li>修改引擎底层物理系统（如《Besiege》的零件力学模拟）。  </li><li>开发自定义编辑器工具（如《Minecraft》红石系统的可视化逻辑设计）。</li></ul></li></ul></li></ul><h4 id="3-理论框架与案例分析"><a href="#3-理论框架与案例分析" class="headerlink" title="3. 理论框架与案例分析"></a><strong>3. 理论框架与案例分析</strong></h4><ul><li><strong>必读书籍</strong>：  <ul><li>《<em>Advanced Game Design: A Systems Approach</em>》（Michael Sellers）：用系统思维解构机制创新，如“涌现型玩法”设计。</li></ul></li><li><strong>经典案例拆解</strong>：  <ul><li>研究独立游戏神作：如《The Return of the Obra Dinn》（时间回溯推理）、《Outer Wilds》（开放宇宙时间循环）。  </li><li>分析失败案例：如《Anthem》飞行机制与关卡设计割裂的教训。</li></ul></li></ul><hr><h3 id="三、实践策略：从实验室到行业"><a href="#三、实践策略：从实验室到行业" class="headerlink" title="三、实践策略：从实验室到行业"></a><strong>三、实践策略：从实验室到行业</strong></h3><h4 id="1-学术资源结合"><a href="#1-学术资源结合" class="headerlink" title="1. 学术资源结合"></a><strong>1. 学术资源结合</strong></h4><ul><li>利用哥德堡大学的<strong>AI与游戏代理研究</strong>：探索AI如何生成或辅助机制设计（如用遗传算法迭代玩法原型）。  </li><li>选修<strong>认知科学&#x2F;交互设计课程</strong>：理解人类认知边界，设计反直觉机制（如《Stephen’s Sausage Roll》的反转视角解谜）。</li></ul><h4 id="2-项目开发重点"><a href="#2-项目开发重点" class="headerlink" title="2. 项目开发重点"></a><strong>2. 项目开发重点</strong></h4><ul><li><strong>Micro-Prototype（微型原型）</strong>：<br>每周用48小时开发一个极端简化的机制原型（例如：仅用“重力反转+时间倒流”两个机制构建平台跳跃游戏）。  </li><li><strong>玩家认知测试</strong>：<br>记录玩家首次接触机制时的“顿悟时刻”（Aha! Moment），优化引导设计（如《The Witness》的环境暗示教学）。</li></ul><hr><h3 id="四、行业突破方向"><a href="#四、行业突破方向" class="headerlink" title="四、行业突破方向"></a><strong>四、行业突破方向</strong></h3><ol><li><p><strong>技术驱动型创新</strong>  </p><ul><li>结合你的计算机背景，探索：  <ul><li><strong>程序化生成机制</strong>（如《Caves of Qud》用算法生成种族&#x2F;技能组合）。  </li><li><strong>ML-driven机制</strong>：让AI基于玩家行为动态生成新规则（如《AI Dungeon》的开放式叙事）。</li></ul></li></ul></li><li><p><strong>叙事与机制融合实验</strong>  </p><ul><li>参考《Disco Elysium》：技能系统直接影响叙事分支，而非单纯数值加成。</li></ul></li><li><p><strong>非传统交互硬件</strong>  </p><ul><li>利用北欧的AR&#x2F;VR产业优势，设计基于空间计算的新机制（如《Tea For God》的无限行走算法）。</li></ul></li></ol><hr><h3 id="五、作品集与求职策略"><a href="#五、作品集与求职策略" class="headerlink" title="五、作品集与求职策略"></a><strong>五、作品集与求职策略</strong></h3><ul><li><strong>作品集结构建议</strong>：  <ol><li><strong>核心机制原型</strong>（附可执行文件+设计文档）：展示从概念到落地的完整流程。  </li><li><strong>跨界项目</strong>：如用游戏机制模拟生物学现象（吸引关注新兴领域的团队）。</li></ol></li></ul><hr><h3 id="关键提醒"><a href="#关键提醒" class="headerlink" title="关键提醒"></a><strong>关键提醒</strong></h3><ul><li><strong>避免“为了创新而创新”</strong>：机制需服务于核心体验（如《Death Stranding》的“连接”机制与孤独感主题高度契合）。</li></ul><ol><li>加入Itch.io的“Experimental Gameplay”社群，每周分析一个前沿案例。<br>你的计算机背景将让你在实现疯狂创意时更具优势——<strong>用代码打破想象的边界</strong>。</li></ol><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><hr><h3 id="一、系统性学习资源推荐"><a href="#一、系统性学习资源推荐" class="headerlink" title="一、系统性学习资源推荐"></a>一、系统性学习资源推荐</h3><h4 id="1-行业权威平台与课程"><a href="#1-行业权威平台与课程" class="headerlink" title="1. 行业权威平台与课程"></a>1. <strong>行业权威平台与课程</strong></h4><ul><li><strong>GDC（游戏开发者大会）演讲</strong>：GDC Vault提供历年演讲视频，搜索关键词“Innovative Mechanics”或“Experimental Design”，例如《Baba Is You》开发者解析规则重构逻辑的演讲。</li><li><strong>书籍延伸</strong>：<ul><li>《<em>Rules of Play</em>》：从规则层解构机制设计的理论框架（如“涌现型玩法”设计）。</li><li>《<em>Advanced Game Design: A Systems Approach</em>》：系统思维拆解创新机制案例（如《Outer Wilds》的时间循环设计）。</li></ul></li></ul><h4 id="2-开发者社区与论坛"><a href="#2-开发者社区与论坛" class="headerlink" title="2. 开发者社区与论坛"></a>2. <strong>开发者社区与论坛</strong></h4><ul><li><strong>Reddit&#x2F;r&#x2F;gamedesign</strong>：讨论前沿机制设计案例，例如《Tunic》的逆向引导设计。</li><li><strong>TIGSource</strong>：独立开发者聚集地，分享原型开发经验与失败教训。</li><li><strong>Itch.io的Experimental Gameplay社群</strong>：每周发布极端实验性游戏原型，适合快速学习。</li></ul><h4 id="3-学术与产业结合资源"><a href="#3-学术与产业结合资源" class="headerlink" title="3. 学术与产业结合资源"></a>3. <strong>学术与产业结合资源</strong></h4><ul><li><strong>Indienova平台</strong>：提供独立游戏开发日志，分析《蒸汽迷域：循环梦魇》等作品的超现实叙事与机制融合逻辑。</li></ul><hr><h3 id="二、寻找新颖机制游戏的渠道"><a href="#二、寻找新颖机制游戏的渠道" class="headerlink" title="二、寻找新颖机制游戏的渠道"></a>二、寻找新颖机制游戏的渠道</h3><h4 id="1-独立游戏平台与展会"><a href="#1-独立游戏平台与展会" class="headerlink" title="1. 独立游戏平台与展会"></a>1. <strong>独立游戏平台与展会</strong></h4><ul><li><strong>Itch.io</strong>：主打实验性游戏，筛选“Innovative Mechanics”标签，例如《Viewfinder》的摄影重构空间机制。</li><li><strong>Steam独立游戏专区</strong>：关注“新品与热门商品”榜单，如2024年黑马《忍者明：悟》的双瞬移解谜机制。</li><li><strong>北欧本地活动</strong>：<ul><li><strong>Nordic Game Jam</strong>：限时开发活动，诞生过《Hollow Knight》等作品的早期原型。</li><li><strong>Swedish Game Awards</strong>：展示北欧学生团队的创新作品，如基于AI动态调整规则的策略游戏。</li></ul></li></ul><h4 id="2-云游戏与试玩平台"><a href="#2-云游戏与试玩平台" class="headerlink" title="2. 云游戏与试玩平台"></a>2. <strong>云游戏与试玩平台</strong></h4><ul><li><strong>Xbox Game Pass</strong>：包含大量独立游戏，如《Tunic》《Death’s Door》的机制拆解学习。</li></ul><h4 id="3-奖项与榜单追踪"><a href="#3-奖项与榜单追踪" class="headerlink" title="3. 奖项与榜单追踪"></a>3. <strong>奖项与榜单追踪</strong></h4><ul><li><strong>IndieCade与IGF（独立游戏节）</strong>：历年获奖作品（如《Return of the Obra Dinn》）是机制创新的标杆。</li><li><strong>iOS&#x2F;Google Play独立游戏榜单</strong>：关注《光注：黑暗中的光芒》等小众高分作品的光影交互设计。</li></ul><h4 id="4-数据分析与案例研究"><a href="#4-数据分析与案例研究" class="headerlink" title="4. 数据分析与案例研究"></a>4. <strong>数据分析与案例研究</strong></h4><ul><li><strong>Deconstructor of Fun</strong>：分析《Pearl Gem》等游戏的机制与商业化平衡策略，学习如何通过“卷心菜式球体”设计降低上手难度。</li><li><strong>GameAnalytics</strong>：研究热门游戏的玩家行为数据，定位机制设计的留存率拐点。</li></ul><hr><h3 id="三、实践与行业联动策略"><a href="#三、实践与行业联动策略" class="headerlink" title="三、实践与行业联动策略"></a>三、实践与行业联动策略</h3><ol><li><strong>逆向工程与拆解</strong>  <ul><li>选择一款小众游戏（如《Loop Hero》的循环生成规则），用Unity&#x2F;Unreal重建其核心机制，记录设计瓶颈与解决方案。</li></ul></li></ol><hr><h3 id="四、长期跟踪与迭代建议"><a href="#四、长期跟踪与迭代建议" class="headerlink" title="四、长期跟踪与迭代建议"></a>四、长期跟踪与迭代建议</h3><ul><li><p><strong>跨界灵感采集</strong>：关注非游戏领域（如交互艺术、建筑学），例如将分形几何转化为关卡生成算法。</p></li><li><p><strong>主动测试与反馈</strong>：将试玩笔记发布至TIGSource论坛，吸引开发者讨论，形成双向学习。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 机制 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现通用的UI布局</title>
      <link href="/2025/04/06/%E6%B8%B8%E6%88%8F/%E6%8A%80%E6%9C%AF/Unity%E5%AD%A6%E4%B9%A0/Unity%E5%AD%A6%E4%B9%A003/"/>
      <url>/2025/04/06/%E6%B8%B8%E6%88%8F/%E6%8A%80%E6%9C%AF/Unity%E5%AD%A6%E4%B9%A0/Unity%E5%AD%A6%E4%B9%A003/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么要实现通用的UI布局？</p><p>因为作为对美术一窍不通的程序员，并不想花太多时间去精致的摆放每一个UI，不如直接用锚点，看着太差不差就好了。</p><p>但是每次调整Unity锚点时都需要重新设置位置，真的很麻烦，干脆写个脚本，实现在运行时通过滑块调整UI布局。</p><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/31.png"></p><h1 id="通用的UI布局"><a href="#通用的UI布局" class="headerlink" title="通用的UI布局"></a>通用的UI布局</h1><p>何为通用的UI布局？</p><p>在我眼里就是网页设计中标准的，页头，正文和页脚三元素（其实就是一分为三块），想要多一点块就不断的嵌套，想要少一点块就将某几块的高度设为0.</p><p>于是就可以实现以下这样的PageLayout类。</p><ol><li>在Awake时获取三元素的初始数据。</li><li>然后在Update时根据滑块数据不断的调整锚点位置。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PageLayout</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">            _headerRectTransform = gameObject.transform.GetChild(<span class="number">0</span>).gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">            _contentRectTransform = gameObject.transform.GetChild(<span class="number">1</span>).gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">            _footerRectTransform = gameObject.transform.GetChild(<span class="number">2</span>).gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line"></span><br><span class="line">            headerHeightPercent = <span class="number">1f</span> - _headerRectTransform.anchorMin.y;</span><br><span class="line">            footerHeightPercent = _footerRectTransform.anchorMax.y;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">            _headerRectTransform.anchorMin = <span class="keyword">new</span> Vector2(<span class="number">0f</span>, <span class="number">1f</span> - headerHeightPercent);</span><br><span class="line">            _headerRectTransform.anchorMax = <span class="keyword">new</span> Vector2(<span class="number">1f</span>, <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line">            _contentRectTransform.anchorMin = <span class="keyword">new</span> Vector2(<span class="number">0f</span>, footerHeightPercent);</span><br><span class="line">            _contentRectTransform.anchorMax = <span class="keyword">new</span> Vector2(<span class="number">1f</span>, <span class="number">1f</span> - headerHeightPercent);</span><br><span class="line"></span><br><span class="line">            _footerRectTransform.anchorMin = <span class="keyword">new</span> Vector2(<span class="number">0f</span>, <span class="number">0f</span>);</span><br><span class="line">            _footerRectTransform.anchorMax = <span class="keyword">new</span> Vector2(<span class="number">1f</span>, footerHeightPercent);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">        [<span class="meta">Range(0f, 1f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> headerHeightPercent;</span><br><span class="line">        [<span class="meta">Range(0f, 1f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> footerHeightPercent;</span><br><span class="line">        <span class="keyword">private</span> RectTransform _headerRectTransform;</span><br><span class="line">        <span class="keyword">private</span> RectTransform _contentRectTransform;</span><br><span class="line">        <span class="keyword">private</span> RectTransform _footerRectTransform;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滑着滑着，伴随着“嗯”的一声，一种恰到好处的感觉油然而生，那就拷贝一下数据然后复制就哦了，从未想过原来布局如此简单。</p><h1 id="通过Input控制UI"><a href="#通过Input控制UI" class="headerlink" title="通过Input控制UI"></a>通过Input控制UI</h1><p>通过添加InputSystemUIInputModule，同时在EventSystem里设置FirstSelected就可以实现。</p><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/32.png"></p><p>但是有个问题就是这样的话游戏一启动就会有一个按钮进入被选择的状态，感觉有点奇怪，应该可以通过设置一个隐形UI解决。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现设计师友好的代码</title>
      <link href="/2025/04/06/%E6%B8%B8%E6%88%8F/%E6%8A%80%E6%9C%AF/Unity%E5%AD%A6%E4%B9%A0/Unity%E5%AD%A6%E4%B9%A004/"/>
      <url>/2025/04/06/%E6%B8%B8%E6%88%8F/%E6%8A%80%E6%9C%AF/Unity%E5%AD%A6%E4%B9%A0/Unity%E5%AD%A6%E4%B9%A004/</url>
      
        <content type="html"><![CDATA[<h1 id="设计师友好的代码"><a href="#设计师友好的代码" class="headerlink" title="设计师友好的代码"></a>设计师友好的代码</h1><p>为什么要开发设计师友好的代码？</p><p>好处有很多，可以防止一些意想不到的bug，也可以提高沟通效率……</p><h1 id="设置参数反射标记"><a href="#设置参数反射标记" class="headerlink" title="设置参数反射标记"></a>设置参数反射标记</h1><ol><li>通过Serializable可以提高参数的可读性，如下图的MoveSettings和AttackSettings。</li><li>通过[Min(0f)]，[HideInInspector]，……，防止设计师乱搞。</li></ol><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/41.png"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Character</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveSettings</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Min(0f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AttackSettings</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> GameObject weaponPrefab;</span><br><span class="line">        <span class="keyword">public</span> Transform weaponEquippedTransform;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HideInInspector</span>] <span class="keyword">public</span> BasicWeapon2D weapon2DComponent;</span><br><span class="line">        [<span class="meta">HideInInspector</span>] <span class="keyword">public</span> Color color;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Min(0f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> collisionDamage;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="添加上下文"><a href="#添加上下文" class="headerlink" title="添加上下文"></a>添加上下文</h1><p>通过[ContextMenu(“”)]，可以为脚本添加上下文，如下。</p><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/42.png"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BasicCharacterController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">ContextMenu(<span class="string">&quot;Init&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            moveSettings.moveSpeed = <span class="number">3f</span>;</span><br><span class="line"></span><br><span class="line">            attackSettings.collisionDamage = <span class="number">0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在编辑器中运行脚本"><a href="#在编辑器中运行脚本" class="headerlink" title="在编辑器中运行脚本"></a>在编辑器中运行脚本</h1><p>通过[ExecuteInEditMode]可以在编辑器中通过脚本调整数据，用在UI里真的太香了，不用像上一篇那样拷贝复制了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UI</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PageLayoutAdjuster</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">            <span class="keyword">if</span> (transform.childCount != <span class="number">3</span>)</span><br><span class="line">                Debug.LogError(<span class="string">&quot;PageLayout requires exactly 3 child objects: Header, Content, and Footer.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            _headerRectTransform = gameObject.transform.GetChild(<span class="number">0</span>).gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">            _contentRectTransform = gameObject.transform.GetChild(<span class="number">1</span>).gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">            _footerRectTransform = gameObject.transform.GetChild(<span class="number">2</span>).gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line"></span><br><span class="line">            headerHeightPercent = <span class="number">1f</span> - _headerRectTransform.anchorMin.y;</span><br><span class="line">            footerHeightPercent = _footerRectTransform.anchorMax.y;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">            _headerRectTransform.anchorMin = <span class="keyword">new</span> Vector2(<span class="number">0f</span>, <span class="number">1f</span> - headerHeightPercent);</span><br><span class="line">            _headerRectTransform.anchorMax = <span class="keyword">new</span> Vector2(<span class="number">1f</span>, <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line">            _contentRectTransform.anchorMin = <span class="keyword">new</span> Vector2(<span class="number">0f</span>, footerHeightPercent);</span><br><span class="line">            _contentRectTransform.anchorMax = <span class="keyword">new</span> Vector2(<span class="number">1f</span>, <span class="number">1f</span> - headerHeightPercent);</span><br><span class="line"></span><br><span class="line">            _footerRectTransform.anchorMin = <span class="keyword">new</span> Vector2(<span class="number">0f</span>, <span class="number">0f</span>);</span><br><span class="line">            _footerRectTransform.anchorMax = <span class="keyword">new</span> Vector2(<span class="number">1f</span>, footerHeightPercent);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">        [<span class="meta">Range(0f, 1f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> headerHeightPercent;</span><br><span class="line">        [<span class="meta">Range(0f, 1f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> footerHeightPercent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> RectTransform _headerRectTransform;</span><br><span class="line">        <span class="keyword">private</span> RectTransform _contentRectTransform;</span><br><span class="line">        <span class="keyword">private</span> RectTransform _footerRectTransform;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现ReadOnly反射标记"><a href="#实现ReadOnly反射标记" class="headerlink" title="实现ReadOnly反射标记"></a>实现ReadOnly反射标记</h1><p>如果你想让设计师可以看到一些参数，但不能调整（调试用），就需要自己来实现ReadOnly这个标记，效果如下。</p><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/43.png"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReadOnlyAttribute</span> : <span class="title">PropertyAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CustomPropertyDrawer(typeof(ReadOnlyAttribute))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReadOnlyDrawer</span> : <span class="title">PropertyDrawer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params">Rect position, SerializedProperty property, GUIContent label</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUI.enabled = <span class="literal">false</span>;</span><br><span class="line">        EditorGUI.PropertyField(position, property, label, <span class="literal">true</span>);</span><br><span class="line">        GUI.enabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于InputSystem实现本地多人游戏（一）</title>
      <link href="/2025/04/06/%E6%B8%B8%E6%88%8F/%E6%8A%80%E6%9C%AF/Unity%E5%AD%A6%E4%B9%A0/Unity%E5%AD%A6%E4%B9%A001/"/>
      <url>/2025/04/06/%E6%B8%B8%E6%88%8F/%E6%8A%80%E6%9C%AF/Unity%E5%AD%A6%E4%B9%A0/Unity%E5%AD%A6%E4%B9%A001/</url>
      
        <content type="html"><![CDATA[<h1 id="InputSystem"><a href="#InputSystem" class="headerlink" title="InputSystem"></a>InputSystem</h1><p>InputSystem 是 Unity 自带的一个上层输入系统（隔离了不同的输入设备），可以让我们更方便地处理输入事件，当然同时也不可避免的会失去一些精细的调控。</p><p>要想实现本地多人游戏光有 InputSystem 可不够，还需要用 PlayerInput 对输入进行二次绑定以及 PlayerInputManager 来管理多个PlayerInput。</p><h1 id="PlayerInput"><a href="#PlayerInput" class="headerlink" title="PlayerInput"></a>PlayerInput</h1><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/2.png"></p><p>大部分设置保留默认就行。</p><ol><li>Camera：这里由于我是 2D 游戏，所以没有设置 Camera。</li><li>Behaviour：这里我没有用默认的 SendMessages，是因为我希望能更精准的控制这些 Callback，所以我选择了 InvokeUnityEvents。</li></ol><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>需要编写一个脚本来处理所有你需要的输入事件，然后在 PlayerInput 组件上注册函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> playerIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector2 moveInput = Vector2.zero;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDeviceLost</span>(<span class="params">PlayerInput playerInput</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;OnDeviceLost: &quot;</span> + playerInput.playerIndex);</span><br><span class="line"></span><br><span class="line">        playerIndex = playerInput.playerIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDeviceRegained</span>(<span class="params">PlayerInput playerInput</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;OnDeviceRegained: &quot;</span> + playerInput.playerIndex);</span><br><span class="line"></span><br><span class="line">        playerIndex = playerInput.playerIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnControlsChanged</span>(<span class="params">PlayerInput playerInput</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;OnControlsChanged: &quot;</span> + playerInput.playerIndex);</span><br><span class="line"></span><br><span class="line">        playerIndex = playerInput.playerIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Runs even if inactive</span></span><br><span class="line">    <span class="comment">// Initializing variables, setting references</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Awake: &quot;</span> + playerIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="comment">// Runs only if active</span></span><br><span class="line">    <span class="comment">// Gameplay logic, dependent object initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Start: &quot;</span> + playerIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (playerIndex == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.position = <span class="keyword">new</span> Vector3(<span class="number">-5.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (playerIndex == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.position = <span class="keyword">new</span> Vector3(<span class="number">5.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnMove</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        moveInput = context.ReadValue&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnJump</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.performed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.transform.position += Vector3.up * <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="comment">// Handling input, animations, UI updates, non-physics movement</span></span><br><span class="line">    <span class="comment">// Faster (reacts instantly, runs as often as possible)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.position += <span class="keyword">new</span> Vector3(moveInput.x, <span class="number">0</span>, moveInput.y) * Time.deltaTime * <span class="number">5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Physics calculations, applying forces (Rigidbody.AddForce()), and physics-based movement</span></span><br><span class="line">    <span class="comment">// Slower(runs less frequently, only at fixed physics steps)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里目前就是按需实现了两个输入事件，分别是 OnMove 和 OnJump。</p><h1 id="PlayerInputManager"><a href="#PlayerInputManager" class="headerlink" title="PlayerInputManager"></a>PlayerInputManager</h1><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/3.png"></p><p>PlayerInputManager 设置起来比较简单，而且只有两个 Event。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerInputManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPlayerJoined</span>(<span class="params">PlayerInput playerInput</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;OnPlayerJoined: &quot;</span> + playerInput.playerIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPlayerLeft</span>(<span class="params">PlayerInput playerInput</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;OnPlayerLeft: &quot;</span> + playerInput.playerIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>因为我懒得再增加一个 Map，从而实现一个键盘可以 Join 两个 PlayerInput，所以只测了一个 PlayerInput（输出如下），两个的也没问题（补测）。</p><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/1.png"></p><p>可以发现玩家首次连接的时候会在 PlayerInput 先触发 OnControlsChanged 事件，然后 PlayerInputManager 才会响应 OnPlayerJoined 事件，这一点说实话我也不是很明白，涉及到底层实现了。</p><h1 id="PlayerIndex"><a href="#PlayerIndex" class="headerlink" title="PlayerIndex"></a>PlayerIndex</h1><p>由于有些本地多人游戏里，每个玩家控制的角色是<strong>固定</strong>不同的（一般表现为合作游戏），所以需要通过 PlayerIndex 来区分不同的玩家，从而异化角色对相同的输入事件的响应。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于InputSystem实现本地多人游戏（二）</title>
      <link href="/2025/04/06/%E6%B8%B8%E6%88%8F/%E6%8A%80%E6%9C%AF/Unity%E5%AD%A6%E4%B9%A0/Unity%E5%AD%A6%E4%B9%A002/"/>
      <url>/2025/04/06/%E6%B8%B8%E6%88%8F/%E6%8A%80%E6%9C%AF/Unity%E5%AD%A6%E4%B9%A0/Unity%E5%AD%A6%E4%B9%A002/</url>
      
        <content type="html"><![CDATA[<h1 id="个性化Player"><a href="#个性化Player" class="headerlink" title="个性化Player"></a>个性化Player</h1><p>相比昨天主要是完整实现了角色的异化，来看看具体的思路吧。</p><p>首先，因为 PlayerInputManager 不支持异化，只能构造通用的 Player，所以就没法直接让 PlayerInputManager 根据不同的 PlayerIndex来 实例化不同的 Player。</p><p>所以想到可以让 PlayerController 直接管理一个 static list 来存储所有的异化 Player，然后再通过 PlayerIndex 来获取对应的 Player，但是这样破坏了封装性。</p><p>干脆就直接让 PlayerController 直接获取对应的 PlayerSpecific，然后拷贝或者创建对应的组件，所以我们就可以在创建中创建一个 PlayersSpecifics 的空物体，然后在里面放置所有的 PlayerSpecific。</p><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/21.png"></p><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/22.png"></p><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/23.png"></p><p>再通过下面的代码，为每一个 PlayerIndex 查找对应的 PlayerSpecific，如果找不到就使用默认的 PlayerSpecific。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Start: &quot;</span> + _playerIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> playersSpecifics = GameObject.FindGameObjectWithTag(<span class="string">&quot;PlayersSpecifics&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (playersSpecifics == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">&quot;PlayersSpecifics not found, please add it to the scene&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> playerSpecific = playersSpecifics.transform.GetChild(_playerIndex).gameObject;</span><br><span class="line">    <span class="keyword">if</span> (playersSpecifics == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogWarning(<span class="string">&quot;PlayerSpecific: &quot;</span> + _playerIndex + <span class="string">&quot; not found, using default(0)&quot;</span>);</span><br><span class="line">        playerSpecific = playersSpecifics.transform.GetChild(<span class="number">0</span>).gameObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy all components from the playerSpecific prefab to this instance</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.position = playerSpecific.transform.position;</span><br><span class="line">        transform.rotation = playerSpecific.transform.rotation;</span><br><span class="line">        transform.localScale = playerSpecific.transform.localScale;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> component <span class="keyword">in</span> playerSpecific.GetComponents&lt;Component&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (component <span class="keyword">is</span> Transform) <span class="keyword">continue</span>;</span><br><span class="line">            CopyComponent(component, gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize special variables</span></span><br><span class="line">    &#123;</span><br><span class="line">        _colour = playerSpecific.GetComponent&lt;SpriteRenderer&gt;().color;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Player&quot;</span> + _playerIndex + <span class="string">&quot; colour: &quot;</span> + _colour);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到之后就需要为我们的 Player 实例拷贝或创建所有特殊的组件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CopyComponent</span>(<span class="params">Component original, GameObject destination</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> type = original.GetType();</span><br><span class="line">    <span class="keyword">if</span> (destination.TryGetComponent(type, <span class="keyword">out</span> <span class="keyword">var</span> copyComponent))</span><br><span class="line">        Debug.Log(<span class="string">&quot;Component already exists: &quot;</span> + type.Name);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        copyComponent = destination.AddComponent(type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> field <span class="keyword">in</span> type.GetFields(BindingFlags.Instance))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Copying field from &quot;</span> + original.GetType().Name + <span class="string">&quot;: &quot;</span> + field.Name);</span><br><span class="line">        field.SetValue(copyComponent, field.GetValue(original));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> property <span class="keyword">in</span> type.GetProperties(BindingFlags.Instance | BindingFlags.Public |</span><br><span class="line">                                                BindingFlags.DeclaredOnly))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!property.CanWrite || property.Name == <span class="string">&quot;name&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        Debug.Log(<span class="string">&quot;Copying property: &quot;</span> + property.Name);</span><br><span class="line">        property.SetValue(copyComponent, property.GetValue(original));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给大家看一下 Log，由于我设置了 BindingFlags.DeclaredOnly，所以只会遍历当前 GameObject 特有的 Property，所以只有 SpriteRenderer，可以看到就是把所有属性都拷贝了。</p><p><img src="/img/Unity%E5%AD%A6%E4%B9%A0/24.png"></p><p>综上所述，之后只需要把通用的直接挂载在 Player Perefab，把特殊的分别在每个 PlayerSpecific 就行了，比如之后有不同的武器系统，都实现起来很方便。</p><h1 id="Field-and-Property"><a href="#Field-and-Property" class="headerlink" title="Field and Property"></a>Field and Property</h1><p>Field 和 Property 是 C# 中两种不同的成员变量定义方式，如下。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Private field</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Property</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;  <span class="comment">// Returns the value of the private field</span></span><br><span class="line">        <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125; <span class="comment">// Sets the value of the private field</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>局域网第三人称射击游戏</title>
      <link href="/2025/04/01/%E6%B8%B8%E6%88%8F/%E6%8A%80%E6%9C%AF/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
      <url>/2025/04/01/%E6%B8%B8%E6%88%8F/%E6%8A%80%E6%9C%AF/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a><a href="https://github.com/zong4/LANTPSGame">项目地址</a></h1><p><video src="https://zong4.github.io/projects/source/LANTPSGame/lan_tps_game.mp4" width="780px" controls="controls"></video></p><h1 id="游戏框架"><a href="#游戏框架" class="headerlink" title="游戏框架"></a>游戏框架</h1><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Assignment.jpg" alt="作业要求"></p><p>依据作业要求，同时参考 <strong>CSGO</strong> 以及 <strong>PUBG</strong>，制定如下框架图。</p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/LANTPSGame.png" alt="框架图"></p><h1 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul><li>单独完成联机大厅以及相关 <strong>UI</strong> 。</li><li>实现人物的动画逻辑以及射击功能。</li><li>制作训练营地图，实现单人与训练营的交互。</li><li>实现多人与训练营的交互。</li><li>制作积分板。</li><li>完成对战地图。</li><li>制作 <strong>AI</strong> 。</li><li>实现多种武器。</li><li>完善动画细节。</li><li>移植到安卓。</li></ul><h2 id="联机大厅"><a href="#联机大厅" class="headerlink" title="联机大厅"></a>联机大厅</h2><p>为了方便日后复用这套局域网联机框架，大厅的地图和人物框架都是独立的，在开始游戏后用联机漫游将会话带入游戏地图中。</p><p><video src="https://zong4.github.io/projects/source/LANTPSGame/lobby_.mp4" width="780px" controls="controls"></video></p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Lobby.png" alt="大厅界面"></p><p>其中颜色调整（材质替换）是通过将 <strong>PlayerIndex</strong> 的复制属性设置为 <strong>RepNotify</strong> 后调用系统生成的广播函数 <strong>OnRep_PlayerIndex</strong> 。</p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/OnRep_PlayerIndex.png" alt="OnRep_PlayerIndex"></p><p>而玩家列表和聊天记录都是通过生成子 <strong>widget</strong> 添加进垂直框中实现的。</p><h2 id="人物动画"><a href="#人物动画" class="headerlink" title="人物动画"></a>人物动画</h2><p>大概想了一下整体的动画规划。</p><ul><li>首先，整体上分为持枪动作和不持枪动作。</li><li>其次可以分别可以做出下蹲、站立、走路、小跑以及快跑和俯仰头。</li><li>其中除了快跑和站立和都可以做到八向移动。</li><li>最后添加换弹以及死亡动画。</li></ul><p><video src="https://zong4.github.io/projects/source/LANTPSGame/animation_.mp4" width="780px" controls="controls"></video></p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/AnimationBP.png" alt="动画蓝图"></p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Locomotion.png" alt="状态机"></p><p>其中俯仰头是通过记录鼠标 <strong>Y</strong> 轴后推算出俯仰角，再用分层骨骼混合节点实现俯仰头的效果。</p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Bend.png" alt="俯仰角"></p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/AnimationBlend.png" alt="分层骨骼混合节点"></p><h3 id="人物动画逻辑"><a href="#人物动画逻辑" class="headerlink" title="人物动画逻辑"></a>人物动画逻辑</h3><ul><li>瞄准时跑步会关闭瞄准。</li><li>小跑时瞄准会切换为走路。</li><li>下蹲时跑步会关闭下蹲。</li><li>瞄准时跳跃会关闭瞄准。</li><li>射击时会限制人物移动速度。</li></ul><p>以上逻辑均在人物蓝图中通过对速度的判断实时修改相关控制参数。</p><p>（概括一下就是下蹲、走路、瞄准和射击时最大移动速度为 150，跑步时为 600，平常为 300。）</p><h2 id="射击细节"><a href="#射击细节" class="headerlink" title="射击细节"></a>射击细节</h2><p><video src="https://zong4.github.io/projects/source/LANTPSGame/shot_.mp4" width="780px" controls="controls"></video></p><p>主要是制作了射击时枪会偏移。</p><p>同时由于时第三人称，所以才瞄准时应该从枪口射出子弹，在非瞄准状态时由第三人称相机射出子弹。</p><h2 id="训练营（靶场）"><a href="#训练营（靶场）" class="headerlink" title="训练营（靶场）"></a>训练营（靶场）</h2><p><video src="https://zong4.github.io/projects/source/LANTPSGame/train_.mp4" width="780px" controls="controls"></video></p><h3 id="场景资源"><a href="#场景资源" class="headerlink" title="场景资源"></a><a href="https://pan.baidu.com/s/1V7qUTGAcC5wkxbpU6xMahQ?pwd=1111">场景资源</a></h3><h3 id="单人交互"><a href="#单人交互" class="headerlink" title="单人交互"></a>单人交互</h3><p>需要交互的主要是靶子和门。</p><ul><li>靶子被击中后会倒下。</li><li>站在门前可以通过按键开关门。</li></ul><p>其中通过在人物模型上添加重叠盒判断是否在开关门的范围内，而门的开关主要通过正反播放时间轴实现，因此可以实现开门瞬间再关门的操作。</p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Timeline.png" alt="时间轴"></p><h3 id="多人交互"><a href="#多人交互" class="headerlink" title="多人交互"></a>多人交互</h3><h4 id="门"><a href="#门" class="headerlink" title="门"></a>门</h4><p>由于重叠盒的重叠判断是在服务器与客户端上共同运行的。</p><p>因此实现多人开门的交互，只需要将判断重叠盒是否重叠的参数和人物是否点击交互键的设置改为通知设置即可。</p><p>由服务器去实现功能逻辑。</p><h4 id="靶子"><a href="#靶子" class="headerlink" title="靶子"></a>靶子</h4><p>欲实现多人交互的靶子击倒，得先将开火细节在服务器与客户端间共享（互相能看到开火）。</p><p>开火是在事件 <strong>tick</strong> 中调用的，所以只需保证 <strong>Server</strong> 和 <strong>Client</strong> 都能运行调用开火函数。</p><p>因此需要其相关参数在服务端与客户端需保证统一。</p><p>而类似于开火键等按键的输入函数均只在本机上运行，因此需要先自定义在服务器上运行的函数，再通过函数通知设置开火参数。</p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Event.png" alt="在服务器上可靠运行的函数"></p><h2 id="积分板"><a href="#积分板" class="headerlink" title="积分板"></a>积分板</h2><p>为了实现积分的统一，也需用在服务器上可靠运行的事件包裹相关函数。</p><p>同时为了不断地更新（其实主要在打开积分板的瞬间更新），需要从 <strong>PlayerController</strong> 中的 <strong>tick</strong> 调用相关事件。</p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/UpdateScoreTab.png" alt="更新积分的函数"></p><p>之所以没有在打开计分板的瞬间更新函数也是因为，打开积分板的操作只在本地运行，所以对于客户端来说，打开积分板并不能调动服务器去更新相关参数。</p><p>当然也可以通过设计中间参数来实现，不过就略微有些麻烦了。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p><video src="https://zong4.github.io/projects/source/LANTPSGame/storage_.mp4" width="780px" controls="controls"></video></p><h3 id="场景资源-1"><a href="#场景资源-1" class="headerlink" title="场景资源"></a>场景资源</h3><p>用了 <strong>EPIC</strong> 本月免费资源（ <strong>Storage House Set</strong> ）。</p><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/BehaviorTree.png" alt="AI行为树框架"></p><h2 id="武器"><a href="#武器" class="headerlink" title="武器"></a>武器</h2><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>补了小刀和手雷，由于没有投掷动画，所以都只能用粒子特效和音效补偿。</p><p>手雷做了爆炸，所以给场景的一些组件添加了模拟物理。</p><p><video src="https://zong4.github.io/projects/source/LANTPSGame/grenade_.mp4" width="780px" controls="controls"></video></p><h3 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h3><p>主要是将所有的 <strong>Actor</strong> 分成了三类， <strong>Pawn, Wood, Other</strong> ，分别有不同的打击声音和火焰。</p><h2 id="动画细节"><a href="#动画细节" class="headerlink" title="动画细节"></a>动画细节</h2><p>（有时间就做）。</p><h3 id="脚步"><a href="#脚步" class="headerlink" title="脚步"></a>脚步</h3><h2 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h2><p>基本就对着和平精英的操作 <strong>UI</strong> 做。</p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/ControlUI0.jpg" alt="和平精英"></p><p><img src="/img/TPS%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/ControlUI1.jpg" alt="UI"></p><h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><p><a href="https://pan.baidu.com/s/1N3sZkXmn6rGRAYdTO3zTOg?pwd=1111">百度网盘</a><br>提取码: 1111</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于色彩理论像素化任意图片</title>
      <link href="/2025/03/31/%E7%AE%97%E6%B3%95/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"/>
      <url>/2025/03/31/%E7%AE%97%E6%B3%95/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a><a href="https://github.com/zong4/PixelPicture">代码</a></h1><h1 id="画像素画"><a href="#画像素画" class="headerlink" title="画像素画"></a>画像素画</h1><h2 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h2><p>先看了会大佬的<a href="https://dotown.maeda-design-room.net/">像素作品（32 * 32）</a>，感觉像素画主要就是把关键特征保留下来。</p><h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><p>看了个<a href="https://www.bilibili.com/video/BV1r7411Z7rT?spm_id_from=333.880.my_history.page.click"> b 站的视频</a>，感觉还不错，决定自己也动手临摹一下。</p><p>找了张图。</p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/PixelPicture.jpg"></p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/Mine.png" alt="我临摹的"></p><p>虽然很不甘心，但是我的美术功底好像确实也就到此为止了，实在是太丑了！</p><h1 id="图片像素化"><a href="#图片像素化" class="headerlink" title="图片像素化"></a>图片像素化</h1><p>既然我自己画不行，那就只能让电脑来画了。</p><h2 id="纯算法"><a href="#纯算法" class="headerlink" title="纯算法"></a>纯算法</h2><p>个人还是喜欢用纯算法的方式解决问题（可解释性强）。</p><h3 id="改进图像缩放"><a href="#改进图像缩放" class="headerlink" title="改进图像缩放"></a>改进图像缩放</h3><p>从本质上来说，图像缩放就是去除冗余像素的过程，但是却无法生成一幅赏心悦目的像素画。</p><p>其根本原因在于没有突出重要部位的颜色（色差不明显），而是一味的使用均值平滑缩放。</p><p>因此，可以先按照缩放比例，将原图像分块，再剔除块内的偏离值，最后取平均值映射到新图像的相应位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Every channel</span></span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, channel):</span><br><span class="line">    mean = np.mean(block[:, :, page])</span><br><span class="line">    std = np.std(block[:, :, page])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 剔除 2σ 异常值</span></span><br><span class="line">    numMaxEdge = mean + <span class="number">1</span> * std</span><br><span class="line">    numMinEdge = mean - <span class="number">1</span> * std</span><br><span class="line">    usefulNum = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> blockRow <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, pixelBlockHeight):</span><br><span class="line">        <span class="keyword">for</span> blockCol <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, pixelBlockWidth):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果在范围内，加入有效值数组内</span></span><br><span class="line">            <span class="keyword">if</span> (block[blockRow, blockCol, page] &lt;= numMaxEdge) <span class="keyword">and</span> (block[blockRow, blockCol, page] &gt;= numMinEdge):</span><br><span class="line">                usefulNum.append(block[blockRow, blockCol, page])</span><br></pre></td></tr></table></figure><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/Shrink2.jpg" alt="偏移量为 2σ"></p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/Shrink1.png" alt="偏移量为 1σ"></p><p>感觉还是缺了点味道，像素画的魅力还是在于强烈的色差（尽量少的颜色）。</p><h3 id="Kmeans"><a href="#Kmeans" class="headerlink" title="Kmeans"></a>Kmeans</h3><p>考虑到像素化的诞生应该是先选色，于是准备用 <strong>Kmeans</strong> 聚类算法先将要用的颜色挑出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造聚类器（基本都缺省）</span></span><br><span class="line">estimator = KMeans(config.keamsNum, init=<span class="string">&#x27;k-means++&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/ColorSegmentation.png" alt="色卡"></p><p>效果其实并不理想，因为这张图像的眼睛和头发的颜色很相近，因此如果不能将眼睛单独识别成一个颜色，那生成的图像必然是不合格的。</p><p>但是除非用 <strong>AI</strong> 识别脸部寻找眼睛，或者用脸部定义眼睛，不然几乎没有办法能单独分辨眼睛。</p><p>看似陷入了僵局，但其实还有两种办法。</p><ol><li>让用户自己取色，数量不限。</li><li>改进 <strong>Kmeans</strong> 算法，增加边缘算子，如果不在同一区域内，则大幅提高像素的色距，从而避免将其分为一类。</li></ol><h3 id="自主取色"><a href="#自主取色" class="headerlink" title="自主取色"></a>自主取色</h3><p>自主取色（不限数量），然后给每个像素判断离哪个颜色近，就用哪个替代（以下取色均为 <strong>8</strong> 种）。</p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/SelectColorBGR512.png" alt="BGR"></p><p>由于 <strong>Opencv</strong> 默认是 <strong>BGR</strong>，不小心把 <strong>RGB</strong> 输进去了，所以色卡翻转了，不过意外的挺好看。</p><p>再通过之前改进的图像缩放，即可实现如下效果。</p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/SelectColorBGR64.png" alt="BGR64"></p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/SelectColorRGB512.png" alt="RGB"></p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/SelectColorRGB64.png" alt="RGB64"></p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/SelectColorRGBColorCard.png" alt="RGB色卡"></p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/SelectColorRGB64Max.png" alt="缩放时采用最大池化"></p><p>感觉和之前的平均池化差别并不是很明显，主要原因也是因为 <strong>64 * 64</strong> 太小了，不过这样可以保证选的颜色就是最终的颜色，不会被弱化掉。</p><h3 id="改进-Kmeans"><a href="#改进-Kmeans" class="headerlink" title="改进 Kmeans"></a>改进 Kmeans</h3><h4 id="自定义初始点"><a href="#自定义初始点" class="headerlink" title="自定义初始点"></a>自定义初始点</h4><p>想想其实也可能基于自定义的初始点去执行聚类算法。</p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/KmeansOwnerPoint.png" alt="色卡"></p><p>基于上述选用的八色进行聚类，得到如上的色卡，基本上与之前的色卡差别不大。</p><h4 id="增加边缘距离"><a href="#增加边缘距离" class="headerlink" title="增加边缘距离"></a>增加边缘距离</h4><p>试了用 <strong>Sobel</strong> 算子进行边缘检测。</p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/SobelProcess.png" alt="Sobel 算子"></p><p>其实从这张图像中能看出不少的问题：</p><ol><li>有些边缘会由于不明显而被隐去</li><li>有些地方有边缘但其实属于同一区域</li><li>边缘的权值</li><li>如何判断两点间是否连通（无边缘）</li></ol><p>其实给 <strong>Kmeans</strong> 增加边缘距离的辅助判断，本质上是从一维距离到二维距离的升维（色彩空间与距离空间），目前并没有合适的思路去配比权值。</p><p>如果以后能找到相关论文再继续探索下去。</p><h5 id="多空间模式聚类"><a href="#多空间模式聚类" class="headerlink" title="多空间模式聚类"></a>多空间模式聚类</h5><p>找了找相关论文，没什么太多的收获。个人感觉，如果单纯的用色彩欧几里得距离与空间欧几里得距离混合聚类的效果不会特别好。</p><p>因为其本质是为了分离那些虽然是同一个颜色，但其实不是一个物体的东西（比如头发和衣服）。</p><p>说到底，还是要加强边缘距离，但是又很难保证不同的图像被同一算子锐化后的特征大致相似（得先理解各个锐化算子的本质与区别）。</p><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><p>找到了一个利用 AI 将图片像素化的网站 <a href="https://pixel-me.tokyo/en/">Pixelme</a> 。</p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/Pixelme.png" alt="Pixelme网站生成的"></p><p>效果还是很不错的，不过由于他会自动裁切出人物所在区域以及会剔除背景，所以可能还需要后期自己微调一下。</p><h1 id="修改像素化图像"><a href="#修改像素化图像" class="headerlink" title="修改像素化图像"></a>修改像素化图像</h1><p>把像素化后的图像导入 <strong>Aseprite</strong> 后即可自主编辑。</p><p><img src="/img/%E5%83%8F%E7%B4%A0%E7%94%BB%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/EditPicture.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图形 </category>
          
          <category> 艺术 </category>
          
          <category> 像素画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一次性布尔多个复杂图形</title>
      <link href="/2025/03/31/%E7%AE%97%E6%B3%95/%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"/>
      <url>/2025/03/31/%E7%AE%97%E6%B3%95/%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Bentley-Ottmann-扫描线法"><a href="#Bentley-Ottmann-扫描线法" class="headerlink" title="Bentley Ottmann 扫描线法"></a>Bentley Ottmann 扫描线法</h1><p>比较传统的老办法，只能求交不能布尔。</p><p>目前最好的文章是<a href="https://blog.csdn.net/weixin_45716328/article/details/126405650?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-126405650-blog-129640718.235%5Ev36%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-126405650-blog-129640718.235%5Ev36%5Epc_relevant_default_base&utm_relevant_index=2">这篇</a>。</p><p>建议先依据该算法把扫描线的结构搭出来。</p><h1 id="Martinez-扫描线法"><a href="#Martinez-扫描线法" class="headerlink" title="Martinez 扫描线法"></a>Martinez 扫描线法</h1><p><a href="https://www.sciencedirect.com/science/article/abs/pii/S0965997813000379?via=ihub">相关论文</a>。</p><p>还可以看一下 Boost::polygon 的源码，虽然我没看完，但是感觉用的就是 Martinez 扫描线法（流程很相似），而且它论文上也说它用的是扫描线。</p><p>还在网上找到<a href="https://zhuanlan.zhihu.com/p/544058724">唯一一篇讲解 Martinez 扫描线法的中文文章</a>。</p><h2 id="求交"><a href="#求交" class="headerlink" title="求交"></a>求交</h2><p>求交不需要考虑特殊情况，唯有一些需要人为调控的精度误差，具体思路在论文中已经介绍的很详细了，就不赘述了。</p><ol><li>按照 Bentley Ottmann 扫描线法的逻辑将所有点事件加入优先队列中，并依次处理；</li></ol><blockquote><p>点事件排序时，对于坐标值相同的节点事件，应把终点放在起点前面，其次如果都是起点再继续比较另一个端点（终点）的纵坐标（优先）和横坐标。</p></blockquote><ol start="2"><li>如果存在线段相交，应将其裁剪并将新的点事件加入优先队列，同时根据布尔规则选取有效线段加入集合中。</li></ol><h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p>因为最近在忙别的任务，暂时只研究了一些。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a><a href="https://github.com/zong4/GeometryStructure">代码</a></h2><p><a href="https://zong4.github.io/2023/06/17/08C++%E5%9B%BE%E5%BD%A2%E7%AE%97%E6%B3%95%E5%BA%95%E5%B1%82%E6%A1%86%E6%9E%B6/">代码讲解</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图形 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Where is my life? 我的人生在哪里</title>
      <link href="/2025/03/31/%E5%93%B2%E5%AD%A6/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
      <url>/2025/03/31/%E5%93%B2%E5%AD%A6/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>他，23岁，一事无成，但是找到了自己的路。</p><p>很久没有写文章了，前段时间一直很迷茫，我总是想为我所做的事情赋予一些意义，说服我自己去完成它，真让我感觉非常痛苦。</p><p>明知它是没有意义的，但我却要不停的相信它是有意义的，这甚至让我有点精神分裂。</p><p>直到昨天，我洗澡的时候在想，为什么我不干脆直接承认所有的一切都是无意义的呢？</p><p>将我的人生比作游戏，不断地发起挑战。</p><p>也许这样的人生态度可以支撑我走的更远。</p><p>这不禁让我想起了《西西弗斯神话》，加缪说我们应该想象西西弗斯是快乐的，在那一刻我终于理解了他，西西弗斯应该是快乐的，他也许就在不断地挑战着他自己。</p><p>更快，更高，更持久。</p><p>从今年2月到现在，9个月的时光，我一直在思考这个问题，很庆幸我现在终于有了自己的答案，终于可以更加坦然的面对自己。</p><p>为了纪念，于第二天（2024&#x2F;11&#x2F;15）写下这篇文章，同时也会在今年将其做成视频，希望能给有相同困境的朋友们一些启发。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>What is the meaning of life? Everyone has their own answers, maybe eating everything, traveling around the world or just be a common and common person.</p><p>人生的意义是什么？我想每个人都有各自的答案：吃遍天下美食？旅游？事业？老有所终……</p><p>However, if i ask you does the life really has its meaning? Can you answer the same as you last reply?</p><p>但是如果换个问题，人生真的有意义吗？现在又还有多少人能做出与上个问题相同的回答呢？</p><p>当人生有意义这个大前提被移除，我们才能真正直面自己的人生，去思考我们所向往的人生意义是否真的是我们所向往的，还是说只是在活出别人向往的人生。</p><p>There is only one heroism in the world: to love life after having understood its true meaning.</p><p>正如罗曼罗兰所说，世界上只有一种真正的英雄主义，那就是在认清了生活的真相后还依然热爱它。</p><p>The only real thing in our lives is there is no meaning and only after you accept this terrible truth, you can find you own spirt.</p><p>同样的，也许只有当我们承认了人生的无意义，才能活出真正的人生。</p><p>Holy shit, 你知道承认人生的无意义意味着什么吗，这甚至在说我敲下这篇文章，你观看这个视频都是在浪费时间，根本就没有意义！</p><p>确实，承认人生的无意义是一件非常非常困难的事情，它会让你茫然，不知所措，甚至是恐惧，但是其实强迫自己，让自己坚信人生是有意义的又何尝不是一种酷刑。</p><p>不过我们还有一味解药，就是游戏人生，此游戏人生非彼游戏人生。</p><p>此游戏人生是要你像玩游戏一样过人生。</p><p>其实如果我们认真思考游戏，就会发现游戏也是无意义的，俄罗斯方块里的分数有什么意义吗，无伤通关Boss然后呢，包括我最爱的LOL，就算我有一天打到了王者又能怎么样呢？</p><p>但是我们为什么如此热衷于游戏呢？</p><p>其实，如果你读过游戏设计相关的书籍，你就会发现，游戏拆解到最后不过是，一个目标，一段曲折或者说是一场挑战。</p><p>所以，以自我为中心，尝试用挑战填满人生，不断地欢愉自己，这是人类在对抗荒谬时最后的倔强。</p><p>我想西西弗斯确实是快乐的。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Blender基础全流程</title>
      <link href="/2025/03/31/%E8%89%BA%E6%9C%AF/Blender/Blender%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/03/31/%E8%89%BA%E6%9C%AF/Blender/Blender%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总所周知，美术是独立游戏很重要的一块，可以不好，但是不能没有，所以就开始学Blender啦。</p><p>然后油管上有个视频展示了一下他学了一周Blender的成果，看着还不错 <a href="https://www.youtube.com/watch?v=OrmKzaeoL2c%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%B9%9F%E6%89%93%E7%AE%97%E5%85%88%E5%8A%AA%E5%8A%9B%E5%AD%A6%E4%B9%A0%E4%B8%80%E5%91%A8%EF%BC%8C%E8%87%B3%E5%B0%91%E5%BE%97%E5%81%9A%E5%88%B0%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E5%88%B6%E4%BD%9C%E6%83%B3%E8%A6%81%E7%9A%84%E5%9C%BA%E6%99%AF%E3%80%82">https://www.youtube.com/watch?v=OrmKzaeoL2c，所以我也打算先努力学习一周，至少得做到可以自己制作想要的场景。</a></p><h1 id="Day1-amp-Day2"><a href="#Day1-amp-Day2" class="headerlink" title="Day1 &amp; Day2"></a>Day1 &amp; Day2</h1><p>找了油管比较火的教程来看 <a href="https://www.youtube.com/watch?v=B0J27sf9N1Y%EF%BC%8C%E5%85%88%E5%81%9A%E4%B8%AA%E7%94%9C%E7%94%9C%E5%9C%88%EF%BC%8C%E7%86%9F%E6%82%89%E4%B8%80%E4%B8%8BBlender%E3%80%82">https://www.youtube.com/watch?v=B0J27sf9N1Y，先做个甜甜圈，熟悉一下Blender。</a></p><h2 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h2><p>Follow the part1, I make some caps&#x2F;hats for the monkey.</p><p><img src="/img/Blender%E5%AD%A6%E4%B9%A0/PartyMonkey.png"></p><p><img src="/img/Blender%E5%AD%A6%E4%B9%A0/AnotherMonkey.png"></p><h2 id="Part2-amp-Part3-Modelling"><a href="#Part2-amp-Part3-Modelling" class="headerlink" title="Part2 &amp; Part3: Modelling"></a>Part2 &amp; Part3: Modelling</h2><p>Before it, I try to place three simple torus, it is pretty interesting.</p><p><img src="/img/Blender%E5%AD%A6%E4%B9%A0/ThreeTorus.png"></p><p>However, we should make our models a little strange, not prefect, or they are always fake.</p><h2 id="Part4-Sculpting"><a href="#Part4-Sculpting" class="headerlink" title="Part4: Sculpting"></a>Part4: Sculpting</h2><p>That is so interesting, sclupting, I want to do more about that next week.</p><h2 id="Part5-Shadering"><a href="#Part5-Shadering" class="headerlink" title="Part5: Shadering"></a>Part5: Shadering</h2><h2 id="Part6-amp-Part7-Geometry-Nodes"><a href="#Part6-amp-Part7-Geometry-Nodes" class="headerlink" title="Part6 &amp; Part7: Geometry Nodes"></a>Part6 &amp; Part7: Geometry Nodes</h2><p>挺有意思的，应该就是指渲染管线里的Geometry Shader，今天就先做到这样吧。</p><p><img src="/img/Blender%E5%AD%A6%E4%B9%A0/Donuts.png"></p><h2 id="Part9-Layout"><a href="#Part9-Layout" class="headerlink" title="Part9: Layout"></a>Part9: Layout</h2><h2 id="Part10-Lighting"><a href="#Part10-Lighting" class="headerlink" title="Part10: Lighting"></a>Part10: Lighting</h2><p>还可以，学Blender主要目的也不是自己建模，重心还是在学习Blender的操作，可以基于现有模型修改出新模型和搭建想要的场景就行，最多人物要自己建，剩下的一般都网上找就行了。</p><p>目前就先这样的效果，盘子有点懒，等会再做。</p><p><img src="/img/Blender%E5%AD%A6%E4%B9%A0/DonutsLight.png"></p><h2 id="Part11-Compositing"><a href="#Part11-Compositing" class="headerlink" title="Part11: Compositing"></a>Part11: Compositing</h2><p>有点类似于后期调色。</p><h2 id="Part12-Animation"><a href="#Part12-Animation" class="headerlink" title="Part12: Animation"></a>Part12: Animation</h2><h2 id="Part8-amp-Part13-Rendering"><a href="#Part8-amp-Part13-Rendering" class="headerlink" title="Part8 &amp; Part13: Rendering"></a>Part8 &amp; Part13: Rendering</h2><p>有很多检查要做，具体的话我觉得可以以后再看视频 <a href="https://www.youtube.com/watch?v=fSfFkh2sI4k&amp;list=PLjEaoINr3zgEPv5y--4MKpciLaoQYZB1Z&amp;index=14%E3%80%82">https://www.youtube.com/watch?v=fSfFkh2sI4k&amp;list=PLjEaoINr3zgEPv5y--4MKpciLaoQYZB1Z&amp;index=14。</a></p><ul><li>检查法线</li><li>开启运动模糊</li><li>……</li></ul><p>不过简单来说，可以渲染第一帧，中间帧，最后一帧，加上预览的动画，基本能解决大部分的问题了。</p><h2 id="Part14-Finale"><a href="#Part14-Finale" class="headerlink" title="Part14: Finale"></a>Part14: Finale</h2><p>不得不说，这就是做好的Blender入门教程。</p><h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>休息了几天，终于要开始学Blender的人物制作了，先看看<a href="https://www.youtube.com/watch?v=0k8yFiTE0PU&amp;list=PLvgIVNDU-Dxi5h3JLNJMfK0t3-WsBm6Av&amp;index=3%E3%80%82">https://www.youtube.com/watch?v=0k8yFiTE0PU&amp;list=PLvgIVNDU-Dxi5h3JLNJMfK0t3-WsBm6Av&amp;index=3。</a></p>]]></content>
      
      
      <categories>
          
          <category> 艺术 </category>
          
          <category> 模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Blender的三维Logo</title>
      <link href="/2025/03/31/%E8%89%BA%E6%9C%AF/Logo%E8%AE%BE%E8%AE%A1/"/>
      <url>/2025/03/31/%E8%89%BA%E6%9C%AF/Logo%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><p>Due to it is a 3D logo, I decide to use Blender but not PS or AI.</p><h1 id="Meanings"><a href="#Meanings" class="headerlink" title="Meanings"></a>Meanings</h1><p>In any 3D softwares, there is an axis which is consisting of three colored arrows.</p><p>So I use three ‘Z’ words to make up my logo.</p><p>Moreover, different color is a symbol of different spirit which you can search on this web site <a href="https://www.color-name.com/">https://www.color-name.com/</a>.</p><p>Red(X axis): Passion, #92162D(Red Passion Color). Red is a very eye-catching color. It commands attention and gives off a feeling of energy, vitality, confidence, power, and aggression. It is also the color of danger and is often used in warning signs and road signals.</p><p>Green(Y axis): Growth, #BCF4A5(Refresh Green Color)&#x2F;#4FAD27(Nature Green Color)&#x2F;#236F21(Natural Green Color). Refreshing and rejuvenating, green is commonly linked to nature and as such, is often used to signify growth, renewal, life, and prosperity.</p><p>Blue(Z axis): Creativity, #2522CA(Permanent Blue Color). As the color of the ocean and the sky, blue brings about feelings of freedom, serenity, and reliability. It encourages open-mindedness and allows a person to think freely, going beyond the restraints of society and normal expectations.</p><p>Also, ‘Z’ is the biggest element.</p><h1 id="More-details"><a href="#More-details" class="headerlink" title="More details"></a>More details</h1><ol><li>Although use some bolder or stronger color make the logo be ugly, meaning is more important. Or just use lighter color like this.</li></ol><p><img src="/img/Logo%E8%AE%BE%E8%AE%A1/LogoDraft.png"></p><ol start="2"><li><p>Withous light, render directly.</p></li><li><p>Use PS to change the background to transparent.</p></li></ol><p><img src="/img/Logo%E8%AE%BE%E8%AE%A1/LogoVersion1Transparent.png"></p>]]></content>
      
      
      <categories>
          
          <category> 艺术 </category>
          
          <category> 模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于OpenGL的光栅化渲染管线</title>
      <link href="/2025/03/31/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
      <url>/2025/03/31/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在写游戏引擎，在这里将主要记录一下如何架构跨平台的 <strong>Rendering Pipeline</strong>。</p><p>在大部分人眼中，这就是 <strong>Rendering Pipeline</strong>，但是其实这只能说是 <strong>Shader Pipeline</strong>，真正的渲染管线远比这更加复杂。</p><p><img src="/img/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/Pipeline.jpg"></p><h1 id="光栅化的渲染管线"><a href="#光栅化的渲染管线" class="headerlink" title="光栅化的渲染管线"></a>光栅化的渲染管线</h1><h2 id="固定的渲染管线"><a href="#固定的渲染管线" class="headerlink" title="固定的渲染管线"></a>固定的渲染管线</h2><p>这是早期架构的渲染管线，因为引擎的交互还不完善，所以暂时不需要考虑动态的情况。</p><pre><code>Rendering/    RenderingInterface.hpp    Platform/        Windows/            WindowsRenderingPipeline.hpp            WindowsRenderingPipelineState.hpp            DirectXInterface.hpp        Android/            AndroidRenderingPipeline.hpp            AndroidRenderingPipelineState.hpp            OpenGLInterface.hppGameObject/    GOManage.hpp    Mesh/        StaticMesh.hpp</code></pre><h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h3><p>对于引擎来说，渲染模块将只暴露出以下几个接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PreInit</span>();</span><br><span class="line"><span class="built_in">Init</span>();</span><br><span class="line"><span class="built_in">PostInit</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Tick</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">InitExit</span>();</span><br><span class="line"><span class="built_in">Exit</span>();</span><br><span class="line"><span class="built_in">PostExit</span>();</span><br></pre></td></tr></table></figure><h4 id="WindowsRenderingPipeline-hpp"><a href="#WindowsRenderingPipeline-hpp" class="headerlink" title="WindowsRenderingPipeline.hpp"></a>WindowsRenderingPipeline.hpp</h4><p>继承 <strong>RenderingInterface</strong> 同时调用 <strong>DirectXInterface</strong> 中提供的 <strong>API</strong>。</p><h5 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h5><p>主要是根据 <strong>Windows</strong> 传入的命令对 <strong>DirectX</strong> 进行初始化。</p><p>具体有创建驱动器和工厂（保证创建出驱动器），再用驱动去创建围栏（同步 <strong>CPU</strong> 和 <strong>GPU</strong>），命令队列，堆（存储视图，视图记录了数据在相应缓冲中的偏移地址和长度，是一种数据标识符）以及交换链。</p><p><img src="/img/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/Init.jpg"></p><p>之后再调用 <strong>WindowsRenderingPipelineState</strong> 创建管线状态对象（<strong>PSO</strong>）。</p><h5 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h5><p><img src="/img/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/Tick.jpg"></p><p><strong>Tick</strong> 其实没什么要讲的，就跟画画一样，清除、绘制和等待。</p><p>就是绘制之前要更新数据，关于 <strong>GPU</strong> 和 <strong>CPU</strong> 在读写数据时怎么保证安全就是另外的问题了。</p><h5 id="Exit"><a href="#Exit" class="headerlink" title="Exit"></a>Exit</h5><h4 id="WindowsRenderingPipelineState-hpp"><a href="#WindowsRenderingPipelineState-hpp" class="headerlink" title="WindowsRenderingPipelineState.hpp"></a>WindowsRenderingPipelineState.hpp</h4><p><img src="/img/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/PostInit.jpg"></p><ol><li><p>创建根签名，绑定常量缓冲区描述表的起始地址到寄存器中。</p></li><li><p>构建 <strong>Shader</strong>。</p></li><li><p>提交模型数据至 <strong>buffer</strong> 中需要遍历 <strong>GOManage.hpp</strong> 中储存 <strong>GameObject</strong> 的数组获得顶点数据和索引，用 <strong>OpenGL</strong> 的话说就是 <strong>VAO</strong>，<strong>VBO</strong>和<strong>IBO</strong>。</p></li><li><p>构建常量描述堆（存放常量缓冲区视图）。</p></li><li><p>构建常量缓冲区，目前来说，所有的 <strong>GameObject</strong> 共用一个常量缓冲区，通过为每一个 <strong>GameObject</strong> 创建一个常量缓冲区视图来分割常量缓冲区，相机的视角投影矩阵单独存放在一个常量缓冲区中。</p></li><li><p>最后是一些设置，包括配置光栅化状态，混合模式等等。</p></li></ol><h2 id="动态的渲染管线"><a href="#动态的渲染管线" class="headerlink" title="动态的渲染管线"></a>动态的渲染管线</h2><p>动态的渲染管线估计会参考<a href="https://www.gamedeveloper.com/programming/designing-a-modern-cross-platform-low-level-graphics-library">这篇文章</a>和<a href="https://github.com/DiligentGraphics/DiligentEngine">他们的引擎</a>。</p><h1 id="光线追踪的渲染管线"><a href="#光线追踪的渲染管线" class="headerlink" title="光线追踪的渲染管线"></a>光线追踪的渲染管线</h1><h1 id="Mesh-Pipeline"><a href="#Mesh-Pipeline" class="headerlink" title="Mesh Pipeline"></a>Mesh Pipeline</h1>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> 渲染 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Games101学习笔记</title>
      <link href="/2025/03/31/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/03/31/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>感觉自己一开始没有认真学，所以现在基础有点差，最近打算重学一遍，该手推就手推，不偷懒了。</p><p>这次主要是跟着 <a href="https://space.bilibili.com/512313464"><strong>GAMES-Webinar</strong></a> 的课程学习，所以如果你想要看懂这份笔记，我建议先去学习相应的课程。</p><h1 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h1><h2 id="View-transformation"><a href="#View-transformation" class="headerlink" title="View transformation"></a>View transformation</h2><p>相机需要设置的参数。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/CameraSetting.jpg"></p><p>将相机平移至原点并同时将 <strong>look at</strong> 和 <strong>up</strong> 及其叉乘共三个向量同时对其标准坐标轴的矩阵即为 <strong>View matrix</strong>。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ViewTransformation.jpg"></p><p>唯一要注意的就是由于直接计算旋转矩阵比较复杂（从任意向量变换到标准坐标轴），所以先计算其逆矩阵（从标准坐标轴变换到任意向量）。</p><h2 id="Projection-transformation"><a href="#Projection-transformation" class="headerlink" title="Projection transformation"></a>Projection transformation</h2><p>其实只要求从四棱台压缩到矩形的矩阵就行了。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(1).jpg"></p><p>直觉上其实很容易得出结论，难点在于求出相应的变换矩阵。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(2).jpg"></p><p>为了计算出来就得补充两个假设。</p><blockquote><p>Any point on the near plane will not change<br>Any point’s z on the far plane will not change</p></blockquote><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(3).jpg"><br><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(4).jpg"></p><p>解方程后也能求出来最后的投影矩阵（还需要用 <strong>FOV</strong> 和长宽比进行参数替代）。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(5).jpg"></p><p>最后再通过正交矩阵映射到 <strong>NDC</strong> 空间。</p><p>补充一点，如果不出意外的话四棱台向长方体的挤压方向是这样的。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(6).jpg"></p><p>因为如果不做出第二条假设，所有的点都会向法线（垂直边方向）挤压，第二条假设的存在使挤压形变变少，速度变慢。</p><h2 id="欧拉角，旋转矩阵和四元数"><a href="#欧拉角，旋转矩阵和四元数" class="headerlink" title="欧拉角，旋转矩阵和四元数"></a>欧拉角，旋转矩阵和四元数</h2><h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/EulerAngle.jpg"></p><p>万向锁就是旋转过程中，任意两轴重合，导致旋转轴的缺失。</p><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/Matrix.jpg"></p><p>唯一的缺点就是不方便插值。</p><h3 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h3><p>四元数的话就看 <strong>3B1B</strong> 的视频吧。</p><blockquote><p>四元数是一种具有四个实数分量的超复数。四元数也可以用于表示三维空间中的旋转，其中三个实数分量表示旋转轴的方向，第四个实数分量表示旋转的角度大小。四元数在旋转计算中具有很多优点，例如不存在万向锁问题，计算量小，而且可以很容易地插值和球面插值。然而，使用四元数需要对其进行规范化处理，而且理解四元数可能需要更多的数学知识。</p></blockquote><h1 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h1><p>光栅化的本质就是采样（没有配图是因为希望每次看到这句话的时候都能自己去想象这张图片）。</p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><blockquote><p>在采样过程中，每个像素的颜色值是由周围像素颜色值插值得到的，因此如果周围像素颜色值发生了剧烈变化，那么插值得到的像素颜色值就会出现锯齿状的边缘。这种锯齿现象是因为高频分量没有被滤波掉导致的。</p></blockquote><h3 id="MSAA-和-FXAA"><a href="#MSAA-和-FXAA" class="headerlink" title="MSAA 和 FXAA"></a>MSAA 和 FXAA</h3><ul><li><p>实现方式：FXAA是一种基于像素的反走样技术，它使用特定的颜色滤波器对像素进行处理，从而实现反走样的效果。而 MSAA 则是一种基于多个采样点的反走样技术，它在采样点周围绘制多个采样点，然后对采样点进行平均化处理，从而实现反走样的效果。</p></li><li><p>渲染速度</p></li><li><p>效果质量：FXAA 相对于 MSAA 来说效果稍逊一些，因为它只是对像素进行颜色滤波处理，容易出现图像过度平滑和模糊等问题。而 MSAA 则可以更好地保留图像的细节和清晰度，但是需要更多的计算资源。</p></li><li><p>适用范围</p></li></ul><blockquote><p>特定的颜色滤波器是指针对图像中特定类型的边缘和锯齿问题而设计的一种颜色滤波器。在 FXAA 中，采用了一种基于 Luma 值（亮度）的颜色滤波器，通过计算像素周围的亮度值来检测出可能的边缘和锯齿，并将其进行平滑处理，从而达到反走样的效果。</p><p>这种颜色滤波器主要是通过将图像中相邻的像素进行比较，并根据它们之间的颜色和亮度差异来判断是否存在边缘和锯齿，并对这些像素进行颜色和亮度的平滑处理，从而消除图像中的锯齿和边缘问题。这种处理方式不需要对图像进行多次采样或绘制额外的像素，因此可以在较短的时间内完成反走样处理，并且对于移动设备、游戏主机和低端PC等设备来说具有很好的适用性。</p></blockquote><h3 id="TAA-Temporal-Anti-Aliasing"><a href="#TAA-Temporal-Anti-Aliasing" class="headerlink" title="TAA(Temporal Anti-Aliasing)"></a>TAA(Temporal Anti-Aliasing)</h3><blockquote><p>传统的空域反走样技术往往会导致图像失去一些细节和清晰度，而时域反走样技术可以利用前一帧和当前帧之间的信息来进行反走样处理，从而避免这种问题。</p><p>TAA 通过利用前一帧和当前帧之间的运动信息，以及图像的深度信息等，计算出运动向量，并将当前帧的像素颜色与前一帧进行混合，从而得到一个平滑的图像。具体来说，它将前一帧的像素颜色投影到当前帧上，并计算出两帧之间的运动向量，然后将当前帧的像素颜色与投影的像素颜色进行混合，从而得到反走样效果。</p><p>TAA 不仅可以减少锯齿状边缘和走样等问题，还可以增强图像的清晰度和细节。但是，它也会带来一些副作用，比如图像可能会出现闪烁和模糊等问题。因此，使用 TAA 需要进行适当的调节和优化，以平衡反走样效果和图像质量。</p></blockquote><h2 id="超采样"><a href="#超采样" class="headerlink" title="超采样"></a>超采样</h2><h3 id="DLSS-Deep-Learning-Super-Sampling"><a href="#DLSS-Deep-Learning-Super-Sampling" class="headerlink" title="DLSS(Deep Learning Super Sampling)"></a>DLSS(Deep Learning Super Sampling)</h3><h1 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h1><h2 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h2><p>求三角形三点坐标对重心的贡献系数。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/TextureMapping(1).jpg"></p><p>根绝贡献系数就可以实现纹理映射了，不过对于三维坐标（比如深度），就只能在三维空间内插值计算好后再映射到二维空间，因为重心从三维映射到二维后相对坐标会发生偏移。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/TextureMapping(2).jpg"></p><p>三线性插值，猜猜哪来的三个维度？</p><h3 id="纹理过小"><a href="#纹理过小" class="headerlink" title="纹理过小"></a>纹理过小</h3><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/BilinearInterpolation.jpg"></p><h3 id="纹理过大"><a href="#纹理过大" class="headerlink" title="纹理过大"></a>纹理过大</h3><p>由于每个屏幕像素只插值纹理上的一个像素点（即使覆盖了很多像素，也只是像素平均后的一个点），所以会导致走样。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/Mipmap(1).jpg"></p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/Mipmap(2).jpg"></p><h2 id="三维纹理"><a href="#三维纹理" class="headerlink" title="三维纹理"></a>三维纹理</h2><p>核磁共振中会用到。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/3dtexture.jpg"></p><h2 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h2><p>从光源看一遍并把深度值存下来，再从相机看一遍，深度一样就是可见。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ShadowMapping(1).jpg"></p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ShadowMapping(2).jpg"></p><p>就是阴影太硬了，还需要用算法优化。</p><h1 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h1><h2 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h2><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/BezierCurve(1).jpg"></p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/BezierCurve(2).jpg"></p><p>三阶贝塞尔曲线（四个控制点）满足 <strong>C1</strong> 连续，所以是平滑的。</p><h2 id="网格体"><a href="#网格体" class="headerlink" title="网格体"></a>网格体</h2><h3 id="曲面细分"><a href="#曲面细分" class="headerlink" title="曲面细分"></a>曲面细分</h3><p>曲面细分本质就是寻找新的顶点，具体顶点的位置就像平均卷积一样，有周围的点控制。</p><h3 id="曲面简化"><a href="#曲面简化" class="headerlink" title="曲面简化"></a>曲面简化</h3><p>去掉一些点，同时让信息量的变化最少（一个度量函数）。</p><h1 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h1><p>其实同样的模型对于不同的渲染方法，出来的结果也是不一样的。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ShadingFrequence.jpg"></p><h2 id="局部光照"><a href="#局部光照" class="headerlink" title="局部光照"></a>局部光照</h2><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/LocalShading(1).jpg"></p><p>主要就是分成漫反射光，镜面反射光和环境光三部分。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/LocalShading(2).jpg"></p><h3 id="Diffuse-Term-Lambertian"><a href="#Diffuse-Term-Lambertian" class="headerlink" title="Diffuse Term(Lambertian)"></a>Diffuse Term(Lambertian)</h3><h3 id="Specular-Term-Blinn-Phong"><a href="#Specular-Term-Blinn-Phong" class="headerlink" title="Specular Term(Blinn-Phong)"></a>Specular Term(Blinn-Phong)</h3><p>加指数项，可以控制高光的大小（提高阈值）。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/DiffuseReflection(2).jpg"></p><h3 id="Ambient-Term"><a href="#Ambient-Term" class="headerlink" title="Ambient Term"></a>Ambient Term</h3><h2 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h2><h3 id="Whitted-Style-Ray-Tracing"><a href="#Whitted-Style-Ray-Tracing" class="headerlink" title="Whitted-Style Ray Tracing"></a>Whitted-Style Ray Tracing</h3><p>用以下式子表示任一光线。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RayEquation.jpg"></p><h4 id="光线和物体求交"><a href="#光线和物体求交" class="headerlink" title="光线和物体求交"></a>光线和物体求交</h4><p>先粗判断。</p><p><strong>AABB</strong> 包围盒。</p><p>关于如何划分包围盒有许多方案，但目前主要就是这两种。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/Partitions.jpg"></p><p><strong>BVH</strong> 的伪代码如下。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/BVHTraversal.jpg"></p><p>再细判断。</p><p>隐式表达式可以直接代入求。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RayIntersection(1).jpg"></p><p>显示表达式可以转换成求直线与平面的交点。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RayIntersection(2).jpg"></p><h4 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h4><p>我建议看一下<a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/#_1">这篇文章</a>，讲的还是很好的，这里就直接给出公式了。</p><p>主要是要弄清楚辐射通量，辐射度和辐射率的区别。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RenderingEquation(1).jpg"></p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RenderingEquation(2).jpg"></p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RenderingEquation(3).jpg"></p><p>其实如果把左边的 <strong>L</strong> 看作 <strong>Li</strong>，右边的看成 <strong>Li-1</strong> 会比较好理解。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RenderingEquation(5).jpg"></p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RenderingEquation(4).jpg"></p><p>这也是为什么光线追踪是全局光照的原因（事实上一次项的 <strong>PBR</strong> 就是局部光照）。</p><h3 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h3><p>优化光线追踪，通过概率（蒙特卡洛，俄罗斯轮盘赌）来降低计算量，同时保持期望值不变。</p><p>继续优化的话就是采样光源而不是采样物体。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/PathTracing1.jpg"></p><p>将光分成两部分，直接光用改写后的方程计算，间接光用优化后的光线追踪方法计算。</p><p><img src="/img/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/PathTracing2.jpg"></p><p>还讲了许多优化路径追踪的渲染方法。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> 渲染 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DX12渲染管线学习笔记</title>
      <link href="/2025/03/31/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/"/>
      <url>/2025/03/31/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>零散的笔记，是我在学习过程中的思考，自认为简单的东西并不会记录在内。</p><h1 id="Direct3D-基础"><a href="#Direct3D-基础" class="headerlink" title="Direct3D 基础"></a>Direct3D 基础</h1><h2 id="初始化-D3D"><a href="#初始化-D3D" class="headerlink" title="初始化 D3D"></a>初始化 D3D</h2><h3 id="Factory-和-Device"><a href="#Factory-和-Device" class="headerlink" title="Factory 和 Device"></a>Factory 和 Device</h3><p>说实话 <strong>DirectX</strong> 中的架构思路真的值得去学习，这里的工厂和驱动都是蕴含了很多的设计思想的，但我目前还不能真正的理解。</p><p><img src="/img/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/InitializeD3D.jpg"></p><h3 id="WRAP"><a href="#WRAP" class="headerlink" title="WRAP"></a><a href="https://learn.microsoft.com/en-us/windows/win32/direct3darticles/directx-warp">WRAP</a></h3><p>应该不需要去写它的意义吧，猜猜就知道了。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>个人感觉 <strong>CommandList</strong> 类似于资源描述符，而 <strong>CommandAllocator</strong> 类似于缓冲区，将 <strong>CommandList</strong> 中的命令传入 <strong>CommandQueue</strong> 中，但是 <strong>CommandAllocator</strong> 还是原来的，这也是为什么在 <strong>CommandQueue</strong> 的命令被执行完前不能重置 <strong>CommandAllocator</strong>。</p><h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><p>目前这里指的就是普通的光栅化流水线。</p><p><img src="/img/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/RenderingPipeline.jpg"></p><p>这里特地拍了一张我在书上的笔记，是想展示一下数据的流向。</p><h3 id="Step1-内存数据流向显存"><a href="#Step1-内存数据流向显存" class="headerlink" title="Step1 内存数据流向显存"></a>Step1 内存数据流向显存</h3><p>可以先到后面看一下流水线状态，可以发现主要就是绑定根签名表和 <strong>Shader</strong>，缓冲区都是在创建时绑定的，当然绑定的都是描述符，绑定数据的话带宽直接废掉了。</p><p><img src="/img/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/BindBuffer.jpg"></p><p>书里也说得很清楚了绑定的时候 <strong>GPU</strong> 会自动创建描述符和堆，<strong>GPU</strong> 会在需要用到数据的时候将数据存入显存中（闲时存入，减少带宽消耗）。</p><p><strong>Vertex Buffer</strong>、<strong>Index Buffer</strong> 和 <strong>Constant Buffer</strong> 的创建与提交在第六章都有详细介绍，阅读之前一定要对描述符、视图、描述表以及描述堆等名词有足够的理解。</p><p><img src="/img/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/VertexBuffer.jpg"></p><p>关于为什么 <strong>RTV</strong> 不用绑定，个人认为应该是直接封装在 <strong>CreateRenderTargetView</strong> 里了。</p><h3 id="Step2-显存数据流向显存"><a href="#Step2-显存数据流向显存" class="headerlink" title="Step2 显存数据流向显存"></a>Step2 显存数据流向显存</h3><p>由于在曲面细分阶段、域着色阶段和几何着色阶段中，顶点数据会被扩展，所以要把新数据加入显存中，之后再提出来着色。</p><p>这也是传冲渲染管线相较于 <strong>Mesh Pipeline</strong> 的缺点。</p><h3 id="Step3-显存数据流向显存"><a href="#Step3-显存数据流向显存" class="headerlink" title="Step3 显存数据流向显存"></a>Step3 显存数据流向显存</h3><p>这里主要是像比如将光照存入纹理中这样的操作，就需要把纹理存在显存中，以便后续的使用。</p><h3 id="Step4-显存数据流向内存"><a href="#Step4-显存数据流向内存" class="headerlink" title="Step4 显存数据流向内存"></a>Step4 显存数据流向内存</h3><p>说实话也不一定是流向内存，可能只是放在了全局显存里，让 <strong>CPU</strong> 自己去读取。</p><p>关于对显存中数据的驻留，<strong>DX12</strong> 也是提供了底层的 <strong>API</strong> 供程序员主动管理，但是龙书中并没有说明具体的操作方法，详细的资料可以阅读《Residency（驻留）》或者去看官方的 <strong>API</strong>，这应该能带来不小的优化。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> 渲染 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏引擎架构阅读笔记</title>
      <link href="/2025/03/30/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/"/>
      <url>/2025/03/30/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不只是阅读《游戏引擎架构》的笔记，更多的是做引擎时的心得。</p><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><p>版本控制、项目构建等等其它方面的工具自选就行，好用就完事了。</p><h1 id="引擎核心层"><a href="#引擎核心层" class="headerlink" title="引擎核心层"></a>引擎核心层</h1><h2 id="引擎入口"><a href="#引擎入口" class="headerlink" title="引擎入口"></a>引擎入口</h2><p>建立 <strong>Engine</strong> 的基类，同时在 <strong>main&#x2F;WinMain</strong> 中创建 <strong>Engine</strong>，将其编译成 <strong>Lib</strong> 库后暴露给编辑器，编辑器通过继承 <strong>Engine</strong> 类以实现对引擎的配置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Editor</span> : <span class="keyword">public</span> Engine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Editor</span>() &#123;&#125;;</span><br><span class="line">~<span class="built_in">Editor</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Engine* <span class="title">CreateEngine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Editor *editor = <span class="keyword">new</span> <span class="built_in">Editor</span>();</span><br><span class="line"><span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例化引擎顺序"><a href="#实例化引擎顺序" class="headerlink" title="实例化引擎顺序"></a>实例化引擎顺序</h2><p>书里面说要注意，但我觉得还好，不容易崩，实在不行就用书里面的优先级队列吧。</p><p>不过引用友元也是会初始化的，所以最好还是在 <strong>PreInit</strong> 或者 <strong>Init</strong>中完成。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h2 id="日志管理和计时器"><a href="#日志管理和计时器" class="headerlink" title="日志管理和计时器"></a>日志管理和计时器</h2><p>这种都是自己想怎么弄都行，不会消耗太多性能，不同的日志和计时器和效果也不一样。</p><h2 id="内存管理、GC-和字符流"><a href="#内存管理、GC-和字符流" class="headerlink" title="内存管理、GC 和字符流"></a>内存管理、GC 和字符流</h2><p>建议自己写，不过不用这么早，放到后面当优化点行，字符流也可以考虑用 <strong>QString</strong>。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>自己写工作量太大了，以优化 <strong>STL</strong> 为主（增加算法）。</p><h1 id="引擎资源层"><a href="#引擎资源层" class="headerlink" title="引擎资源层"></a>引擎资源层</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="/img/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/Database.jpg"></p><h2 id="模型导入"><a href="#模型导入" class="headerlink" title="模型导入"></a>模型导入</h2><p>看看这张图吧。</p><p><img src="/img/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/assimp_structure.png"></p><p>直接从<a href="https://learnopengl-cn.github.io/03%20Model%20Loading/01%20Assimp/">这里</a>复制了。</p><ul><li><p>和材质和网格(Mesh)一样，所有的场景&#x2F;模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。</p></li><li><p>场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。</p></li><li><p>一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。</p></li><li><p>一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见你好，三角形）。</p></li><li><p>最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。</p></li></ul><h1 id="引擎功能层"><a href="#引擎功能层" class="headerlink" title="引擎功能层"></a>引擎功能层</h1><p>在这里核心层和功能层的分界并不明确，比如渲染功能的接口是要在核心层（平台层）封装的，而调用则在功能层。</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h3 id="渲染架构"><a href="#渲染架构" class="headerlink" title="渲染架构"></a>渲染架构</h3><p><img src="/img/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/RenderingArchitecture.png"></p><h3 id="渲染层级"><a href="#渲染层级" class="headerlink" title="渲染层级"></a>渲染层级</h3><p>需要一个渲染 <strong>Layer</strong> 以及一个储存 <strong>Layer</strong> 的容器，比如栈或者优先级队列。</p><p>渲染层级很重要，有了它才可以绘制透明物体，制作特效以及 <strong>UI</strong> 等等。</p><h3 id="渲染管道"><a href="#渲染管道" class="headerlink" title="渲染管道"></a>渲染管道</h3><p><img src="/img/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/RenderingPipeline1.jpg"></p><p>这样的渲染管线示意图对程序员更友好。</p><p><img src="/img/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/RenderingPipeline2.jpg"></p><p><img src="/img/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/PVS.jpg"></p><h1 id="引擎工具层"><a href="#引擎工具层" class="headerlink" title="引擎工具层"></a>引擎工具层</h1><p>最重要的就是反射（数据解析）了。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础篇</title>
      <link href="/2025/03/17/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A000/"/>
      <url>/2025/03/17/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A000/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没更新了，之后尽量日更，最近在 gap，下半年去北欧读研，最近就随便学点感兴趣的东西。</p><p>我会尽量研究的透彻点，到研一的 level 吧（hope），代码基本都会附，但不会给全，不然你们都不思考。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="Artificial-Intelligence"><a href="#Artificial-Intelligence" class="headerlink" title="Artificial Intelligence"></a>Artificial Intelligence</h2><p>模拟人类的行为来解决问题。</p><h2 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h2><p>和传统算法的区别在于目的是发现规律（Rules），和不是获取结果。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/1.jpg"></p><h2 id="Deep-Learning-x2F-Neural-Networks"><a href="#Deep-Learning-x2F-Neural-Networks" class="headerlink" title="Deep Learning &#x2F; Neural Networks"></a>Deep Learning &#x2F; Neural Networks</h2><p>相比于 ML，多了很多中间层。</p><pre><code>NN 不是模拟人脑。</code></pre><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/2.jpg"></p><h1 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h1><p>分成 <strong>Search</strong>，<strong>Knowledge</strong>，<strong>Uncertainty</strong>，<strong>Optimization</strong>，<strong>Learning</strong>，<strong>Neural Networks</strong> 和 <strong>Language</strong> 七个 Part 来理解 AI。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Harvard CS50’s Artificial Intelligence with Python – Full University Course</p><p>Machine Learning with Python Certification | freeCodeCamp.org</p><p>以及其他补充资料。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何从RNN走向LSTM和GRU</title>
      <link href="/2025/03/06/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B908/"/>
      <url>/2025/03/06/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B908/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么会出现LSTM和GRU呢？"><a href="#为什么会出现LSTM和GRU呢？" class="headerlink" title="为什么会出现LSTM和GRU呢？"></a>为什么会出现LSTM和GRU呢？</h1><p>因为 RNN 会出现梯度消失和梯度爆炸，梯度消失就意味着模型缺少长期记忆。</p><pre><code>如果你问我为什么 RNN 会出现梯度消失，这是由它的训练公式决定的。</code></pre><h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><p>这也解释了为什么 LSTM 多加了一条贯穿时间的，<strong>不直接施加任何权重的</strong> cell state，就是为了解决梯度消失的问题，从而获取长期记忆。</p><p>理解了这一点，也许你再看 LSTM 的流程就会豁然开朗了，这边推荐油管上的一个视频 <a href="https://www.youtube.com/watch?v=YCzL96nL7j0%EF%BC%8C%E5%AE%83%E7%94%9A%E8%87%B3%E8%BF%98%E4%B8%BE%E4%BA%86%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%9A%84%E4%BE%8B%E5%AD%90%E3%80%82">https://www.youtube.com/watch?v=YCzL96nL7j0，它甚至还举了一个计算的例子。</a></p><p><img src="/img/AI%E7%9F%A5%E8%AF%86%E7%82%B9/9.png"></p><p>最后来解决最关键的问题：为什么 LSTM 是这样的结构？一个遗忘门，一个输入门，一个输出门？</p><p>本质其实就是在<strong>用最简单的模型模拟人的记忆过程</strong>，遗忘门决定了长期记忆里多少要被遗忘，输入门决定了新的记忆要加入多少，输出门决定了记忆的输出，同时这也是研究人员用各种参数和模型结构<strong>测试出来的结果</strong>。</p><p><strong>切记不要神话任何模型的诞生，因为你只看到了最后的结果。</strong></p><h1 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h1><p>GRU 其实就是 LSTM 的<strong>简化版</strong>，它把遗忘门和输入门合并成了一个更新门，这样就减少了参数，也减少了计算量。</p><p><img src="/img/AI%E7%9F%A5%E8%AF%86%E7%82%B9/10.png"></p><p>为什么这么做呢？</p><p>因为 LSTM 的参数太多，训练起来太慢，而且容易过拟合。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习的本质</title>
      <link href="/2025/02/28/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B907/"/>
      <url>/2025/02/28/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B907/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要想讲清楚深度学习的本质，就要先从显示编程和隐式编程开始讲起。</p><h1 id="显示编程"><a href="#显示编程" class="headerlink" title="显示编程"></a>显示编程</h1><p>所谓显示编程，顾名思义，就是咱们让计算机干什么，计算机就干什么，比如让计算机走迷宫，我们就是让它上下左右都试探一边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">maze</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> at_end(maze):</span><br><span class="line">        <span class="keyword">for</span> direction <span class="keyword">in</span> [<span class="string">&#x27;up&#x27;</span>, <span class="string">&#x27;down&#x27;</span>, <span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;right&#x27;</span>]:</span><br><span class="line">            <span class="keyword">if</span> can_move(maze, direction):</span><br><span class="line">                move(maze, direction)</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="隐式编程"><a href="#隐式编程" class="headerlink" title="隐式编程"></a>隐式编程</h1><p>隐式编程其实就是指人工智能中的那些学习方法，它就是由机器学习之父提出来的，旨在不通过显示的告诉计算机怎么做，就能让计算机自己学会怎么做。</p><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>为了方便理解，所以我这里只讨论线性回归的方案，线性回归从本质上来说就是只有输入层和输出层的神经网络。</p><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>深度学习的提出其实就是为了让机器学习在特征提取时也能做到隐式编程，也就是说那些中间层就是用来提取特征的。</p><p>而正如当时机器学习被评价的一样，要想获得好结果，最重要的是特征提取而不是最后的拟合算法，所以深度学习的研究也正是在构建更好的模型提取出更重要的特征。</p><p>而怎么样才能让模型提取出更好的特征呢？或者说什么样的模型可以提取出来什么样的特征呢？</p><p>由于模型是黑盒，所以需要可视化的辅助，至于怎么可视化权重，其实现在已经有挺多方案了，具体就留以后再讲了。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch神经网络训练全流程</title>
      <link href="/2025/02/27/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B906/"/>
      <url>/2025/02/27/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B906/</url>
      
        <content type="html"><![CDATA[<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>直接给大家看代码吧，完整代码在这 <a href="https://github.com/zong4/Kaggle%EF%BC%8Cfunctions">https://github.com/zong4/Kaggle，functions</a> 的那些函数干了什么基本也就是字面意思（剔除一些没用的列然后归一化，再把字符串列进行one-hot编码）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load data</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">basic_path = <span class="string">&#x27;house-prices-advanced-regression-techniques&#x27;</span></span><br><span class="line">train_data = pd.read_csv(basic_path + <span class="string">&quot;/train.csv&quot;</span>)</span><br><span class="line">test_data = pd.read_csv(basic_path + <span class="string">&quot;/test.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare environment</span></span><br><span class="line"><span class="keyword">import</span> functions_pytorch</span><br><span class="line"></span><br><span class="line">functions_pytorch.set_seed(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract target variable</span></span><br><span class="line">train_labels = train_data[<span class="string">&#x27;SalePrice&#x27;</span>]</span><br><span class="line">train_data.drop([<span class="string">&#x27;SalePrice&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Data preprocessing</span></span><br><span class="line"><span class="keyword">import</span> functions</span><br><span class="line"></span><br><span class="line">train_data = functions.drop_useless_cols(train_data, test_data)</span><br><span class="line"></span><br><span class="line">train_data.drop([<span class="string">&#x27;Id&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">train_data = functions.drop_cols_with_same_data(train_data, <span class="number">0.9</span>)</span><br><span class="line">train_data = functions.drop_cols_with_na(train_data, <span class="number">0.8</span>)</span><br><span class="line">train_data = functions.fill_na_with_mean(train_data)</span><br><span class="line">train_data = functions.normalize(train_data)</span><br><span class="line">train_data = functions.one_hot_encoding(train_data)</span><br><span class="line"><span class="built_in">print</span>(train_data.info())</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(train_data.head())</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">test_data.drop([<span class="string">&#x27;Id&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">test_data = functions.fill_na_with_mean(test_data)</span><br><span class="line">test_data = functions.normalize(test_data)</span><br><span class="line">test_data = functions.one_hot_encoding(test_data)</span><br><span class="line"></span><br><span class="line">test_data = functions.drop_useless_cols(test_data, train_data)</span><br><span class="line">test_data = functions.add_missing_dummy_columns(test_data, train_data)</span><br></pre></td></tr></table></figure><h1 id="模型设置"><a href="#模型设置" class="headerlink" title="模型设置"></a>模型设置</h1><p>这里主要是自定义模型和 Dataset，大家改的话也就改模型就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set up model</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"><span class="keyword">from</span> torchsummary <span class="keyword">import</span> summary</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HousePricesDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data, labels</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.labels = labels</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):    </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = torch.tensor(self.data.iloc[idx].values.astype(<span class="string">&#x27;float32&#x27;</span>))</span><br><span class="line">            label = torch.tensor(self.labels.iloc[idx].astype(<span class="string">&#x27;float32&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> data, label</span><br><span class="line">        <span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;KeyError: <span class="subst">&#123;e&#125;</span> at index <span class="subst">&#123;idx&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Unexpected error: <span class="subst">&#123;e&#125;</span> at index <span class="subst">&#123;idx&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_dim</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(input_dim, <span class="number">128</span>)</span><br><span class="line">        self.dropout1 = nn.Dropout(<span class="number">0.2</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.dropout2 = nn.Dropout(<span class="number">0.2</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">64</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = torch.relu(self.fc1(x))</span><br><span class="line">        x = self.dropout1(x)</span><br><span class="line">        x = torch.relu(self.fc2(x))</span><br><span class="line">        x = self.dropout2(x)</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">model = Net(train_data.shape[<span class="number">1</span>])</span><br><span class="line">summary(model, input_size=(train_data.shape[<span class="number">1</span>],))</span><br><span class="line">model.to(functions_pytorch.device)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><p>我这里用的是K折交叉验证，大家也可以直接分割数据集然后调用 functions_pytorch.train_model()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Train model with KFold cross validation</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">k = <span class="number">5</span></span><br><span class="line">num_epochs = <span class="number">100</span></span><br><span class="line">batch_size = <span class="number">32</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">criterion = functions_pytorch.RMSLELoss()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_kfold</span>(<span class="params">train_data, train_labels, model, criterion, optimizer, k</span>):</span><br><span class="line">    kf = KFold(n_splits=k, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> train, val <span class="keyword">in</span> kf.split(train_data):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Fold <span class="subst">&#123;cnt&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        train_data_fold = train_data.iloc[train]</span><br><span class="line">        train_labels_fold = train_labels.iloc[train]</span><br><span class="line">        val_data_fold = train_data.iloc[val]</span><br><span class="line">        val_labels_fold = train_labels.iloc[val]</span><br><span class="line"></span><br><span class="line">        train_dataset = HousePricesDataset(train_data_fold, train_labels_fold)</span><br><span class="line">        train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">        val_dataset = HousePricesDataset(val_data_fold, val_labels_fold)</span><br><span class="line">        val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        train_losses, val_losses = functions_pytorch.train_model(model, criterion, optimizer, train_loader, val_loader, num_epochs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Plot losses</span></span><br><span class="line">        plt.clf()</span><br><span class="line">        plt.plot(train_losses, label=<span class="string">&#x27;Train Loss&#x27;</span>)</span><br><span class="line">        plt.plot(val_losses, label=<span class="string">&#x27;val Loss&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;Training and Validation Loss&#x27;</span>)</span><br><span class="line">        plt.savefig(basic_path + <span class="string">f&#x27;/loss_fold_<span class="subst">&#123;cnt&#125;</span>.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">train_kfold(train_data, train_labels, model, criterion, optimizer, k)</span><br></pre></td></tr></table></figure><p>MSLELoss 是我自己定义的损失函数，大家可以看看怎么实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Logarithmic root mean squared error</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RMSLELoss</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(RMSLELoss, self).__init__()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, pred, actual</span>):</span><br><span class="line">        pred = torch.clamp(pred, <span class="built_in">min</span>=<span class="number">0</span>)</span><br><span class="line">        actual = torch.clamp(actual, <span class="built_in">min</span>=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> torch.sqrt(torch.mean((torch.log(pred + <span class="number">1</span>) - torch.log(actual + <span class="number">1</span>)) ** <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>训练模型的代码主要是下面这样，我是10步打印一次损失值，但是因为我可以一折画一次图，所以我也不需要把输出做的很频繁，知道在跑就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Train model</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">model, criterion, optimizer, train_loader, val_loader, num_epochs</span>):</span><br><span class="line">    train_losses = []</span><br><span class="line">    val_losses = []</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> i, (data, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            outputs = model(data.to(device))</span><br><span class="line">            loss = criterion(outputs, labels.to(device).view(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        train_losses.append(loss.item())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> val_loader:</span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                model.<span class="built_in">eval</span>()</span><br><span class="line">                total_loss = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> data, labels <span class="keyword">in</span> val_loader:</span><br><span class="line">                    outputs = model(data.to(device))</span><br><span class="line">                    total_loss += criterion(outputs, labels.to(device).view(-<span class="number">1</span>, <span class="number">1</span>)).item()</span><br><span class="line">                val_losses.append(total_loss / <span class="built_in">len</span>(val_loader))</span><br><span class="line">                model.train()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> val_loader:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;num_epochs&#125;</span>, Train Loss: <span class="subst">&#123;train_losses[-<span class="number">1</span>]&#125;</span>, Val Loss: <span class="subst">&#123;val_losses[-<span class="number">1</span>]&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;num_epochs&#125;</span>, Train Loss: <span class="subst">&#123;train_losses[-<span class="number">1</span>]&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> train_losses, val_losses</span><br></pre></td></tr></table></figure><h1 id="模型预测"><a href="#模型预测" class="headerlink" title="模型预测"></a>模型预测</h1><p>这一块具体怎么写还是要看输出格式，我这不是 Kaggle 的格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Predict test data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict_test_data</span>(<span class="params">model, test_data</span>):</span><br><span class="line">    <span class="comment"># Train model with all data</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Train model with all data&quot;</span>)</span><br><span class="line">    train_dataset = HousePricesDataset(train_data, train_labels)</span><br><span class="line">    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">    functions_pytorch.train_model(model, criterion, optimizer, train_loader, <span class="literal">None</span>, num_epochs)</span><br><span class="line"></span><br><span class="line">    test_dataset = HousePricesDataset(test_data, pd.Series([<span class="number">0</span>] * <span class="built_in">len</span>(test_data)))</span><br><span class="line">    test_loader = DataLoader(test_dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    predictions = []</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        model.<span class="built_in">eval</span>()</span><br><span class="line">        <span class="keyword">for</span> data, _ <span class="keyword">in</span> test_loader:</span><br><span class="line">            outputs = model(data.to(functions_pytorch.device))</span><br><span class="line">            predictions.append(outputs.item())</span><br><span class="line">        model.train()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="keyword">return</span> predictions</span><br><span class="line"><span class="comment"># best_model_path = &#x27;model_fold_5.pth&#x27;</span></span><br><span class="line"><span class="comment"># model.load_state_dict(torch.load(best_model_path))</span></span><br><span class="line">predictions = predict_test_data(model, test_data)</span><br><span class="line"></span><br><span class="line">submission = pd.DataFrame(&#123;<span class="string">&#x27;Id&#x27;</span>: test_data.index + <span class="number">1461</span>, <span class="string">&#x27;SalePrice&#x27;</span>: predictions&#125;)</span><br><span class="line">submission.to_csv(basic_path + <span class="string">&#x27;/submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(submission.head())</span><br></pre></td></tr></table></figure><h1 id="模型的加载和保存"><a href="#模型的加载和保存" class="headerlink" title="模型的加载和保存"></a>模型的加载和保存</h1><p>这一块我原本写了，但是后来发现不需要我就又删掉了，就留给大家自行思考了。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning篇（二），用强化学习玩尼姆（取物）游戏并泛化至任意情况</title>
      <link href="/2025/02/26/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A013/"/>
      <url>/2025/02/26/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A013/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很快啊，今天的第二篇，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h1><p>终于来到我最喜欢的强化学习了。</p><p>强化学习中各要素的关系如图所示。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/35.png"></p><ul><li>环境会告诉代理目前的状态，由此可以推出代理可以作出的行动。</li><li>代理根据自己的判断选择行动后，环境会给出相应的惩罚或者奖励。</li><li>不断循环上面两步直到代理成功或者失败。</li><li>继续训练，不断的开始下一局游戏</li></ul><p>OK，那接下来我们就来看个例子吧。</p><h1 id="尼姆（取物）游戏"><a href="#尼姆（取物）游戏" class="headerlink" title="尼姆（取物）游戏"></a>尼姆（取物）游戏</h1><p>给大家看一眼应该大家就知道怎么玩了，我这里的话是谁最后取完谁输。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/36.png"></p><pre><code>小潮院长他们最新一期羊村也玩了。</code></pre><h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><p>这里用的学习算法是 Q-learning，公式如下。</p><p>$$Q(s, a) &lt;- Q(s, a) + alpha * (new_value_estimate - old_value_estimate)$$</p><p>其中 alpha 是学习率，new_value_estimate &#x3D; reward（现阶段的奖励）+ best_future_reward（未来最大的奖励）。</p><p>具体实现主要是下面的 update(self, old_state, action, new_state, reward)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NimAI</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, alpha=<span class="number">0.5</span>, epsilon=<span class="number">0.1</span></span>):</span><br><span class="line">        self.q = <span class="built_in">dict</span>()</span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, old_state, action, new_state, reward</span>):</span><br><span class="line">        old = self.get_q_value(old_state, action)</span><br><span class="line">        best_future = self.best_future_reward(new_state)</span><br><span class="line">        self.update_q_value(old_state, action, old, reward, best_future)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_q_value</span>(<span class="params">self, state, action</span>):</span><br><span class="line">        <span class="keyword">return</span> self.q.get((<span class="built_in">tuple</span>(state), action), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_q_value</span>(<span class="params">self, state, action, old_q, reward, future_rewards</span>):</span><br><span class="line">        self.q[(<span class="built_in">tuple</span>(state), action)] = old_q + self.alpha * (reward + future_rewards - old_q)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">best_future_reward</span>(<span class="params">self, state</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> Nim.available_actions(state):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>([self.get_q_value(state, action) <span class="keyword">for</span> action <span class="keyword">in</span> Nim.available_actions(state)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">choose_action</span>(<span class="params">self, state, epsilon=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="comment"># Return best action</span></span><br><span class="line">        <span class="keyword">if</span> epsilon:</span><br><span class="line">            <span class="keyword">if</span> random.random() &lt; self.epsilon:</span><br><span class="line">                <span class="keyword">return</span> random.choice(<span class="built_in">list</span>(Nim.available_actions(state)))</span><br><span class="line">        </span><br><span class="line">        best_action = <span class="literal">None</span></span><br><span class="line">        best_q = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> action <span class="keyword">in</span> Nim.available_actions(state):</span><br><span class="line">            q = self.get_q_value(state, action)</span><br><span class="line">            <span class="keyword">if</span> q &gt; best_q:</span><br><span class="line">                best_q = q</span><br><span class="line">                best_action = action</span><br><span class="line">        <span class="keyword">return</span> best_action</span><br></pre></td></tr></table></figure><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>训练的代码如下，这里只需要最后一步有给奖励，诶，这就是算法神奇的地方了。</p><p>主要是因为上面的 Q-learning 算法更新时会有来自未来的奖励，自然就不断的稀释给前面的行动了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">n</span>):</span><br><span class="line">    player = NimAI()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Play n games</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Playing training game <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">        game = Nim()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Keep track of last move made by either player</span></span><br><span class="line">        last = &#123;</span><br><span class="line">            <span class="number">0</span>: &#123;<span class="string">&quot;state&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;action&quot;</span>: <span class="literal">None</span>&#125;,</span><br><span class="line">            <span class="number">1</span>: &#123;<span class="string">&quot;state&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;action&quot;</span>: <span class="literal">None</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Game loop</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Keep track of current state and action</span></span><br><span class="line">            state = game.piles.copy()</span><br><span class="line">            action = player.choose_action(game.piles)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Keep track of last state and action</span></span><br><span class="line">            last[game.player][<span class="string">&quot;state&quot;</span>] = state</span><br><span class="line">            last[game.player][<span class="string">&quot;action&quot;</span>] = action</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Make move</span></span><br><span class="line">            game.move(action)</span><br><span class="line">            new_state = game.piles.copy()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># When game is over, update Q values with rewards</span></span><br><span class="line">            <span class="keyword">if</span> game.winner <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                player.update(state, action, new_state, -<span class="number">1</span>)</span><br><span class="line">                player.update(</span><br><span class="line">                    last[game.player][<span class="string">&quot;state&quot;</span>],</span><br><span class="line">                    last[game.player][<span class="string">&quot;action&quot;</span>],</span><br><span class="line">                    new_state,</span><br><span class="line">                    <span class="number">1</span></span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># If game is continuing, no rewards yet</span></span><br><span class="line">            <span class="keyword">elif</span> last[game.player][<span class="string">&quot;state&quot;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                player.update(</span><br><span class="line">                    last[game.player][<span class="string">&quot;state&quot;</span>],</span><br><span class="line">                    last[game.player][<span class="string">&quot;action&quot;</span>],</span><br><span class="line">                    new_state,</span><br><span class="line">                    <span class="number">0</span></span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Done training&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the trained AI</span></span><br><span class="line">    <span class="keyword">return</span> player</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>这结果也没法展示，就这么说吧，训练完10000次后，我被 AI 完虐。</p><p>不过我学习了一下必胜法就好多了，目前就是谁先手谁输。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="智能-or-记忆"><a href="#智能-or-记忆" class="headerlink" title="智能 or 记忆"></a>智能 or 记忆</h2><p>不过其实 AI 应该并没有学会必胜法，毕竟我们看看算法就能发现它其实就是把每一步的结果存到字典里了，这叫什么？这叫背公式。</p><p>但是我转念一想，如果换我来，在不知道必胜法的情况下，我自己玩一千把，可能也不一定找到必胜法，只能有一种冥冥之中的感觉。</p><p>这种感觉是什么呢，也许也是记忆，也许是隐隐感受到了数学公式在里面。</p><p>但是就算我能发现必胜法是计算异或值（尼姆和），这也是基于我以前学过数学学过计算机，但是这对于空白一张的 AI 是完全不可能的事情。</p><p>除非我提供给它的状态不用 {1, 3, 5, 7} 这样的方式表示，而是直接给出尼姆和，或者给出每个数字的二进制表示，这样也许它才能学到其中的奥秘。</p><h2 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h2><p>OK，那假设 AI 已经理解问题了，我们该如何泛化问题呢？</p><p>就比如说我现在给 AI 多加一排，变成 {1, 3, 5, 7, 9}，由于有些状态就没在字典里出现过，AI 该怎么选择呢？</p><p>我试着写了一下，给大家看看。</p><ol><li>首先找一下这个状态是不是已知的，是的话就不用猜了。</li><li>找不到的话就看看这个未知状态离哪个状态最近，这里的话距离是用异或算的，基本也是变相告诉 AI，尼姆和很重要。</li><li>最后查找离的最近的状态的最好决策，然后让 AI 做出可以和这个最好决策达到相同状态的决策。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict_action</span>(<span class="params">self, state</span>):</span><br><span class="line">    min_distance = <span class="built_in">int</span>(math.<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">32</span>))</span><br><span class="line">    nearest_state = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> state_known, action <span class="keyword">in</span> self.q.keys():</span><br><span class="line">        <span class="keyword">if</span> state_known == state:</span><br><span class="line">            <span class="keyword">return</span> self.choose_action(state, epsilon=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xor_state = state[<span class="number">0</span>] ^ state[<span class="number">1</span>] ^ state[<span class="number">2</span>] ^ state[<span class="number">3</span>] ^ state[<span class="number">4</span>]</span><br><span class="line">            xor_state_known = state_known[<span class="number">0</span>] ^ state_known[<span class="number">1</span>] ^ state_known[<span class="number">2</span>] ^ state_known[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">            distance = xor_state ^ xor_state_known</span><br><span class="line">            <span class="keyword">if</span> distance &lt; min_distance:</span><br><span class="line">                min_distance = distance</span><br><span class="line">                nearest_state = state_known</span><br><span class="line"></span><br><span class="line">    predict_action = self.choose_action(nearest_state, epsilon=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> action <span class="keyword">in</span> Nim.available_actions(state):</span><br><span class="line">        <span class="keyword">if</span> state[action[<span class="number">0</span>] - action[<span class="number">1</span>]] == state[predict_action[<span class="number">0</span>] - predict_action[<span class="number">1</span>]]:</span><br><span class="line">            <span class="keyword">return</span> action</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> predict_action</span><br></pre></td></tr></table></figure><p>给大家看看结果，我没有博弈完，但是我一看到 AI 从第四堆里拿，我就知道泛化成功了，至此 AI 将随意玩任意情况的尼姆游戏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Piles:</span><br><span class="line">Pile 0: 1</span><br><span class="line">Pile 1: 3</span><br><span class="line">Pile 2: 5</span><br><span class="line">Pile 3: 7</span><br><span class="line">Pile 4: 9</span><br><span class="line"></span><br><span class="line">Your Turn</span><br><span class="line">Choose Pile: 1  </span><br><span class="line">Choose Count: 2</span><br><span class="line"></span><br><span class="line">Piles:</span><br><span class="line">Pile 0: 1</span><br><span class="line">Pile 1: 1</span><br><span class="line">Pile 2: 5</span><br><span class="line">Pile 3: 7</span><br><span class="line">Pile 4: 9</span><br><span class="line"></span><br><span class="line">AI&#x27;s Turn</span><br><span class="line">AI chose to take 3 from pile 4.</span><br><span class="line"></span><br><span class="line">Piles:</span><br><span class="line">Pile 0: 1</span><br><span class="line">Pile 1: 1</span><br><span class="line">Pile 2: 5</span><br><span class="line">Pile 3: 7</span><br><span class="line">Pile 4: 6</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这其实也是我第一次尝试实现强化学习，感觉确实挺好玩的，下一篇可能会让 AI 玩真正的狼人杀了。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Xavier初始化</title>
      <link href="/2025/02/25/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B905/"/>
      <url>/2025/02/25/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B905/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Xavier 初始化是一种比较常用的初始化方法，其核心思想是使得每一层的输出方差尽量相等，这样可以避免梯度消失和梯度爆炸，具体的公式如下。</p><p>$$<br>W \sim U(-\sqrt{\frac{6}{n_{in} + n_{out}}}, \sqrt{\frac{6}{n_{in} + n_{out}}})<br>$$</p><p>其中 $n_{in}$ 是输入神经元的个数，$n_{out}$ 是输出神经元的个数，$U(a, b)$ 是均匀分布。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>为什么要让每一层的输出方差尽量相等呢？</p><ol><li>避免梯度消失和梯度爆炸：如果各层输出的方差不一致，可能会导致梯度在传递过程中逐渐变小（梯度消失）或逐渐变大（梯度爆炸）。</li><li>保证信号的有效传播：如果各层输出方差不一致，可能会导致信号在某些层被放大或缩小，从而影响网络对特征的提取和学习能力。例如，当某一层的输出方差过大时，该层的输出值可能会超出激活函数的有效范围，使得激活函数饱和，从而丢失了部分信息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>交叉熵损失函数的前世今生</title>
      <link href="/2025/02/25/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B904/"/>
      <url>/2025/02/25/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B904/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>西瓜书基本都过了一遍，感觉怎么说呢，理论气息太重了，实战中的价值感觉不大，所以我又开了一本新书《动手学深度学习》，之后就是边看边把自己觉得重要和有所感悟的地方记录下来。</p><h1 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h1><p>先来看看交叉熵损失函数长啥样，</p><p>$$<br>H(y^{(i)}, \hat{y}^{(i)}) &#x3D; -\sum_{j} y_j^{(i)} \log \hat{y}_j^{(i)}<br>$$</p><p>其中 $p(x)$ 是真实分布，$q(x)$ 是预测分布，$j$ 是标签类别的索引。</p><p>不知道大家看到这个会不会觉得很熟悉，反正我第一时间就想到了信息熵。</p><h1 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h1><p>同样的我们也来看看信息熵长啥样。</p><p>$$<br>H(p) &#x3D; -\sum_{x} p(x) \log p(x)<br>$$</p><p>其中 $p(x)$ 是概率分布。</p><p>是不是几乎一摸一样，所以交叉熵损失函数的本质就是在求预测分布所包含的信息量。</p><p>那为什么要最小化交叉熵损失函数，也就是最小化信息量呢？</p><p>因为信息量越小，意味着信息越<strong>纯净</strong>，大家可以画一下上面的函数图，会发现当且仅当 $y^{(i)} &#x3D; \hat{y}^{(i)}$ 时，交叉熵损失函数取最小值，也就是说预测分布和真实分布完全一致时，信息量最小。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>交叉熵损失函数的主要应用场景是<strong>分类问题</strong>，因为分类问题的输出是一个概率分布，也只有概率分布才会包含所谓的信息。</p><h2 id="单标签分类"><a href="#单标签分类" class="headerlink" title="单标签分类"></a>单标签分类</h2><p>来考虑一下单标签分类问题，换言之每个样本只有一个标签，也就是说在真实分布中只有一个 $y_j^{(i)} &#x3D; 1$，其他都是0，所以我们可以将交叉熵损失函数简化为。</p><p>$$<br>H(y^{(i)}, \hat{y}^{(i)}) &#x3D; -\log \hat{y}_j^{(i)}<br>$$</p><p>其中 $j$ 是真实标签的索引。</p><h2 id="多标签分类"><a href="#多标签分类" class="headerlink" title="多标签分类"></a>多标签分类</h2><p>这就是要求多个标签的联合信息熵了。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Knowledge篇（四），让AI玩狼人杀</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A006/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A006/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>终于，我们来玩狼人杀了，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h1><p>规则的话，因为人越多越复杂，所以我这边就只弄了一个丐版的，五个人：三村民，一狼人，一预言，先给大家看一眼初始化游戏的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">ROLES = [<span class="string">&#x27;citizen&#x27;</span>, <span class="string">&#x27;werewolf&#x27;</span>, <span class="string">&#x27;prophet&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        number = <span class="number">5</span></span><br><span class="line">        roles = &#123;<span class="string">&#x27;citizen&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;werewolf&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;prophet&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">        players_name = [<span class="string">&#x27;player&#x27;</span> + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(number)]</span><br><span class="line">        <span class="comment"># self.symboles = [Symbol(player_name + &#x27; is &#x27; + role) for player_name in players_name for role in ROLES]</span></span><br><span class="line">        knowledge_base = And(</span><br><span class="line">            Or(Symbol(<span class="string">&#x27;player0 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player0 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player0 is prophet&#x27;</span>)),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player0 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player0 is werewolf&#x27;</span>))),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player0 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player0 is prophet&#x27;</span>))),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player0 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player0 is prophet&#x27;</span>))),</span><br><span class="line"></span><br><span class="line">            Or(Symbol(<span class="string">&#x27;player1 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player1 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player1 is prophet&#x27;</span>)),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player1 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player1 is werewolf&#x27;</span>))),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player1 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player1 is prophet&#x27;</span>))),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player1 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player1 is prophet&#x27;</span>))),</span><br><span class="line"></span><br><span class="line">            Or(Symbol(<span class="string">&#x27;player2 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player2 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player2 is prophet&#x27;</span>)),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player2 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player2 is werewolf&#x27;</span>))),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player2 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player2 is prophet&#x27;</span>))),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player2 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player2 is prophet&#x27;</span>))),</span><br><span class="line"></span><br><span class="line">            Or(Symbol(<span class="string">&#x27;player3 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player3 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player3 is prophet&#x27;</span>)),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player3 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player3 is werewolf&#x27;</span>))),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player3 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player3 is prophet&#x27;</span>))),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player3 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player3 is prophet&#x27;</span>))),</span><br><span class="line"></span><br><span class="line">            Or(Symbol(<span class="string">&#x27;player4 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player4 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player4 is prophet&#x27;</span>)),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player4 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player4 is werewolf&#x27;</span>))),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player4 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player4 is prophet&#x27;</span>))),</span><br><span class="line">            Not(And(Symbol(<span class="string">&#x27;player4 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player4 is prophet&#x27;</span>))),</span><br><span class="line"></span><br><span class="line">            Or(Symbol(<span class="string">&#x27;player0 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player1 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player2 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player3 is citizen&#x27;</span>), Symbol(<span class="string">&#x27;player4 is citizen&#x27;</span>)),</span><br><span class="line">            Or(Symbol(<span class="string">&#x27;player0 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player1 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player2 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player3 is werewolf&#x27;</span>), Symbol(<span class="string">&#x27;player4 is werewolf&#x27;</span>)),</span><br><span class="line">            Or(Symbol(<span class="string">&#x27;player0 is prophet&#x27;</span>), Symbol(<span class="string">&#x27;player1 is prophet&#x27;</span>), Symbol(<span class="string">&#x27;player2 is prophet&#x27;</span>), Symbol(<span class="string">&#x27;player3 is prophet&#x27;</span>), Symbol(<span class="string">&#x27;player4 is prophet&#x27;</span>)),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># random roles</span></span><br><span class="line">        self.players = []</span><br><span class="line">        <span class="keyword">for</span> player_name <span class="keyword">in</span> players_name:</span><br><span class="line">            role = random.choice(ROLES)</span><br><span class="line">            roles[role] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> roles[role] == <span class="number">0</span>:</span><br><span class="line">                ROLES.remove(role)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> role == <span class="string">&#x27;citizen&#x27;</span>:</span><br><span class="line">                player = Citizen(player_name, role)</span><br><span class="line">            <span class="keyword">elif</span> role == <span class="string">&#x27;werewolf&#x27;</span>:</span><br><span class="line">                player = Werewolf(player_name, role)</span><br><span class="line">            <span class="keyword">elif</span> role == <span class="string">&#x27;prophet&#x27;</span>:</span><br><span class="line">                player = Prophet(player_name, role)</span><br><span class="line"></span><br><span class="line">            player.add_knowledge(knowledge_base, <span class="literal">None</span>, <span class="literal">True</span>)</span><br><span class="line">            self.players.append(player)</span><br></pre></td></tr></table></figure><p>其中，knowledge_base 是每个人都有的基础知识，相信大家看过上一篇之后，一定懂为什么 knowledge_base 长这样。</p><p>然后是游戏流程，天黑 -&gt; 狼人刀人 -&gt; 预言查人 -&gt; 各自发言 -&gt; 各自投票 -&gt; 下一天，代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">    day = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        day += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Day&#x27;</span>, day)</span><br><span class="line"></span><br><span class="line">        dead = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> self.players:</span><br><span class="line">            <span class="keyword">if</span> player.get_role() == <span class="string">&#x27;werewolf&#x27;</span>:</span><br><span class="line">                dead = player.kill(self.players)</span><br><span class="line">        <span class="built_in">print</span>(dead.get_name() + <span class="string">&#x27; is dead&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.players) == <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Werewolf win&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        symbol = Symbol(dead.get_name() + <span class="string">&#x27; is &#x27;</span> + dead.get_role())</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> self.players:</span><br><span class="line">            player.add_knowledge(symbol, <span class="literal">None</span>, <span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(symbol)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        prophet = <span class="literal">None</span></span><br><span class="line">        checked = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> self.players:</span><br><span class="line">            player.say(self.players.index(player))</span><br><span class="line">            <span class="keyword">if</span> player.get_role() == <span class="string">&#x27;prophet&#x27;</span>:</span><br><span class="line">                prophet = player</span><br><span class="line">                checked = player.check(self.players)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        symbol1 = Symbol(prophet.get_name() + <span class="string">&#x27; is &#x27;</span> + prophet.get_role())</span><br><span class="line">        symbol2 = Symbol(checked.get_name() + <span class="string">&#x27; is &#x27;</span> + checked.get_role())</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> self.players:</span><br><span class="line">            player.add_knowledge(symbol1, <span class="literal">None</span>, <span class="literal">True</span>)</span><br><span class="line">            player.add_knowledge(symbol2, <span class="literal">None</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        votes = []</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> self.players:</span><br><span class="line">            votes.append(player.vote(self.players))</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        target = <span class="built_in">max</span>(<span class="built_in">set</span>(votes), key = votes.count)</span><br><span class="line">        self.players.remove(target)</span><br><span class="line">        <span class="built_in">print</span>(target.get_name() + <span class="string">&#x27; is voted&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target.get_role() == <span class="string">&#x27;werewolf&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Citizen win&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="角色实现"><a href="#角色实现" class="headerlink" title="角色实现"></a>角色实现</h1><p>主要给大家讲一下基类 Player 吧，剩下的大家可以自行实现，代码如下，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, role</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.role = role</span><br><span class="line"></span><br><span class="line">        self.knowledge = And(</span><br><span class="line">            Symbol(self.name + <span class="string">&#x27; is &#x27;</span> + self.role),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_role</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.role</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_knowledge</span>(<span class="params">self, symbol1, symbol2, sure</span>):</span><br><span class="line">        <span class="keyword">if</span> sure:</span><br><span class="line">            self.knowledge = And(self.knowledge, symbol1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> symbol2:</span><br><span class="line">            self.knowledge = And(self.knowledge, Implication(symbol1, symbol2))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_knowledge</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.knowledge</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_probabilities</span>(<span class="params">self, players, target</span>):</span><br><span class="line">        probabilities = []</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">            symbol = Symbol(player.get_name() + <span class="string">&#x27; is &#x27;</span> + target)</span><br><span class="line">            model_check(self.knowledge, symbol)</span><br><span class="line">            probabilities.append((player, symbol.true / (symbol.true + symbol.false)))</span><br><span class="line"></span><br><span class="line">        logger.info(self.knowledge)</span><br><span class="line">        logger.info(probabilities)</span><br><span class="line"></span><br><span class="line">        probabilities.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> (probabilities[<span class="number">0</span>], probabilities[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>其中最重要的就是这个 get_probabilities 了，它主要是根据当前玩家所有的 knowledge，通过 model_check 来判断其余每个玩家为 target 的概率，然后返回概率最低的和最高的两个。</p><p>如果你还不了解 model_check，可以先阅读<a href="../AI%E5%AD%A6%E4%B9%A003">这一篇</a>。</p><p>那基于这个函数我们就能让好人去投票最像狼人的人，也能让预言家去查最像狼人的人，同时也可以让狼人去杀最像预言家的人。</p><h1 id="游戏结果"><a href="#游戏结果" class="headerlink" title="游戏结果"></a>游戏结果</h1><p>这里给大家随便看一局。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Day 1</span><br><span class="line">player2 is dead</span><br><span class="line">player2 is citizen</span><br><span class="line"></span><br><span class="line">player0 is prophet</span><br><span class="line">player0 checked player4 is citizen</span><br><span class="line">player1 is citizen(lying)</span><br><span class="line">player3 is citizen</span><br><span class="line">player4 is citizen</span><br><span class="line"></span><br><span class="line">player0 voted player1</span><br><span class="line">player1 voted player0</span><br><span class="line">player3 voted player1</span><br><span class="line">player4 voted player1</span><br><span class="line"></span><br><span class="line">player1 is voted</span><br><span class="line"></span><br><span class="line">Citizen win</span><br></pre></td></tr></table></figure><p>可以看到这里是狼人（player1）第一晚杀了 player2，是个村民。</p><p>然后各自发言，预言家（player0）给 player4 发了个金水。</p><p>最后大家各自投票，将 player1 投出，因为 player1 是狼人，所以游戏结束，好人获胜。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>如果大家实现完会发现，AI 很呆板，举个例子，我们甚至无法让预言家自由选择何时自曝身份，何时再苟一轮，而这在实际游玩中很重要。</p><p>但是大家一定要知道，实现不了不是说 AI 的能力有限，而是我们的能力有限，我们没法给他穷尽这个决策树，我们最多能做到的就是给他一个概率，比如50%去自曝身份，50%去再苟一轮。</p><p>而如果想让 AI 更进一步，我们就得进入深度学习的世界（这会放在以后再讲），只有深度学习，才能让 AI 自己通过不断的训练，理解这些变量之间的复杂关系，从而找到最优解。</p><h2 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h2><p>最后的话还有我自己的一个困惑，再第一轮中，明明大家对除了被发金水以外的两个人没有任何信息，但却会给他们不同的狼人概率，<strong>按理说第一天这两个应该都是0%！！！</strong>，应该是弃票的。</p><p>下面这六条，第一条是狼人眼中每个人是预言家的概率，第二条是预言家眼中每个人是狼人的概率，第三四六条是每个好人投票时每个人是狼人的概率，第五条是狼人的就不用看了，按理说这里面五条所有的概率都应该是0！！！但是实际结果却不是，这让我感觉非常的困惑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">INFO:__main__:[(&lt;__main__.Prophet object at 0x1035b9f70&gt;, 0.0), (&lt;__main__.Werewolf object at 0x1035bb160&gt;, 0.0), (&lt;__main__.Citizen object at 0x1035bb2e0&gt;, 0.95), (&lt;__main__.Citizen object at 0x1035bb460&gt;, 0.0), (&lt;__main__.Citizen object at 0x1035bb5e0&gt;, 0.0)]</span><br><span class="line"></span><br><span class="line">INFO:__main__:[(&lt;__main__.Prophet object at 0x1035b9f70&gt;, 0.0), (&lt;__main__.Werewolf object at 0x1035bb160&gt;, 0.75), (&lt;__main__.Citizen object at 0x1035bb460&gt;, 0.5), (&lt;__main__.Citizen object at 0x1035bb5e0&gt;, 0.9)]</span><br><span class="line"></span><br><span class="line">INFO:__main__:[(&lt;__main__.Prophet object at 0x1035b9f70&gt;, 0.0), (&lt;__main__.Werewolf object at 0x1035bb160&gt;, 0.75), (&lt;__main__.Citizen object at 0x1035bb460&gt;, 0.5), (&lt;__main__.Citizen object at 0x1035bb5e0&gt;, 0.0)]</span><br><span class="line"></span><br><span class="line">INFO:__main__:[(&lt;__main__.Prophet object at 0x1035b9f70&gt;, 1.0), (&lt;__main__.Werewolf object at 0x1035bb160&gt;, 0.0), (&lt;__main__.Citizen object at 0x1035bb460&gt;, 0.0), (&lt;__main__.Citizen object at 0x1035bb5e0&gt;, 0.0)]</span><br><span class="line"></span><br><span class="line">INFO:__main__:[(&lt;__main__.Prophet object at 0x1035b9f70&gt;, 0.0), (&lt;__main__.Werewolf object at 0x1035bb160&gt;, 1.0), (&lt;__main__.Citizen object at 0x1035bb460&gt;, 0.0), (&lt;__main__.Citizen object at 0x1035bb5e0&gt;, 0.0)]</span><br><span class="line"></span><br><span class="line">INFO:__main__:[(&lt;__main__.Prophet object at 0x1035b9f70&gt;, 0.0), (&lt;__main__.Werewolf object at 0x1035bb160&gt;, 0.75), (&lt;__main__.Citizen object at 0x1035bb460&gt;, 0.5), (&lt;__main__.Citizen object at 0x1035bb5e0&gt;, 0.0)]</span><br></pre></td></tr></table></figure><p>里面最大的可能是 KB 不完整，也有可能在所有的可能情况下，排除了某些情况后算出来的概率就是这样，不知道有没有概率好的能解释解释。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Knowledge篇（三），让AI玩真假游戏</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A005/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A005/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>哎，狼人杀的逻辑好难实现，这毕竟不是大模型，给几个目标让他们自己练就可以，首先得我自己搞懂狼人杀的发言逻辑，所以今天还是先从比较简单的真假游戏开始，相信看完这篇，你也会和我一样眼前一亮，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h1><p>同样的简单讲一下规则，这游戏我第一次接触是小学学奥数的时候。</p><p>简单来说，就是会有几个人，他们要么是骑士要么是恶魔，骑士只能说真话，而恶魔可以是假话也可以是真话，我们需要从他们说的话来判断他们的身份。</p><p>所以我们首先创建所有会用到的 Symbol。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AKnight = Symbol(<span class="string">&quot;A is a Knight&quot;</span>)</span><br><span class="line">AKnave = Symbol(<span class="string">&quot;A is a Knave&quot;</span>)</span><br><span class="line"></span><br><span class="line">BKnight = Symbol(<span class="string">&quot;B is a Knight&quot;</span>)</span><br><span class="line">BKnave = Symbol(<span class="string">&quot;B is a Knave&quot;</span>)</span><br><span class="line"></span><br><span class="line">CKnight = Symbol(<span class="string">&quot;C is a Knight&quot;</span>)</span><br><span class="line">CKnave = Symbol(<span class="string">&quot;C is a Knave&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="游戏逻辑"><a href="#游戏逻辑" class="headerlink" title="游戏逻辑"></a>游戏逻辑</h1><p>OK，这一块的话就是重中之重了，来举个简单的例子先，考虑下面这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设只有一个 A。</span><br><span class="line">A 说：“我即是骑士又是恶魔。”</span><br></pre></td></tr></table></figure><p>大家可以先想一下这个问题的 KB 应该怎么表示再往下看。</p><p>答案一共是四句，首先要说明 A 只能是骑士或者恶魔，然后再用推理来表示 A 说的话，如果 A 是骑士，那么他说的话就为真，反之则不一定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">knowledge0 = And(</span><br><span class="line">    Or(AKnight, AKnave), <span class="comment"># A is a knight or A is a knave</span></span><br><span class="line">    Not(And(AKnight, AKnave)), <span class="comment"># A is not a knight and a knave</span></span><br><span class="line"></span><br><span class="line">    Implication(AKnight, And(AKnight, AKnave)), <span class="comment"># If A is a knight, then A is a knight and a knave</span></span><br><span class="line">    Implication(AKnave, Not(And(AKnight, AKnave))) <span class="comment"># If A is a knave, then A is not a knight and a knave</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同样的，接下来还有三个问题，大家可以尝试自行解决，然后再看看我的代码 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Puzzle 1</span></span><br><span class="line"><span class="comment"># A says &quot;We are both knaves.&quot;</span></span><br><span class="line"><span class="comment"># B says nothing.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Puzzle 2</span></span><br><span class="line"><span class="comment"># A says &quot;We are the same kind.&quot;</span></span><br><span class="line"><span class="comment"># B says &quot;We are of different kinds.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Puzzle 3</span></span><br><span class="line"><span class="comment"># A says either &quot;I am a knight.&quot; or &quot;I am a knave.&quot;, but you don&#x27;t know which.</span></span><br><span class="line"><span class="comment"># B says &quot;A said &#x27;I am a knave&#x27;.&quot;</span></span><br><span class="line"><span class="comment"># B says &quot;C is a knave.&quot;</span></span><br><span class="line"><span class="comment"># C says &quot;A is a knight.&quot;</span></span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>哈哈哈，今天文章好像有点水，但是今天是除夕，应该大家也不介意。</p><p>不过这个游戏要实现还是挺耗脑子的，因为你需要仔细思考如何原封不动的转述给 AI，比如那个例子，你可能一看到就知道 A 是恶魔，但是你不能直接给 KB 里面放一个 A 是恶魔，你必须得用那些连接符和 Symbols 来解释，还是挺痛苦的。</p><p>不过大家现在看完应该也发现了，狼人杀的发言跟这个就是异曲同工，所以明天一定给大家端出来。</p><p>最后给大家讲一段挺有意思的代码，就是下面这个判断每个人的角色。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> puzzle, knowledge <span class="keyword">in</span> puzzles:</span><br><span class="line">    <span class="built_in">print</span>(puzzle)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(knowledge.conjuncts) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;    Not yet implemented.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols:</span><br><span class="line">            <span class="keyword">if</span> model_check(knowledge, symbol):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;    <span class="subst">&#123;symbol&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这代码妙就妙在，通过 model_check 只打印了 symbol 为真的情况，这样就不需要二次修改输出了，直接就能出现这样的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Puzzle 1</span><br><span class="line">    A is a Knave</span><br><span class="line">    B is a Knight</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Knowledge篇（二），让AI玩扫雷</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A004/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A004/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原本是要让 AI 来玩狼人杀的，后来感觉思路不是很清晰，所以干脆今天就先做个单人游戏——扫雷，先给大家看一下成果，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/12.jpg"></p><h1 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h1><p>这里先给不了解游戏规则的人介绍一下游戏，扫雷中的每个数字代表的是，以此数字为中心的九宫格内有几颗地雷，如下图就表示 A～H 这八个格子里有一颗雷。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/13.png"></p><h1 id="扫雷逻辑"><a href="#扫雷逻辑" class="headerlink" title="扫雷逻辑"></a>扫雷逻辑</h1><p>OK，那知道了游戏规则后，我们怎么来表示这个 Knowledge Base 呢？当然你可以像昨天说的那样用以下的式子来表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Or(A, B, C, D, E, F, G, H)</span><br></pre></td></tr></table></figure><p>但是，别忘了，上面的式子只能表达有至少一颗雷，但是没有表达出最多也只有一颗雷，具体还需要下面这一堆才行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Or(</span><br><span class="line">And(A, Not(B), Not(C), Not(D), Not(E), Not(F), Not(G), Not(H)),     </span><br><span class="line">And(Not(A), B, Not(C), Not(D), Not(E), Not(F), Not(G), Not(H)),     </span><br><span class="line">And(Not(A), Not(B), C, Not(D), Not(E), Not(F), Not(G), Not(H)),     </span><br><span class="line">And(Not(A), Not(B), Not(C), D, Not(E), Not(F), Not(G), Not(H)),     </span><br><span class="line">And(Not(A), Not(B), Not(C), Not(D), E, Not(F), Not(G), Not(H)),     </span><br><span class="line">And(Not(A), Not(B), Not(C), Not(D), Not(E), F, Not(G), Not(H)),     </span><br><span class="line">And(Not(A), Not(B), Not(C), Not(D), Not(E), Not(F), G, Not(H)),     </span><br><span class="line">And(Not(A), Not(B), Not(C), Not(D), Not(E), Not(F), Not(G), H),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>光是一个 1 就这么复杂，那怎么行，所以我们得想一个新的表达方式。</p><h1 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h1><p>思考一下，扫雷其实说白了就三种操作。</p><ol><li>如果数字正好等于未翻格子的数量，则代表那些全是雷。</li><li>如果数字为0，则代表周围没有雷。</li><li>切割子集。</li></ol><p>第一条和第二条都很好理解，想象一下中间数字是8和0的情况就行了。</p><p>至于第三条，我们可以通过经典的12排雷给大家解释。</p><p>如下图，通过上面的1我们可以知道，ABC 中一定有一雷，又通过下面的2我们知道 ABCDE 中一定有两颗雷，所以我们可以得出 DE 中一定有一颗雷，这就是切割子集。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/14.png"></p><p>OK，那我们该用什么样的数据结构来表示呢？</p><p>相信聪明的朋友已经发现了，我在上面一直在说几何集合，没错，我们可以用集合来表示，具体表示形式如下。</p><p>在上面的例子中，我们可以说 {A, B, C} &#x3D; 1，{A, B, C, D, E} &#x3D; 2，然后得出 {D, E} &#x3D; 1，也就是说我们有如下公式。</p><p>set1 &#x3D; number1，set2 &#x3D; number2，set2-set1 &#x3D; number2-number1。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><p>运行代码就给大家稍微带一下。</p><p>一块的话是画图的代码，每帧更新，没什么好说的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Draw board</span></span><br><span class="line">    cells = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(HEIGHT):</span><br><span class="line">        row = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(WIDTH):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Draw rectangle for cell</span></span><br><span class="line">            rect = pygame.Rect(</span><br><span class="line">                board_origin[<span class="number">0</span>] + j * cell_size,</span><br><span class="line">                board_origin[<span class="number">1</span>] + i * cell_size,</span><br><span class="line">                cell_size, cell_size</span><br><span class="line">            )</span><br><span class="line">            pygame.draw.rect(screen, GRAY, rect)</span><br><span class="line">            pygame.draw.rect(screen, WHITE, rect, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Add a mine, flag, or number if needed</span></span><br><span class="line">            <span class="keyword">if</span> game.is_mine((i, j)) <span class="keyword">and</span> lost:</span><br><span class="line">                screen.blit(mine, rect)</span><br><span class="line">            <span class="keyword">elif</span> (i, j) <span class="keyword">in</span> flags:</span><br><span class="line">                screen.blit(flag, rect)</span><br><span class="line">            <span class="keyword">elif</span> (i, j) <span class="keyword">in</span> revealed:</span><br><span class="line">                neighbors = smallFont.render(</span><br><span class="line">                    <span class="built_in">str</span>(game.nearby_mines((i, j))),</span><br><span class="line">                    <span class="literal">True</span>, BLACK</span><br><span class="line">                )</span><br><span class="line">                neighborsTextRect = neighbors.get_rect()</span><br><span class="line">                neighborsTextRect.center = rect.center</span><br><span class="line">                screen.blit(neighbors, neighborsTextRect)</span><br><span class="line"></span><br><span class="line">            row.append(rect)</span><br><span class="line">        cells.append(row)</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>还有一块的话是 AI 的扫雷步骤，可以看到是先查找有没有安全的格子，没有的话就随机选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> left == <span class="number">1</span>:</span><br><span class="line">    mouse = pygame.mouse.get_pos()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If AI button clicked, make an AI move</span></span><br><span class="line">    <span class="keyword">if</span> aiButton.collidepoint(mouse) <span class="keyword">and</span> <span class="keyword">not</span> lost:</span><br><span class="line">        move = ai.make_safe_move()</span><br><span class="line">        <span class="keyword">if</span> move <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            move = ai.make_random_move()</span><br><span class="line">            <span class="keyword">if</span> move <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                flags = ai.mines.copy()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;No moves left to make.&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;No known safe moves, AI making random move.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;AI making safe move.&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># use flags to mark mines</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(HEIGHT):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(WIDTH):</span><br><span class="line">                <span class="keyword">if</span> (i, j) <span class="keyword">in</span> ai.mines:</span><br><span class="line">                    flags.add((i, j))</span><br></pre></td></tr></table></figure><h2 id="逻辑代码"><a href="#逻辑代码" class="headerlink" title="逻辑代码"></a>逻辑代码</h2><p>OK，接下来看看大头逻辑代码。</p><p>首先是棋盘类，主要的话就是要判断格子上是不是雷已经它周围雷的数量，也就是要显示的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Minesweeper</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Minesweeper game representation</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, height=<span class="number">8</span>, width=<span class="number">8</span>, mines=<span class="number">8</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set initial width, height, and number of mines</span></span><br><span class="line">        self.height = height</span><br><span class="line">        self.width = width</span><br><span class="line">        self.mines = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initialize an empty field with no mines</span></span><br><span class="line">        self.board = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.height):</span><br><span class="line">            row = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.width):</span><br><span class="line">                row.append(<span class="literal">False</span>)</span><br><span class="line">            self.board.append(row)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add mines randomly</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.mines) != mines:</span><br><span class="line">            i = random.randrange(height)</span><br><span class="line">            j = random.randrange(width)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.board[i][j]:</span><br><span class="line">                self.mines.add((i, j))</span><br><span class="line">                self.board[i][j] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># At first, player has found no mines</span></span><br><span class="line">        self.mines_found = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_mine</span>(<span class="params">self, cell</span>):</span><br><span class="line">        i, j = cell</span><br><span class="line">        <span class="keyword">return</span> self.board[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nearby_mines</span>(<span class="params">self, cell</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns the number of mines that are</span></span><br><span class="line"><span class="string">        within one row and column of a given cell,</span></span><br><span class="line"><span class="string">        not including the cell itself.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Keep count of nearby mines</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Loop over all cells within one row and column</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cell[<span class="number">0</span>] - <span class="number">1</span>, cell[<span class="number">0</span>] + <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cell[<span class="number">1</span>] - <span class="number">1</span>, cell[<span class="number">1</span>] + <span class="number">2</span>):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Ignore the cell itself</span></span><br><span class="line">                <span class="keyword">if</span> (i, j) == cell:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Update count if cell in bounds and is mine</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; self.height <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; self.width:</span><br><span class="line">                    <span class="keyword">if</span> self.board[i][j]:</span><br><span class="line">                        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">won</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Checks if all mines have been flagged.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.mines_found == self.mines</span><br></pre></td></tr></table></figure><p>而 Sentence 类的话其实就是对应了一个集合，所以它需要实现知识表示里的前两种操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Logical statement about a Minesweeper game</span></span><br><span class="line"><span class="string">    A sentence consists of a set of board cells,</span></span><br><span class="line"><span class="string">    and a count of the number of those cells which are mines.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">known_mines</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns the set of all cells in self.cells known to be mines.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.cells) == self.count:</span><br><span class="line">            <span class="keyword">return</span> self.cells</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">known_safes</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns the set of all cells in self.cells known to be safe.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.cells</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mark_mine</span>(<span class="params">self, cell</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Updates internal knowledge representation given the fact that</span></span><br><span class="line"><span class="string">        a cell is known to be a mine.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> cell <span class="keyword">in</span> self.cells:</span><br><span class="line">            self.cells.remove(cell)</span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mark_safe</span>(<span class="params">self, cell</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Updates internal knowledge representation given the fact that</span></span><br><span class="line"><span class="string">        a cell is known to be safe.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> cell <span class="keyword">in</span> self.cells:</span><br><span class="line">            self.cells.remove(cell)</span><br></pre></td></tr></table></figure><p>最后就是我们的 AI Agent 了，主要就是去记录一些安全格和雷格的信息，从而进行安全的移动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinesweeperAI</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Minesweeper game player</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, height=<span class="number">8</span>, width=<span class="number">8</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set initial height and width</span></span><br><span class="line">        self.height = height</span><br><span class="line">        self.width = width</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Keep track of which cells have been clicked on</span></span><br><span class="line">        self.moves_made = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Keep track of cells known to be safe or mines</span></span><br><span class="line">        self.mines = <span class="built_in">set</span>()</span><br><span class="line">        self.safes = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># List of sentences about the game known to be true</span></span><br><span class="line">        self.knowledge = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mark_mine</span>(<span class="params">self, cell</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Marks a cell as a mine, and updates all knowledge</span></span><br><span class="line"><span class="string">        to mark that cell as a mine as well.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.mines.add(cell)</span><br><span class="line">        <span class="keyword">for</span> sentence <span class="keyword">in</span> self.knowledge:</span><br><span class="line">            sentence.mark_mine(cell)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mark_safe</span>(<span class="params">self, cell</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Marks a cell as safe, and updates all knowledge</span></span><br><span class="line"><span class="string">        to mark that cell as safe as well.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.safes.add(cell)</span><br><span class="line">        <span class="keyword">for</span> sentence <span class="keyword">in</span> self.knowledge:</span><br><span class="line">            sentence.mark_safe(cell)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_safe_move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns a safe cell to choose on the Minesweeper board.</span></span><br><span class="line"><span class="string">        The move must be known to be safe, and not already a move</span></span><br><span class="line"><span class="string">        that has been made.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This function may use the knowledge in self.mines, self.safes</span></span><br><span class="line"><span class="string">        and self.moves_made, but should not modify any of those values.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> safe_cell <span class="keyword">in</span> self.safes:</span><br><span class="line">            <span class="keyword">if</span> safe_cell <span class="keyword">not</span> <span class="keyword">in</span> self.moves_made:</span><br><span class="line">                <span class="keyword">return</span> safe_cell</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_random_move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns a move to make on the Minesweeper board.</span></span><br><span class="line"><span class="string">        Should choose randomly among cells that:</span></span><br><span class="line"><span class="string">            1) have not already been chosen, and</span></span><br><span class="line"><span class="string">            2) are not known to be mines</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        possible_moves = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.height):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.width):</span><br><span class="line">                <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> self.moves_made <span class="keyword">and</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> self.mines:</span><br><span class="line">                    possible_moves.add((i, j))</span><br><span class="line">        <span class="keyword">if</span> possible_moves:</span><br><span class="line">            <span class="keyword">return</span> random.choice(<span class="built_in">list</span>(possible_moves))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>而其中负责增加新信息的主要这个 <strong>add_knowledge(self, cell, count)</strong> 函数，这里的 cell 就是当前新格子周围的未翻开格子了，count 就是周围雷的数量，那这个函数具体干了哪些事呢？</p><ol><li>记录并标记当前格子未安全。</li><li>添加新信息，也就是 cell &#x3D; count，同时根据已知的安全格缩小 cell。</li><li>根据新的安全格，更新 KB。</li><li>通过新集合，划分子集。</li><li>再次更新 KB。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_knowledge</span>(<span class="params">self, cell, count</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">     Called when the Minesweeper board tells us, for a given</span></span><br><span class="line"><span class="string">     safe cell, how many neighboring cells have mines in them.</span></span><br><span class="line"><span class="string">     &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     self.moves_made.add(cell)</span><br><span class="line">     self.mark_safe(cell)</span><br><span class="line"></span><br><span class="line">     <span class="comment"># Add new sentence to knowledge base</span></span><br><span class="line">     new_sentence_cells = <span class="built_in">set</span>()</span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cell[<span class="number">0</span>] - <span class="number">1</span>, cell[<span class="number">0</span>] + <span class="number">2</span>):</span><br><span class="line">         <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cell[<span class="number">1</span>] - <span class="number">1</span>, cell[<span class="number">1</span>] + <span class="number">2</span>):</span><br><span class="line">             <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; self.height <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; self.width:</span><br><span class="line">                 <span class="keyword">if</span> (i, j) <span class="keyword">in</span> self.mines:</span><br><span class="line">                     count -= <span class="number">1</span></span><br><span class="line">                 <span class="keyword">elif</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> self.safes:</span><br><span class="line">                     new_sentence_cells.add((i, j))</span><br><span class="line">     new_sentence = Sentence(new_sentence_cells, count)</span><br><span class="line">     self.knowledge.append(new_sentence)</span><br><span class="line"></span><br><span class="line">     <span class="comment"># Mark additional cells as safe or as mines</span></span><br><span class="line">     <span class="keyword">for</span> sentence <span class="keyword">in</span> self.knowledge:</span><br><span class="line">         <span class="keyword">for</span> safe_cell <span class="keyword">in</span> sentence.known_safes():</span><br><span class="line">             self.safes.add(safe_cell)</span><br><span class="line">         <span class="keyword">for</span> mine_cell <span class="keyword">in</span> sentence.known_mines():</span><br><span class="line">             self.mines.add(mine_cell)</span><br><span class="line"></span><br><span class="line">     <span class="comment"># Add new sentences to knowledge base</span></span><br><span class="line">     <span class="keyword">for</span> sentence1, sentence2 <span class="keyword">in</span> itertools.combinations(self.knowledge, <span class="number">2</span>):</span><br><span class="line">         <span class="keyword">if</span> sentence1.cells.issubset(sentence2.cells):</span><br><span class="line">             new_sentence = Sentence(sentence2.cells - sentence1.cells, sentence2.count - sentence1.count)</span><br><span class="line">         <span class="keyword">elif</span> sentence2.cells.issubset(sentence1.cells):</span><br><span class="line">             new_sentence = Sentence(sentence1.cells - sentence2.cells, sentence1.count - sentence2.count)</span><br><span class="line">         <span class="keyword">if</span> new_sentence <span class="keyword">not</span> <span class="keyword">in</span> self.knowledge:</span><br><span class="line">             self.knowledge.append(new_sentence)</span><br><span class="line"></span><br><span class="line">     <span class="comment"># Remove empty sentences</span></span><br><span class="line">     self.knowledge = [sentence <span class="keyword">for</span> sentence <span class="keyword">in</span> self.knowledge <span class="keyword">if</span> sentence.cells]</span><br><span class="line"></span><br><span class="line">     <span class="comment"># Mark additional cells as safe or as mines</span></span><br><span class="line">     <span class="keyword">for</span> sentence <span class="keyword">in</span> self.knowledge:</span><br><span class="line">         <span class="keyword">for</span> safe_cell <span class="keyword">in</span> sentence.known_safes():</span><br><span class="line">             self.safes.add(safe_cell)</span><br><span class="line">         <span class="keyword">for</span> mine_cell <span class="keyword">in</span> sentence.known_mines():</span><br><span class="line">             self.mines.add(mine_cell)</span><br><span class="line"></span><br><span class="line">     <span class="comment"># Mark safe cells and mines</span></span><br><span class="line">     <span class="keyword">for</span> safe_cell <span class="keyword">in</span> self.safes:</span><br><span class="line">         self.mark_safe(safe_cell)</span><br><span class="line">     <span class="keyword">for</span> mine_cell <span class="keyword">in</span> self.mines:</span><br><span class="line">         self.mark_mine(mine_cell)</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实读到这里大家应该发现了，这扫雷写起来也不难，难的是你有没有想到用这样的数据逻辑来解释他。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Knowledge篇（一），让AI具有逻辑</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A003/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A003/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>所谓的 Knowledge 就是指逻辑推理。</p><p>就像经典的苏格拉底三段论一样。</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>一个完整的可以分成什么呢？</p><h2 id="Proposition-Symbols"><a href="#Proposition-Symbols" class="headerlink" title="Proposition Symbols"></a>Proposition Symbols</h2><p>这里的 Symbols 是指一句完整的有主谓宾的句子。</p><p>看一下代码吧，这块感觉没什么好讲的，不懂再说吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">self, model</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">formula</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">symbols</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>()</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate</span>(<span class="params">cls, sentence</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(sentence, Sentence):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;must be a logical sentence&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parenthesize</span>(<span class="params">cls, s</span>):</span><br><span class="line">        p = re.<span class="built_in">compile</span>(<span class="string">r&quot;\s*([()])\s*&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> p.sub(<span class="string">r&quot; \1 &quot;</span>, s).strip()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Symbol</span>(<span class="title class_ inherited__">Sentence</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.true = <span class="number">0</span></span><br><span class="line">        self.false = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isinstance</span>(other, Symbol) <span class="keyword">and</span> self.name == other.name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((<span class="string">&quot;symbol&quot;</span>, self.name))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">self, model</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">bool</span>(model[self.name])</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;variable <span class="subst">&#123;self.name&#125;</span> not in model&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">formula</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">symbols</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;self.name&#125;</span><br></pre></td></tr></table></figure><h2 id="Logic-Connectives"><a href="#Logic-Connectives" class="headerlink" title="Logic Connectives"></a>Logic Connectives</h2><p>这也是逻辑推理的核心，基本的逻辑主要是以下五个。</p><ol><li>Not</li><li>And</li><li>Or</li><li>Implication</li><li>Biconditional</li></ol><p>需要注意的是，这不像大学里学的数字逻辑，没有异或也没有同或，取而代之的是 Implication（推导）和 Biconditional（充分必要条件）。</p><p>举个例子，如果今天下雨（P），我就不出门（Q），这样一句话就可以表示为 $P\rightarrow Q$，它的是非表如下。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/8.png"></p><p>可以看出，只有当条件为真，结果为否是，$P\rightarrow Q$ 才等于 false。</p><p>再来，如果且只有（if and only if）今天下雨（P），我才不出门（Q），这样一句话就可以表示为 $P\leftrightarrow Q$，它的是非表如下。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/9.png"></p><p>可以看出这就和上面的单向箭头有区别了。</p><p>给大家放了 Not 和 And 的实现代码，剩下三个就自己来实现吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Not</span>(<span class="title class_ inherited__">Sentence</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, operand</span>):</span><br><span class="line">        Sentence.validate(operand)</span><br><span class="line">        self.operand = operand</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isinstance</span>(other, Not) <span class="keyword">and</span> self.operand == other.operand</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((<span class="string">&quot;not&quot;</span>, <span class="built_in">hash</span>(self.operand)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;(not <span class="subst">&#123;self.operand&#125;</span>)&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">self, model</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.operand.evaluate(model)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">formula</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;¬&quot;</span> + Sentence.parenthesize(self.operand.formula())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">symbols</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.operand.symbols() </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">And</span>(<span class="title class_ inherited__">Sentence</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *conjuncts</span>):</span><br><span class="line">        <span class="keyword">for</span> conjunct <span class="keyword">in</span> conjuncts:</span><br><span class="line">            Sentence.validate(conjunct)</span><br><span class="line">        self.conjuncts = <span class="built_in">list</span>(conjuncts)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isinstance</span>(other, And) <span class="keyword">and</span> self.conjuncts == other.conjuncts</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((<span class="string">&quot;and&quot;</span>, <span class="built_in">tuple</span>(<span class="built_in">hash</span>(conjunct) <span class="keyword">for</span> conjunct <span class="keyword">in</span> self.conjuncts)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        conjunctions = <span class="string">&quot;, &quot;</span>.join(<span class="built_in">str</span>(conjunct) <span class="keyword">for</span> conjunct <span class="keyword">in</span> self.conjuncts)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;(and <span class="subst">&#123;conjunctions&#125;</span>)&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">self, model</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(conjunct.evaluate(model) <span class="keyword">for</span> conjunct <span class="keyword">in</span> self.conjuncts)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">formula</span>(<span class="params">self</span>):</span><br><span class="line">        conjunctions = <span class="string">&quot;(&quot;</span> + <span class="string">&quot; ∧ &quot;</span>.join(Sentence.parenthesize(conjunct.formula()) <span class="keyword">for</span> conjunct <span class="keyword">in</span> self.conjuncts) + <span class="string">&quot;)&quot;</span></span><br><span class="line">        <span class="keyword">return</span> Sentence.parenthesize(conjunctions)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">symbols</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>().union(*(conjunct.symbols() <span class="keyword">for</span> conjunct <span class="keyword">in</span> self.conjuncts))</span><br></pre></td></tr></table></figure><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>这里的 Model 不是模型，而是指一个存在所有 Symbols 的空间。可以理解为一个 Model 就是是非表里的一行，所有 Model 就构成了是非表。</p><h2 id="Knowledge-Base"><a href="#Knowledge-Base" class="headerlink" title="Knowledge Base"></a>Knowledge Base</h2><p>这个是所有已经条件的集合。</p><h2 id="Entailment"><a href="#Entailment" class="headerlink" title="Entailment"></a>Entailment</h2><p>可以理解为所有 Model 的共识，这也是需要 AI 来回答的问题。</p><p>也就是说当我给出所有的 Knowledge Base，$\alpha$ 这个 Symbol 所代表的事情是否一定为真。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/10.png"></p><h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><p>没什么好说的，就是上图的 $\alpha$，也就是要求证的事情。</p><h2 id="Model-Checking"><a href="#Model-Checking" class="headerlink" title="Model Checking"></a>Model Checking</h2><p>这就是来验证 Inference 对不对了，需要注意的是，只有当 KB 为 true 时，才需要检查 Inference 是不是 true。</p><p>考虑下图的 Entailment，只有绿色那一种情况下 KB 是真的，因此只看那一条，可以发现 R 是 true，所以可以完成这个推论。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/11.png"></p><p>看一下代码，可以发现是递归式的，<strong>即需要把所有 Symbol 都打上 true 或者 false，也就是创建一个完整的新 Model后</strong>，才能判断 Entailment。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">model_check</span>(<span class="params">knowledge, query</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_all</span>(<span class="params">knowledge, query, symbols, model</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> symbols:</span><br><span class="line">            <span class="keyword">if</span> knowledge.evaluate(model):</span><br><span class="line">                <span class="keyword">if</span> query.evaluate(model):</span><br><span class="line">                    query.true += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    query.false += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> query.evaluate(model)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        remaining = symbols.copy()</span><br><span class="line">        p = remaining.pop()</span><br><span class="line">        <span class="keyword">return</span> (check_all(knowledge, query, remaining, &#123;**model, **&#123;p: <span class="literal">True</span>&#125;&#125;) <span class="keyword">and</span></span><br><span class="line">                check_all(knowledge, query, remaining, &#123;**model, **&#123;p: <span class="literal">False</span>&#125;&#125;))</span><br><span class="line">    </span><br><span class="line">    symbols = knowledge.symbols().union(query.symbols())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> check_all(knowledge, query, symbols, model=&#123;&#125;)</span><br></pre></td></tr></table></figure><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>OK，来一个实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">rain = Symbol(<span class="string">&quot;rain&quot;</span>) <span class="comment"># It&#x27;s raining.</span></span><br><span class="line">hagrid = Symbol(<span class="string">&quot;hagrid&quot;</span>) <span class="comment"># Zong will visit Hagrid.</span></span><br><span class="line">dumbledore = Symbol(<span class="string">&quot;dumbledore&quot;</span>) <span class="comment"># Zong will visit Dumbledore.</span></span><br><span class="line"></span><br><span class="line">knowledge = And(</span><br><span class="line">    Implication(rain, hagrid), <span class="comment"># If it&#x27;s raining, then Zong will visit Hagrid.</span></span><br><span class="line">    Or(hagrid, dumbledore), <span class="comment"># Zong will visit Hagrid or Zong will visit Dumbledore.</span></span><br><span class="line">    Not(And(hagrid, dumbledore)), <span class="comment"># Zong will not visit both Hagrid and Dumbledore.</span></span><br><span class="line">    hagrid, <span class="comment"># Zong will visit Hagrid.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">inference = rain</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(knowledge.formula()) <span class="comment"># Should be (rain =&gt; hagrid) ∧ (hagrid ∨ dumbledore) ∧ ¬(hagrid ∧ dumbledore) ∧ hagrid</span></span><br><span class="line"></span><br><span class="line">symbols = [rain, hagrid, dumbledore]</span><br><span class="line"><span class="keyword">for</span> symbol <span class="keyword">in</span> symbols:</span><br><span class="line">    <span class="keyword">if</span> model_check(knowledge, symbol):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;symbol&#125;</span>: Yes&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        prosibilities = symbol.true / (symbol.true + symbol.false)</span><br><span class="line">        <span class="keyword">if</span> prosibilities == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;symbol&#125;</span>: No&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;symbol&#125;</span>: <span class="subst">&#123;prosibilities * <span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>KB 第一句是一句推导，如果下雨，那么 Zong 会去拜访 Hagrid，第二句是 Zong 一定会去拜访一个，第三句是说 Zong 一次只会拜访一个（如果没有这句就不能得出一定不会去拜访 Dumbledore）。</code></pre><p>其中可以看到正如之前所说，先创建 Symbols，然后通过逻辑符组成 KB，最后就可以检查在所有可能情况下，各个 Symbol 为真的概率，当然你也可以让他直接来给出结论，最后的输出如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">( rain =&gt; hagrid ∧ ( hagrid ∨ dumbledore ) ∧ ¬ ( hagrid ∧ dumbledore ) ∧ hagrid )</span><br><span class="line">rain: 50.00%</span><br><span class="line">hagrid: Yes</span><br><span class="line">dumbledore: No</span><br></pre></td></tr></table></figure><pre><code>其中，第一行是 KB 的公式。</code></pre><p>通过结果可以看出 Zong will visit Hagrid. 是肯定会发生的，Zong will visit Dumbledore. 是肯定不会发生的，下雨是一件不相关的事情（因为没说只有下雨才……），所以是 50%。</p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p>其实看到 Model Checking 的算法，就可以预见在很多 Symbols 的情况下计算时间会几何飙升，所以简化 Symbols 很重要，让它数量越少越好。</p><p>怎么简化呢，其实大家如果自己写了 Implication 和 Biconditional 这两个逻辑的实现代码就会发现，这两个玩意是可以用前三个来表示的，就像异或也可以用简单的逻辑来表达一样，这就是简化的关键。</p><p>想象一下，将所有逻辑都只有 Not 和 Or 来表达，然后再通过那些合并简化的公式，就自然而然可以让 Symbols 的数量减少，从而降低运行时间。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实通过以上的操作就能让AI具备推理能力了，因为人类也就是这样做的，再加上 NLP（自然语言处理），AI 就可以不用人类来分割语言了。</p><p>突然有个想法，让 AI 来玩狼人杀，明天准备试着写一写，感觉会很有意思。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Search篇（二），让AI玩井字棋</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A002/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A002/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="零和博弈游戏"><a href="#零和博弈游戏" class="headerlink" title="零和博弈游戏"></a>零和博弈游戏</h1><p>正如之前所说，零和博弈中的最优解不是让自己来最多的分，而是让对方拿的分更少，<strong>换言之就是保证自己最坏情况下拿的分更多</strong>。</p><p>如下图，在目前的情况下，假设你（绿色玩家）下一手（上三条线），红色玩家下一手（下九条线），就达到了解空间中的其中一个状态，对应你获得的分数如下。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/7.png"></p><pre><code>线是 Path，是 Transition Model。</code></pre><p>作为绿色玩家，你应该考虑到红色玩家不会让你得最高的分，只会让你得最少的分。</p><p>因此，你此时的三种选择对应的分数分别是 min(4, 8, 5)，min(9, 3, _) 和 min(2, _, _)，那么目前状态下你可以获得的最高分数就是 max(4, $\leq$ 3, $\leq$ 2) &#x3D; 4。</p><p>这也就是 <strong>MiniMax</strong> 的由来，来实现一下简单的井字棋。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minimax</span>(<span class="params">board, depth, player</span>):</span><br><span class="line">    <span class="keyword">if</span> player == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">        best = [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">10</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        best = [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="keyword">if</span> depth == <span class="number">0</span>:</span><br><span class="line">        score = evaluate(board)</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>, score]</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> empty_cells(board):</span><br><span class="line">        x, y = cell[<span class="number">0</span>], cell[<span class="number">1</span>]</span><br><span class="line">        board[x][y] = player</span><br><span class="line">        score = minimax(board, depth - <span class="number">1</span>, <span class="string">&#x27;O&#x27;</span> <span class="keyword">if</span> player == <span class="string">&#x27;X&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">        board[x][y] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">        score[<span class="number">0</span>], score[<span class="number">1</span>] = x, y</span><br><span class="line">        <span class="keyword">if</span> player == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> score[<span class="number">2</span>] &gt; best[<span class="number">2</span>]:</span><br><span class="line">                best = score</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> score[<span class="number">2</span>] &lt; best[<span class="number">2</span>]:</span><br><span class="line">                best = score</span><br><span class="line">    <span class="keyword">return</span> best</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">board</span>):</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> board:</span><br><span class="line">        <span class="keyword">if</span> row.count(<span class="string">&#x27;X&#x27;</span>) == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> row.count(<span class="string">&#x27;O&#x27;</span>) == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">if</span> board[<span class="number">0</span>][col] == board[<span class="number">1</span>][col] == board[<span class="number">2</span>][col] == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> board[<span class="number">0</span>][col] == board[<span class="number">1</span>][col] == board[<span class="number">2</span>][col] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> board[<span class="number">0</span>][<span class="number">0</span>] == board[<span class="number">1</span>][<span class="number">1</span>] == board[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;X&#x27;</span> <span class="keyword">or</span> board[<span class="number">0</span>][<span class="number">2</span>] == board[<span class="number">1</span>][<span class="number">1</span>] == board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> board[<span class="number">0</span>][<span class="number">0</span>] == board[<span class="number">1</span>][<span class="number">1</span>] == board[<span class="number">2</span>][<span class="number">2</span>] == <span class="string">&#x27;O&#x27;</span> <span class="keyword">or</span> board[<span class="number">0</span>][<span class="number">2</span>] == board[<span class="number">1</span>][<span class="number">1</span>] == board[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">empty_cells</span>(<span class="params">board</span>):</span><br><span class="line">    cells = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                cells.append([i, j])</span><br><span class="line">    <span class="keyword">return</span> cells</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_board</span>(<span class="params">board</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>最后的输出就会像这样，和棋也是必然的，从第二步 ‘O’ 走中间就可以看出来算法应该没有问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">-------------</span><br><span class="line">|   |   |   | </span><br><span class="line">|   |   |   | </span><br><span class="line">|   |   |   | </span><br><span class="line">-------------</span><br><span class="line">Player X</span><br><span class="line">-------------</span><br><span class="line">| X |   |   | </span><br><span class="line">|   |   |   | </span><br><span class="line">|   |   |   | </span><br><span class="line">-------------</span><br><span class="line">Player O</span><br><span class="line">-------------</span><br><span class="line">| X |   |   | </span><br><span class="line">|   | O |   | </span><br><span class="line">|   |   |   | </span><br><span class="line">-------------</span><br><span class="line">Player X</span><br><span class="line">-------------</span><br><span class="line">| X | X |   | </span><br><span class="line">|   | O |   | </span><br><span class="line">|   |   |   | </span><br><span class="line">-------------</span><br><span class="line">Player O</span><br><span class="line">-------------</span><br><span class="line">| X | X | O | </span><br><span class="line">|   | O |   |</span><br><span class="line">|   |   |   |</span><br><span class="line">-------------</span><br><span class="line">Player X</span><br><span class="line">-------------</span><br><span class="line">| X | X | O |</span><br><span class="line">|   | O |   |</span><br><span class="line">| X |   |   |</span><br><span class="line">-------------</span><br><span class="line">Player O</span><br><span class="line">-------------</span><br><span class="line">| X | X | O |</span><br><span class="line">| O | O |   |</span><br><span class="line">| X |   |   |</span><br><span class="line">-------------</span><br><span class="line">Player X</span><br><span class="line">-------------</span><br><span class="line">| X | X | O |</span><br><span class="line">| O | O | X |</span><br><span class="line">| X |   |   |</span><br><span class="line">-------------</span><br><span class="line">Player O</span><br><span class="line">-------------</span><br><span class="line">| X | X | O |</span><br><span class="line">| O | O | X |</span><br><span class="line">| X | O |   |</span><br><span class="line">-------------</span><br><span class="line">Player X</span><br><span class="line">-------------</span><br><span class="line">| X | X | O |</span><br><span class="line">| O | O | X |</span><br><span class="line">| X | O | X |</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure><h1 id="ML-的应用"><a href="#ML-的应用" class="headerlink" title="ML 的应用"></a>ML 的应用</h1><h2 id="单人游戏"><a href="#单人游戏" class="headerlink" title="单人游戏"></a>单人游戏</h2><p>如果考虑寻路的话，一般就是用 ML 来计算 A* 算法中的估价函数。</p><p>以现实生活中的导航为例，由于各种未知信息的存在，我们很难准确的给出一个估价函数来预测当前位置到目标位置的成本，因此我们可以<strong>在一个小范围内用 BFS 来计算每个点的未来成本</strong>，同时给出一些相关的因素。</p><table><thead><tr><th>直线距离</th><th>包围盒内是否有桥，如有，桥的长度</th><th>直线路径上是否有不可逾越的建筑，如有，占地面积</th><th>包围盒内&#x2F;直线路径上的红绿灯数量</th><th>未来成本</th></tr></thead><tbody><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><pre><code>此处只以走路为例，其中包围盒是指当前位置与目标位置形成的包围盒。</code></pre><p>通过 ML，就可以挖掘出这些因素是如何影响未来成本的，从而提出一个合适的估价函数。</p><h2 id="多人游戏"><a href="#多人游戏" class="headerlink" title="多人游戏"></a>多人游戏</h2><p>这就比较常见了，就像 AlphaGo 或者 Dota2 之前职业和 AI 间的比赛都是很好的应用。</p><p>那在这种复杂计算中，因为你无法概括出影响结果的因素所以 ML 就不够用了，得用 DL 让 AI 自己玩，让他自己去发掘数据间的联系。</p><p>当然了对于上面的寻路也是可以用 DL 的，通过让他自己在地图上随机游走，同时记录路径的特征，来挖掘特征与成本的关系。</p><p>这里就不具体给大家展示模型了，如果大家感兴趣的话可以看看这篇文章 <a href="https://www.geeksforgeeks.org/alphago-algorithm-in-artificial-intelligence/%E3%80%82">https://www.geeksforgeeks.org/alphago-algorithm-in-artificial-intelligence/。</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Search篇（一），让AI走迷宫</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A001/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A001/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>所谓 Search 就是寻找最优解。</p><p>生活中的话像导航，或者之前比较火的 AlphaGo 下围棋都算，我们就从比较有代表的迷宫开始。</p><h1 id="Maze"><a href="#Maze" class="headerlink" title="Maze"></a>Maze</h1><pre><code>顺带一提，之前做雅思，好像 amaze 就是从 maze 延申出来的。</code></pre><p>每一个 Maze，或者说每一个 Search 问题都能被分成以下几个部分。</p><h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><p>或者说 Player，如果是导航，那 Agent 就是你自己，如果是博弈游戏，那就是参与游戏的每个人。</p><h2 id="Initial-State"><a href="#Initial-State" class="headerlink" title="Initial State"></a>Initial State</h2><p>同样的，如果是导航那就是你的起点，如果是围棋，那就是空棋盘。</p><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>被规则允许的所有 Action。</p><h2 id="Transition-Model"><a href="#Transition-Model" class="headerlink" title="Transition Model"></a>Transition Model</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Result</span>(<span class="params">State, Action</span>):</span><br><span class="line">    ...</span><br><span class="line">    retun state</span><br></pre></td></tr></table></figure><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/3.jpg"></p><h2 id="State-Space"><a href="#State-Space" class="headerlink" title="State Space"></a>State Space</h2><p>没什么好说的，状态转移图。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/4.jpg"></p><p>可以被简化成有向图。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/5.jpg"></p><h2 id="Goal-Test"><a href="#Goal-Test" class="headerlink" title="Goal Test"></a>Goal Test</h2><p>没什么好说的，不然连解出来了都不知道。</p><h2 id="Path-Cost-Function"><a href="#Path-Cost-Function" class="headerlink" title="Path Cost Function"></a>Path Cost Function</h2><p>不同问题中的 Path Cost 是不一样的，可能是时间，可能是距离，也可能是单位1（围棋每一手的成本都是一样的），也可以是预测的未来成本。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>既然是寻找解，肯定要知道解是什么，或者说目标状态是怎么样的。</p><p>对于单人问题，解自然是满足你的需求或者说达成你的目标。</p><p>但是多人问题就不一样了，以围棋举例，就是输赢平三种解。</p><h2 id="Optimal-Solution"><a href="#Optimal-Solution" class="headerlink" title="Optimal Solution"></a>Optimal Solution</h2><p>单人问题很简单，最契合你的需求的就是最优解。</p><p>多人问题就比较复杂了，如果是合作，那很明显就是一起获得更多的分，如果是零和博弈，那就是让对方获得的分更少，而不是让自己获得的分更多，其他博弈的话也基本是让自己的分更多。</p><h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><p>没什么好说的，用节点就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, parent, action, cost</span>):</span><br><span class="line">        self.state = state <span class="comment"># 当前状态</span></span><br><span class="line">        self.parent = parent <span class="comment"># 父亲状态</span></span><br><span class="line">        self.action = action <span class="comment"># Transition Model 里的 action</span></span><br><span class="line">        self.cost = cost <span class="comment"># 总成本</span></span><br></pre></td></tr></table></figure><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="Depth-First-Search-x2F-Breadth-First-Search"><a href="#Depth-First-Search-x2F-Breadth-First-Search" class="headerlink" title="Depth First Search &#x2F; Breadth First Search"></a>Depth First Search &#x2F; Breadth First Search</h2><p>这两个么没什么好说的了就，直接看代码吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackFrontier</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.frontier = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, node</span>):</span><br><span class="line">        self.frontier.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains_state</span>(<span class="params">self, state</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">any</span>(node.state == state <span class="keyword">for</span> node <span class="keyword">in</span> self.frontier)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.frontier) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;empty frontier&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = self.frontier[-<span class="number">1</span>]</span><br><span class="line">            self.frontier = self.frontier[:-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueFrontier</span>(<span class="title class_ inherited__">StackFrontier</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;empty frontier&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = self.frontier[<span class="number">0</span>]</span><br><span class="line">            self.frontier = self.frontier[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Maze</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename</span>):</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">neighbors</span>(<span class="params">self, state</span>):</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self</span>):</span><br><span class="line">        start = Node(state=self.start, parent=<span class="literal">None</span>, action=<span class="literal">None</span>, cost=<span class="number">0</span>)</span><br><span class="line">        frontier = QueueFrontier()</span><br><span class="line">        frontier.add(start)</span><br><span class="line"></span><br><span class="line">        self.explored = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> frontier.empty():</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;no solution&quot;</span>)</span><br><span class="line"></span><br><span class="line">            node = frontier.remove()</span><br><span class="line">            self.explored.add(node.state)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.state == self.goal:</span><br><span class="line">                actions = []</span><br><span class="line">                cells = []</span><br><span class="line">                <span class="keyword">while</span> node.parent <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    actions.append(node.action)</span><br><span class="line">                    cells.append(node.state)</span><br><span class="line">                    node = node.parent</span><br><span class="line">                actions.reverse()</span><br><span class="line">                cells.reverse()</span><br><span class="line">                self.solution = (actions, cells)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> action, state <span class="keyword">in</span> self.neighbors(node.state):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> frontier.contains_state(state) <span class="keyword">and</span> state <span class="keyword">not</span> <span class="keyword">in</span> self.explored:</span><br><span class="line">                    child = Node(state=state, parent=node, action=action, cost=node.cost + <span class="number">1</span>)</span><br><span class="line">                    frontier.add(child)</span><br></pre></td></tr></table></figure><h2 id="Revised-Approach"><a href="#Revised-Approach" class="headerlink" title="Revised Approach"></a>Revised Approach</h2><p>这个也没什么好说的，就是因为可能是带环图，所以要有一个状态集存放已经探索过的状态。</p><h2 id="Greedy-Best-first-Search（贪婪算法）"><a href="#Greedy-Best-first-Search（贪婪算法）" class="headerlink" title="Greedy Best-first Search（贪婪算法）"></a>Greedy Best-first Search（贪婪算法）</h2><p>由于 DFS 只是随机转移，不考虑未来到达解还需要多少成本，所以有时候找到的不是最优解，而 BFS 占用空间又过大，所以需要优化 DFS。</p><p>贪婪算法每次都往 Estimated Cost to Goal 最低的状态过渡（此时 Node 中的 cost 就应该是 Estimated Cost to Goal 而不是 Sum Cost，因为只要找到就必然是最优解）。</p><p>在迷宫游戏中，每个状态到解的成本的预测值就是 Agent 此时到解的曼哈顿距离（dx + dy）。</p><h2 id="A-Search"><a href="#A-Search" class="headerlink" title="A* Search"></a>A* Search</h2><p>当然了贪婪算法还是有问题的，在如下图中使用贪婪算法就依然找不到最优解，因为没有考虑到 Cost to Reach Node。</p><p>所以目前的最终 cost &#x3D; cost to reach node + estimated cost to goal($\geq$ 0)。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/6.jpg"></p><p>图中的数字是预测的总 cost &#x3D; cost to reach node + estimated cost to goal<br>值得注意的是，<em><em>即使是 A</em> 算法也不是一定能找到最优解的（因为找不到完美的的估价函数）</em>*，但是那些就得视情况做针对性的优化了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>写的不少了，不知道大家觉得难度怎么样（这一篇应该算比较简单的了）。</p><p>下一篇会讲零和博弈游戏。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>求证人类的本质是复读机</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A017/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A017/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>啊哈，我又来更新了，原本是想结束了来着，但是又找到了几个好玩的题，所以来更新一下，顺便把之前欠的补了，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="石头剪刀布"><a href="#石头剪刀布" class="headerlink" title="石头剪刀布"></a>石头剪刀布</h1><p>不知道当你看到这个题目的时候想到了什么策略，总之强化学习肯定是用不了的，因为纯概率游戏是没有最优策略的，给大家看看我写的三个策略。</p><h2 id="策略1"><a href="#策略1" class="headerlink" title="策略1"></a>策略1</h2><p>出能赢对手上次出的那一手。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Strategy1: play the winning move of the opponent&#x27;s last move</span></span><br><span class="line"><span class="keyword">if</span> prev_play == <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;P&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> prev_play == <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;S&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> prev_play == <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;R&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> random.choice([<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;S&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="策略2"><a href="#策略2" class="headerlink" title="策略2"></a>策略2</h2><p>出能赢对手最容易出的那一手。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Strategy2: play the winning move of the opponent&#x27;s most frequent move</span></span><br><span class="line"><span class="keyword">if</span> opponent_history.count(<span class="string">&#x27;R&#x27;</span>) &gt; opponent_history.count(<span class="string">&#x27;P&#x27;</span>) <span class="keyword">and</span> opponent_history.count(<span class="string">&#x27;R&#x27;</span>) &gt; opponent_history.count(<span class="string">&#x27;S&#x27;</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;P&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> opponent_history.count(<span class="string">&#x27;P&#x27;</span>) &gt; opponent_history.count(<span class="string">&#x27;R&#x27;</span>) <span class="keyword">and</span> opponent_history.count(<span class="string">&#x27;P&#x27;</span>) &gt; opponent_history.count(<span class="string">&#x27;S&#x27;</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;S&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> opponent_history.count(<span class="string">&#x27;S&#x27;</span>) &gt; opponent_history.count(<span class="string">&#x27;R&#x27;</span>) <span class="keyword">and</span> opponent_history.count(<span class="string">&#x27;S&#x27;</span>) &gt; opponent_history.count(<span class="string">&#x27;P&#x27;</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;R&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> random.choice([<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;S&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="策略3"><a href="#策略3" class="headerlink" title="策略3"></a>策略3</h2><p>用马尔可夫链预测对手最容易出的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Strategy3: play the winning move through markov chain</span></span><br><span class="line">r2r_count = opponent_history.count(<span class="string">&#x27;RR&#x27;</span>)</span><br><span class="line">r2p_count = opponent_history.count(<span class="string">&#x27;RP&#x27;</span>)</span><br><span class="line">r2s_count = opponent_history.count(<span class="string">&#x27;RS&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p2p_count = opponent_history.count(<span class="string">&#x27;PP&#x27;</span>)</span><br><span class="line">p2r_count = opponent_history.count(<span class="string">&#x27;PR&#x27;</span>)</span><br><span class="line">p2s_count = opponent_history.count(<span class="string">&#x27;PS&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s2s_count = opponent_history.count(<span class="string">&#x27;SS&#x27;</span>)</span><br><span class="line">s2r_count = opponent_history.count(<span class="string">&#x27;SR&#x27;</span>)</span><br><span class="line">s2p_count = opponent_history.count(<span class="string">&#x27;SP&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> prev_play == <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> r2r_count &gt; r2p_count <span class="keyword">and</span> r2r_count &gt; r2s_count:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;R&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> r2p_count &gt; r2r_count <span class="keyword">and</span> r2p_count &gt; r2s_count:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;P&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> r2s_count &gt; r2r_count <span class="keyword">and</span> r2s_count &gt; r2p_count:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;S&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> random.choice([<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;S&#x27;</span>])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">elif</span> prev_play == <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> p2p_count &gt; p2r_count <span class="keyword">and</span> p2p_count &gt; p2s_count:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;P&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> p2r_count &gt; p2p_count <span class="keyword">and</span> p2r_count &gt; p2s_count:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;R&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> p2s_count &gt; p2p_count <span class="keyword">and</span> p2s_count &gt; p2r_count:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;S&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> random.choice([<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;S&#x27;</span>])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">elif</span> prev_play == <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> s2s_count &gt; s2r_count <span class="keyword">and</span> s2s_count &gt; s2p_count:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;S&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> s2r_count &gt; s2s_count <span class="keyword">and</span> s2r_count &gt; s2p_count:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;R&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> s2p_count &gt; s2s_count <span class="keyword">and</span> s2p_count &gt; s2r_count:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;P&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> random.choice([<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;S&#x27;</span>])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> random.choice([<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;S&#x27;</span>])</span><br></pre></td></tr></table></figure><p>上面这些应该都挺简单的，大家随便过一下就行，来看下一趴。</p><h1 id="人类的本质是复读机"><a href="#人类的本质是复读机" class="headerlink" title="人类的本质是复读机"></a>人类的本质是复读机</h1><p>不知道大家有没有听过这句话，“人的本质是复读机”，我们今天就来模拟一下。</p><h2 id="生存游戏"><a href="#生存游戏" class="headerlink" title="生存游戏"></a>生存游戏</h2><p>因为是模拟人类社会，所以这个生存游戏肯定得有合作有竞争，所以就使用比较经典的囚徒困境就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define the pay - off matrix for the Prisoner&#x27;s Dilemma</span></span><br><span class="line">PAYOFF_MATRIX = &#123;</span><br><span class="line">    (<span class="string">&#x27;cooperate&#x27;</span>, <span class="string">&#x27;cooperate&#x27;</span>): (<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="string">&#x27;cooperate&#x27;</span>, <span class="string">&#x27;defect&#x27;</span>): (-<span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="string">&#x27;defect&#x27;</span>, <span class="string">&#x27;cooperate&#x27;</span>): (<span class="number">3</span>, -<span class="number">1</span>),</span><br><span class="line">    (<span class="string">&#x27;defect&#x27;</span>, <span class="string">&#x27;defect&#x27;</span>): (-<span class="number">3</span>, -<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生存策略"><a href="#生存策略" class="headerlink" title="生存策略"></a>生存策略</h2><p>这边的话就先来四个策略，第三个就是所谓的复读机（重复遇到的上一个玩家的策略），最后应该会再放一个 AI 进去学。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define different strategies</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">always_cooperate</span>(<span class="params">history</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;cooperate&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">always_defect</span>(<span class="params">history</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;defect&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tit_for_tat</span>(<span class="params">history</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> history:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;cooperate&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> history[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_choice</span>(<span class="params">history</span>):</span><br><span class="line">    <span class="keyword">return</span> random.choice([<span class="string">&#x27;cooperate&#x27;</span>, <span class="string">&#x27;defect&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Player class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, strategy</span>):</span><br><span class="line">        self.strategy = strategy</span><br><span class="line">        self.score = <span class="number">10</span></span><br><span class="line">        self.history = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_choice</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.strategy(self.history)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_score</span>(<span class="params">self, payoff</span>):</span><br><span class="line">        self.score += payoff</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_history</span>(<span class="params">self, own_choice, other_choice</span>):</span><br><span class="line">        self.history.append((own_choice, other_choice))</span><br></pre></td></tr></table></figure><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>因为是生存模拟，所以肯定得淘汰低于0分的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function to run the simulation</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_simulation</span>(<span class="params">num_players_per_strategy, num_rounds</span>):</span><br><span class="line">    strategies = [always_cooperate, always_defect, tit_for_tat, random_choice]</span><br><span class="line">    players = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create players with equal distribution of strategies</span></span><br><span class="line">    <span class="keyword">for</span> strategy <span class="keyword">in</span> strategies:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_players_per_strategy):</span><br><span class="line">            players.append(Player(strategy))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> round_num <span class="keyword">in</span> <span class="built_in">range</span>(num_rounds):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;round_num: &quot;</span> + <span class="built_in">str</span>(round_num))</span><br><span class="line"></span><br><span class="line">        random.shuffle(players)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(players), <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(players):</span><br><span class="line">                play_round(players[i], players[i + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Remove players with score &lt;= 0</span></span><br><span class="line">        players = [player <span class="keyword">for</span> player <span class="keyword">in</span> players <span class="keyword">if</span> player.score &gt; <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        always_cooperate_count = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> player <span class="keyword">in</span> players <span class="keyword">if</span> player.strategy == always_cooperate)</span><br><span class="line">        always_defect_count = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> player <span class="keyword">in</span> players <span class="keyword">if</span> player.strategy == always_defect)</span><br><span class="line">        tit_for_tat_count = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> player <span class="keyword">in</span> players <span class="keyword">if</span> player.strategy == tit_for_tat)</span><br><span class="line">        random_choice_count = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> player <span class="keyword">in</span> players <span class="keyword">if</span> player.strategy == random_choice)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;always_cooperate: &quot;</span> + <span class="built_in">str</span>(always_cooperate_count))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;always_defect: &quot;</span> + <span class="built_in">str</span>(always_defect_count))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;tit_for_tat: &quot;</span> + <span class="built_in">str</span>(tit_for_tat_count))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;random_choice: &quot;</span> + <span class="built_in">str</span>(random_choice_count))</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h2 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h2><p>看一下这个结果，总是合作的竟然一个都没被淘汰，说明囚徒困境的得分设置的不合理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">round_num: 9999</span><br><span class="line">always_cooperate: 10</span><br><span class="line">always_defect: 6</span><br><span class="line">tit_for_tat: 10</span><br><span class="line">random_choice: 8</span><br></pre></td></tr></table></figure><p>可以调整成下面这样，这样的话对于任何策略的得分期望就是0了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PAYOFF_MATRIX = &#123;</span><br><span class="line">    (<span class="string">&#x27;cooperate&#x27;</span>, <span class="string">&#x27;cooperate&#x27;</span>): (<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="string">&#x27;cooperate&#x27;</span>, <span class="string">&#x27;defect&#x27;</span>): (-<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="string">&#x27;defect&#x27;</span>, <span class="string">&#x27;cooperate&#x27;</span>): (<span class="number">3</span>, -<span class="number">3</span>),</span><br><span class="line">    (<span class="string">&#x27;defect&#x27;</span>, <span class="string">&#x27;defect&#x27;</span>): (-<span class="number">3</span>, -<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h2><p>结果全死光了，就剩一个复读机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">round_num: 9999</span><br><span class="line">always_cooperate: 0</span><br><span class="line">always_defect: 0</span><br><span class="line">tit_for_tat: 1</span><br><span class="line">random_choice: 0</span><br></pre></td></tr></table></figure><p>所以得再每次淘汰的时候添加新生儿，直接copy一份就好了（无性繁殖hhh）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>(players) &lt; <span class="built_in">len</span>(strategies) * num_players_per_strategy):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Copy players&quot;</span>)</span><br><span class="line">    players_copy = players.copy()</span><br><span class="line">    <span class="keyword">for</span> player <span class="keyword">in</span> players_copy:</span><br><span class="line">        players.append(Player(player.strategy, player.score))</span><br></pre></td></tr></table></figure><h2 id="优化3"><a href="#优化3" class="headerlink" title="优化3"></a>优化3</h2><p>跑了两趟，结果还是差别挺大的，毕竟跟谁玩是完全随机的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Round: 99</span><br><span class="line">Always cooperate: 21.21212121212121%</span><br><span class="line">Always defect: 31.818181818181817%</span><br><span class="line">Tit for tat: 15.151515151515152%</span><br><span class="line">Random choice: 31.818181818181817%</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Round: 99</span><br><span class="line">Always cooperate: 28.169014084507044%</span><br><span class="line">Always defect: 22.535211267605636%</span><br><span class="line">Tit for tat: 29.577464788732392%</span><br><span class="line">Random choice: 19.718309859154928%</span><br></pre></td></tr></table></figure><p>应该让玩家随机出生在一个位置，然后围成一个圆，只会跟附近的人进行囚徒博弈，所以只在一开始 shuffle 一下，后面就相邻的人玩。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">random.shuffle(players)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> round_num <span class="keyword">in</span> <span class="built_in">range</span>(num_rounds):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Round: &quot;</span> + <span class="built_in">str</span>(round_num))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(players)):</span><br><span class="line">        play_round(players[i], (players[(i + <span class="number">1</span>) % <span class="built_in">len</span>(players)]))</span><br></pre></td></tr></table></figure><h2 id="优化4"><a href="#优化4" class="headerlink" title="优化4"></a>优化4</h2><p>看了一眼结果，看起来好麻烦，所以再加一下图形化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Round: 99</span><br><span class="line">Always cooperate: 7</span><br><span class="line">Always defect: 2</span><br><span class="line">Tit for tat: 7</span><br><span class="line">Random choice: 5</span><br><span class="line">&lt;function random_choice at 0x1029860c0&gt;</span><br><span class="line">&lt;function always_defect at 0x102987100&gt;</span><br><span class="line">&lt;function always_cooperate at 0x102986f20&gt;</span><br><span class="line">&lt;function tit_for_tat at 0x102986e80&gt;</span><br><span class="line">&lt;function always_cooperate at 0x102986f20&gt;</span><br><span class="line">&lt;function tit_for_tat at 0x102986e80&gt;</span><br><span class="line">&lt;function always_defect at 0x102987100&gt;</span><br><span class="line">&lt;function random_choice at 0x1029860c0&gt;</span><br><span class="line">&lt;function tit_for_tat at 0x102986e80&gt;</span><br><span class="line">&lt;function always_cooperate at 0x102986f20&gt;</span><br><span class="line">&lt;function always_cooperate at 0x102986f20&gt;</span><br><span class="line">&lt;function always_cooperate at 0x102986f20&gt;</span><br><span class="line">&lt;function always_cooperate at 0x102986f20&gt;</span><br><span class="line">&lt;function random_choice at 0x1029860c0&gt;</span><br><span class="line">&lt;function random_choice at 0x1029860c0&gt;</span><br><span class="line">&lt;function tit_for_tat at 0x102986e80&gt;</span><br><span class="line">&lt;function tit_for_tat at 0x102986e80&gt;</span><br><span class="line">&lt;function tit_for_tat at 0x102986e80&gt;</span><br><span class="line">&lt;function random_choice at 0x1029860c0&gt;</span><br><span class="line">&lt;function tit_for_tat at 0x102986e80&gt;</span><br><span class="line">&lt;function always_cooperate at 0x102986f20&gt;</span><br></pre></td></tr></table></figure><p>效果如下，看上去似乎还行，不过为了保险起见，先去掉随机者再观察一下。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/66.png"></p><p>改了一下，这次没问题了，看结果的话就是复读机和永远合作容易活，毕竟永远竞争会内部消耗，接下来就加个 AI 试试。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/67.png"></p><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>仔细想了一下，好像没法让 AI 学策略，学出来也是跟随机者差不多估计，因为状态只有两个，学的也最多是一个不均等的选择概率。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Uncertainty篇（一），用马尔可夫链求PageRank</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A007/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A007/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说实话，感觉也没什么好说的，都是大学概率统计学的内容，就挑重点讲一下吧，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h1><p>马尔可夫链直白点说就是状态转移，如下图所示。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/15.png"></p><p>通过这样一个转移概率图，我们可以求出转移矩阵，类似下图。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/16.png"></p><p>通过这个矩阵，我们可以做很多事情，如下图，不过具体的还是来个实战吧。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/17.jpg"></p><h1 id="Page-Rank"><a href="#Page-Rank" class="headerlink" title="Page Rank"></a>Page Rank</h1><p>Page Rank 就是用来评估网页的价值的（被更多网站引用的网站一般价值会更高）。</p><p>那我们这边主要用两种方法来计算，一种是随机冲浪者模型，另一种是迭代算法。</p><h2 id="随机冲浪者模型"><a href="#随机冲浪者模型" class="headerlink" title="随机冲浪者模型"></a>随机冲浪者模型</h2><p>这模型说白了就是在模拟大家平时浏览网站的操作。</p><p>假设大家随机从一个网站开始，当我们浏览完毕后，我们有一定概率（DAMPING）会去浏览它引用的其中一个网站，还有一定概率会重新再选一个网站浏览（1 - DAMPING）。</p><p>于是我们就可以写出如下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">DAMPING = <span class="number">0.85</span></span><br><span class="line">SAMPLES = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transition_model</span>(<span class="params">corpus, page, damping_factor</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return a probability distribution over which page to visit next,</span></span><br><span class="line"><span class="string">    given a current page.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    With probability `damping_factor`, choose a link at random</span></span><br><span class="line"><span class="string">    linked to by `page`. With probability `1 - damping_factor`, choose</span></span><br><span class="line"><span class="string">    a link at random chosen from all pages in the corpus.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create a dictionary to store the probability distribution</span></span><br><span class="line">    probability_distribution = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># If the page has no links, return a probability distribution that chooses randomly from all pages</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(corpus[page]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> corpus:</span><br><span class="line">            probability_distribution[page] = <span class="number">1</span> / <span class="built_in">len</span>(corpus)</span><br><span class="line">        <span class="keyword">return</span> probability_distribution</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate the probability of choosing a link at random linked to the page</span></span><br><span class="line">    <span class="keyword">for</span> linked_page <span class="keyword">in</span> corpus[page]:</span><br><span class="line">        probability_distribution[linked_page] = damping_factor / <span class="built_in">len</span>(corpus[page])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate the probability of choosing a link at random from all pages</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> corpus:</span><br><span class="line">        probability_distribution[page] = (<span class="number">1</span> - damping_factor) / <span class="built_in">len</span>(corpus)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> probability_distribution</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sample_pagerank</span>(<span class="params">corpus, damping_factor, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return PageRank values for each page by sampling `n` pages</span></span><br><span class="line"><span class="string">    according to transition model, starting with a page at random.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return a dictionary where keys are page names, and values are</span></span><br><span class="line"><span class="string">    their estimated PageRank value (a value between 0 and 1). All</span></span><br><span class="line"><span class="string">    PageRank values should sum to 1.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a dictionary to store the number of times each page is visited</span></span><br><span class="line">    page_visits = &#123;page: <span class="number">0</span> <span class="keyword">for</span> page <span class="keyword">in</span> corpus&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Choose a random page to start</span></span><br><span class="line">    current_page = random.choice(<span class="built_in">list</span>(corpus.keys()))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Visit n pages</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        page_visits[current_page] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Get the probability distribution for the current page</span></span><br><span class="line">        probability_distribution = transition_model(corpus, current_page, damping_factor)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Choose the next page based on the probability distribution</span></span><br><span class="line">        current_page = random.choices(<span class="built_in">list</span>(probability_distribution.keys()), weights=probability_distribution.values(), k=<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate the PageRank values</span></span><br><span class="line">    page_rank = &#123;page: page_visits[page] / n <span class="keyword">for</span> page <span class="keyword">in</span> corpus&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> page_rank</span><br></pre></td></tr></table></figure><p>其中 transition_model 就是我们的冲浪逻辑，而 sample_pagerank 中，通过记录 n 次冲浪时浏览的网站来给出相应的 Page Rank。</p><h2 id="迭代算法"><a href="#迭代算法" class="headerlink" title="迭代算法"></a>迭代算法</h2><p>迭代算法是笨办法，就是对于网页的权重，一开始因为不知道所以都是0，但是我们知道<strong>每个网页的权重是能转移到它的网页的概率权重 + 随机浏览的概率权重</strong>，所以我们可以一直迭代算它们的权重，一直到<strong>所有网页的权重和为1</strong>结束，代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">iterate_pagerank</span>(<span class="params">corpus, damping_factor</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return PageRank values for each page by iteratively updating</span></span><br><span class="line"><span class="string">    PageRank values until convergence.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return a dictionary where keys are page names, and values are</span></span><br><span class="line"><span class="string">    their estimated PageRank value (a value between 0 and 1). All</span></span><br><span class="line"><span class="string">    PageRank values should sum to 1.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create a dictionary to store the PageRank values</span></span><br><span class="line">    page_rank = &#123;page: <span class="number">1</span> / <span class="built_in">len</span>(corpus) <span class="keyword">for</span> page <span class="keyword">in</span> corpus&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create a dictionary to store the new PageRank values</span></span><br><span class="line">    new_page_rank = &#123;page: <span class="number">0</span> <span class="keyword">for</span> page <span class="keyword">in</span> corpus&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create a boolean variable to check if the PageRank values have converged</span></span><br><span class="line">    converged = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Iterate until the PageRank values converge</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> converged:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Calculate the new PageRank values</span></span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> corpus:</span><br><span class="line">            new_page_rank[page] = (<span class="number">1</span> - damping_factor) / <span class="built_in">len</span>(corpus)</span><br><span class="line">            <span class="keyword">for</span> linking_page <span class="keyword">in</span> corpus:</span><br><span class="line">                <span class="keyword">if</span> page <span class="keyword">in</span> corpus[linking_page]:</span><br><span class="line">                    new_page_rank[page] += damping_factor * page_rank[linking_page] / <span class="built_in">len</span>(corpus[linking_page])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Check if the PageRank values have converged</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(<span class="built_in">abs</span>(new_page_rank[page] - page_rank[page]) &lt; <span class="number">0.001</span> <span class="keyword">for</span> page <span class="keyword">in</span> corpus):</span><br><span class="line">            converged = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Update the PageRank values</span></span><br><span class="line">        page_rank = new_page_rank.copy()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> page_rank</span><br></pre></td></tr></table></figure><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>最后来看一个例子，给出下图的状态转移图。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/18.png"></p><p>给大家看一下结果，可以发现差别还是很大的，随机冲浪者模型算出的的 Page Rank 的方差看上去比迭代算法的高了太多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PageRank Results <span class="keyword">from</span> Sampling (damping factor = <span class="number">0.85</span>, samples = <span class="number">10000</span>)</span><br><span class="line">  <span class="number">1.</span>html: <span class="number">0.0393</span></span><br><span class="line">  <span class="number">2.</span>html: <span class="number">0.8808</span></span><br><span class="line">  <span class="number">3.</span>html: <span class="number">0.0396</span></span><br><span class="line">  <span class="number">4.</span>html: <span class="number">0.0403</span></span><br><span class="line">PageRank Results <span class="keyword">from</span> Iteration</span><br><span class="line">  <span class="number">1.</span>html: <span class="number">0.2198</span></span><br><span class="line">  <span class="number">2.</span>html: <span class="number">0.4294</span></span><br><span class="line">  <span class="number">3.</span>html: <span class="number">0.2198</span></span><br><span class="line">  <span class="number">4.</span>html: <span class="number">0.1311</span></span><br></pre></td></tr></table></figure><p>那是什么原因导致的呢？大家可以想一想。</p><p>其实是因为迭代算法前几次由于没有相关网页的权重，所以导致他迭代算了很多次随机游走的概率，才使得结果会更向平均值靠拢。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>完整代码 <a href="https://github.com/zong4/AILearning">https://github.com/zong4/AILearning</a> 中还有几个例子，大家都可以跑一跑试试，也可以改改这两个超参数（严格来说迭代步数其实不能算超参数），来看看结果会有什么变化。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Uncertainty篇（二），用隐式马尔可夫链解遗传问题</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A008/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A008/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="隐式马尔可夫链"><a href="#隐式马尔可夫链" class="headerlink" title="隐式马尔可夫链"></a>隐式马尔可夫链</h1><p>隐式马尔可夫链就是在马尔可夫链的基础上多了观察变量，如下图上半部分就是我们上一篇讲的马尔可夫链，具体可以阅读<a href="../../30/AI%E5%AD%A6%E4%B9%A007">这一篇</a>。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/19.jpeg"></p><p>OK，那除此之外，在显式马尔可夫链中，我们是知道整个转移模型的（也就是上图的绿线），而在隐式马尔可夫链中我们只知道转移模型中的各状态对应传感器状态（也就是观察变量）的概率（也就是上图的红线）。</p><p>那自然我们除了之前的转移矩阵还有一个新的矩阵如下图所示。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/20.jpeg"></p><p>于是我们就可以去计算各种情况的发生概率了。</p><p>不过大部分情况，我们之所以要<strong>用隐式马尔可夫链是因为我们不知道显式的马尔可夫链</strong>，比如下图的问题，对于这样的 笑脸 -&gt; 笑脸 -&gt; 苦脸 的顺序，天气的顺序最有可能是怎么样的？概率又是多少呢？</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/21.jpeg"></p><p>具体的计算思路就是类似于<strong>有记忆的递归算法</strong>，如下哦，这就不多说了吧，毕竟概率也是左加右嘛。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/22.jpeg"></p><h1 id="遗传问题"><a href="#遗传问题" class="headerlink" title="遗传问题"></a>遗传问题</h1><p>OK，接下来就让我们来试着解一下遗传问题。</p><p>我们可以将任何遗传问题用下图表示。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/24.png"></p><h2 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h2><ol><li>来吧，首先是人群中（独立）携带指定基因的概率，用来算一开始第一步的概率，相当于初始状态。</li><li>然后是携带基因的表现概率，就是说有的人携带了也不会表达出来，表达出来了才算基因起作用了。</li><li>最后是突变概率。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PROBS = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Unconditional probabilities for having gene</span></span><br><span class="line">    <span class="string">&quot;gene&quot;</span>: &#123;</span><br><span class="line">        <span class="number">2</span>: <span class="number">0.01</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="number">0.03</span>,</span><br><span class="line">        <span class="number">0</span>: <span class="number">0.96</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;trait&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Probability of trait given two copies of gene</span></span><br><span class="line">        <span class="number">2</span>: &#123;</span><br><span class="line">            <span class="literal">True</span>: <span class="number">0.65</span>,</span><br><span class="line">            <span class="literal">False</span>: <span class="number">0.35</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Probability of trait given one copy of gene</span></span><br><span class="line">        <span class="number">1</span>: &#123;</span><br><span class="line">            <span class="literal">True</span>: <span class="number">0.56</span>,</span><br><span class="line">            <span class="literal">False</span>: <span class="number">0.44</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Probability of trait given no gene</span></span><br><span class="line">        <span class="number">0</span>: &#123;</span><br><span class="line">            <span class="literal">True</span>: <span class="number">0.01</span>,</span><br><span class="line">            <span class="literal">False</span>: <span class="number">0.99</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Mutation probability</span></span><br><span class="line">    <span class="string">&quot;mutation&quot;</span>: <span class="number">0.01</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h2><p>这里的计算方法是考虑每一种情况然后累加概率，可以通过以下函数计算任一种情况的概率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">joint_probability</span>(<span class="params">people, one_gene, two_genes, have_trait</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Compute and return a joint probability.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The probability returned should be the probability that</span></span><br><span class="line"><span class="string">        * everyone in set `one_gene` has one copy of the gene, and</span></span><br><span class="line"><span class="string">        * everyone in set `two_genes` has two copies of the gene, and</span></span><br><span class="line"><span class="string">        * everyone not in `one_gene` or `two_gene` does not have the gene, and</span></span><br><span class="line"><span class="string">        * everyone in set `have_trait` has the trait, and</span></span><br><span class="line"><span class="string">        * everyone not in set` have_trait` does not have the trait.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize joint probability</span></span><br><span class="line">    p = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Loop over all people</span></span><br><span class="line">    <span class="keyword">for</span> person <span class="keyword">in</span> people:</span><br><span class="line">        <span class="comment"># Get number of genes</span></span><br><span class="line">        genes = <span class="number">2</span> <span class="keyword">if</span> person <span class="keyword">in</span> two_genes <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">if</span> person <span class="keyword">in</span> one_gene <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get trait</span></span><br><span class="line">        trait = person <span class="keyword">in</span> have_trait</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get parents</span></span><br><span class="line">        mother = people[person][<span class="string">&quot;mother&quot;</span>]</span><br><span class="line">        father = people[person][<span class="string">&quot;father&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get probability of gene</span></span><br><span class="line">        <span class="keyword">if</span> mother <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> father <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            p_gene = PROBS[<span class="string">&quot;gene&quot;</span>][genes]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Get number of genes from parents</span></span><br><span class="line">            n_genes_mother = <span class="number">2</span> <span class="keyword">if</span> mother <span class="keyword">in</span> two_genes <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">if</span> mother <span class="keyword">in</span> one_gene <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n_genes_father = <span class="number">2</span> <span class="keyword">if</span> father <span class="keyword">in</span> two_genes <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">if</span> father <span class="keyword">in</span> one_gene <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Calculate probability of gene</span></span><br><span class="line">            <span class="keyword">if</span> genes == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> n_genes_mother == <span class="number">0</span> <span class="keyword">and</span> n_genes_father == <span class="number">0</span>:</span><br><span class="line">                    p_gene = (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>])</span><br><span class="line">                <span class="keyword">elif</span> (n_genes_mother == <span class="number">0</span> <span class="keyword">and</span> n_genes_father == <span class="number">1</span>) <span class="keyword">or</span> (n_genes_mother == <span class="number">1</span> <span class="keyword">and</span> n_genes_father == <span class="number">0</span>):</span><br><span class="line">                    p_gene = (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * <span class="number">0.5</span></span><br><span class="line">                <span class="keyword">elif</span> n_genes_mother == <span class="number">1</span> <span class="keyword">and</span> n_genes_father == <span class="number">1</span>:</span><br><span class="line">                    p_gene = <span class="number">0.5</span> * <span class="number">0.5</span></span><br><span class="line">                <span class="keyword">elif</span> (n_genes_mother == <span class="number">0</span> <span class="keyword">and</span> n_genes_father == <span class="number">2</span>) <span class="keyword">or</span> (n_genes_mother == <span class="number">2</span> <span class="keyword">and</span> n_genes_father == <span class="number">0</span>):</span><br><span class="line">                    p_gene = (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * PROBS[<span class="string">&quot;mutation&quot;</span>]</span><br><span class="line">                <span class="keyword">elif</span> (n_genes_mother == <span class="number">1</span> <span class="keyword">and</span> n_genes_father == <span class="number">2</span>) <span class="keyword">or</span> (n_genes_mother == <span class="number">2</span> <span class="keyword">and</span> n_genes_father == <span class="number">1</span>):</span><br><span class="line">                    p_gene = <span class="number">0.5</span> * PROBS[<span class="string">&quot;mutation&quot;</span>]</span><br><span class="line">                <span class="keyword">elif</span> n_genes_mother == <span class="number">2</span> <span class="keyword">and</span> n_genes_father == <span class="number">2</span>:</span><br><span class="line">                    p_gene = PROBS[<span class="string">&quot;mutation&quot;</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>]</span><br><span class="line">            <span class="keyword">elif</span> genes == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> n_genes_mother == <span class="number">0</span> <span class="keyword">and</span> n_genes_father == <span class="number">0</span>:</span><br><span class="line">                    p_gene = (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * PROBS[<span class="string">&quot;mutation&quot;</span>] + PROBS[<span class="string">&quot;mutation&quot;</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>])</span><br><span class="line">                <span class="keyword">elif</span> (n_genes_mother == <span class="number">0</span> <span class="keyword">and</span> n_genes_father == <span class="number">1</span>) <span class="keyword">or</span> (n_genes_mother == <span class="number">1</span> <span class="keyword">and</span> n_genes_father == <span class="number">0</span>):</span><br><span class="line">                    p_gene = <span class="number">0.5</span> * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) + <span class="number">0.5</span> * PROBS[<span class="string">&quot;mutation&quot;</span>]</span><br><span class="line">                <span class="keyword">elif</span> n_genes_mother == <span class="number">1</span> <span class="keyword">and</span> n_genes_father == <span class="number">1</span>:</span><br><span class="line">                    p_gene = <span class="number">0.5</span> * <span class="number">0.5</span> + <span class="number">0.5</span> * <span class="number">0.5</span></span><br><span class="line">                <span class="keyword">elif</span> (n_genes_mother == <span class="number">0</span> <span class="keyword">and</span> n_genes_father == <span class="number">2</span>) <span class="keyword">or</span> (n_genes_mother == <span class="number">2</span> <span class="keyword">and</span> n_genes_father == <span class="number">0</span>):</span><br><span class="line">                    p_gene = (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * PROBS[<span class="string">&quot;mutation&quot;</span>] + PROBS[<span class="string">&quot;mutation&quot;</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>])</span><br><span class="line">                <span class="keyword">elif</span> (n_genes_mother == <span class="number">1</span> <span class="keyword">and</span> n_genes_father == <span class="number">2</span>) <span class="keyword">or</span> (n_genes_mother == <span class="number">2</span> <span class="keyword">and</span> n_genes_father == <span class="number">1</span>):</span><br><span class="line">                    p_gene = <span class="number">0.5</span> * PROBS[<span class="string">&quot;mutation&quot;</span>] + <span class="number">0.5</span> * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>])</span><br><span class="line">                <span class="keyword">elif</span> n_genes_mother == <span class="number">2</span> <span class="keyword">and</span> n_genes_father == <span class="number">2</span>:</span><br><span class="line">                    p_gene = PROBS[<span class="string">&quot;mutation&quot;</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) + (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * PROBS[<span class="string">&quot;mutation&quot;</span>]</span><br><span class="line">            <span class="keyword">elif</span> genes == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> n_genes_mother == <span class="number">0</span> <span class="keyword">and</span> n_genes_father == <span class="number">0</span>:</span><br><span class="line">                    p_gene = PROBS[<span class="string">&quot;mutation&quot;</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>]</span><br><span class="line">                <span class="keyword">elif</span> (n_genes_mother == <span class="number">0</span> <span class="keyword">and</span> n_genes_father == <span class="number">1</span>) <span class="keyword">or</span> (n_genes_mother == <span class="number">1</span> <span class="keyword">and</span> n_genes_father == <span class="number">0</span>):</span><br><span class="line">                    p_gene = <span class="number">0.5</span> * PROBS[<span class="string">&quot;mutation&quot;</span>]</span><br><span class="line">                <span class="keyword">elif</span> n_genes_mother == <span class="number">1</span> <span class="keyword">and</span> n_genes_father == <span class="number">1</span>:</span><br><span class="line">                    p_gene = <span class="number">0.5</span> * <span class="number">0.5</span></span><br><span class="line">                <span class="keyword">elif</span> (n_genes_mother == <span class="number">0</span> <span class="keyword">and</span> n_genes_father == <span class="number">2</span>) <span class="keyword">or</span> (n_genes_mother == <span class="number">2</span> <span class="keyword">and</span> n_genes_father == <span class="number">0</span>):</span><br><span class="line">                    p_gene = PROBS[<span class="string">&quot;mutation&quot;</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>])</span><br><span class="line">                <span class="keyword">elif</span> (n_genes_mother == <span class="number">1</span> <span class="keyword">and</span> n_genes_father == <span class="number">2</span>) <span class="keyword">or</span> (n_genes_mother == <span class="number">2</span> <span class="keyword">and</span> n_genes_father == <span class="number">1</span>):</span><br><span class="line">                    p_gene = <span class="number">0.5</span> * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>])</span><br><span class="line">                <span class="keyword">elif</span> n_genes_mother == <span class="number">2</span> <span class="keyword">and</span> n_genes_father == <span class="number">2</span>:</span><br><span class="line">                    p_gene = (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>])</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get probability of trait</span></span><br><span class="line">        p_trait = PROBS[<span class="string">&quot;trait&quot;</span>][genes][trait]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Update joint probability</span></span><br><span class="line">        p *= p_gene * p_trait</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><p>在任一情况下，one_gene 包含所有只携带一个基因的人，two_genes 则包含所有只携带两个基因的人, have_trait 包含所有有症状显示的人。</p><p>通过遍历所有人，计算他们满足该情况的概率后累乘，即为这种情况出现的概率。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>感觉这种方法好麻烦，而且我算那段基因概率的时候头好大，感觉好不确定，还是用递归来做吧，应该会简单。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Uncertainty篇（三），用递归解遗传问题</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A009/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A009/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇说了要给大家用递归来解，昨天的那个算法太诡异了，接下来我们来讲一下，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>我这次用的是节点，如下，基本就是把表格信息都存下来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, father=<span class="literal">None</span>, mother=<span class="literal">None</span>, trait=<span class="literal">None</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.father = father</span><br><span class="line">        self.mother = mother</span><br><span class="line">        self.trait = trait</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># name,mother,father,trait</span></span><br><span class="line"><span class="comment"># Harry,Lily,James,</span></span><br><span class="line"><span class="comment"># James,,,1</span></span><br><span class="line"><span class="comment"># Lily,,,0</span></span><br><span class="line">james = Node(<span class="string">&quot;James&quot;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">True</span>)</span><br><span class="line">lily = Node(<span class="string">&quot;Lily&quot;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">False</span>)</span><br><span class="line">harry = Node(<span class="string">&quot;Harry&quot;</span>, james, lily, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>来看最重要的算法吧，主要是把人分成了三种先。</p><ol><li>第一类人是一点信息都没有的，那就是人群中的随机一人。</li><li>第二类人是只有是否患病的信息，这与上面一类人的概率略有不同，具体可以看代码。</li><li>第三类人是有父母的，那就递归开算。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_genes_possibility</span>(<span class="params">self</span>):</span><br><span class="line">    ren = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> self.father <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> self.mother <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> self.trait == <span class="literal">None</span>:</span><br><span class="line">            ren = PROBS[<span class="string">&quot;gene&quot;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            genes_0_possibility = PROBS[<span class="string">&quot;trait&quot;</span>][<span class="number">0</span>][self.trait] * PROBS[<span class="string">&quot;gene&quot;</span>][<span class="number">0</span>]</span><br><span class="line">            genes_1_posibility = PROBS[<span class="string">&quot;trait&quot;</span>][<span class="number">1</span>][self.trait] * PROBS[<span class="string">&quot;gene&quot;</span>][<span class="number">1</span>]</span><br><span class="line">            genes_2_possibility = PROBS[<span class="string">&quot;trait&quot;</span>][<span class="number">2</span>][self.trait] * PROBS[<span class="string">&quot;gene&quot;</span>][<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">            ren = &#123;</span><br><span class="line">                <span class="number">0</span>: genes_0_possibility / (genes_0_possibility + genes_1_posibility + genes_2_possibility),</span><br><span class="line">                <span class="number">1</span>: genes_1_posibility / (genes_0_possibility + genes_1_posibility + genes_2_possibility),</span><br><span class="line">                <span class="number">2</span>: genes_2_possibility / (genes_0_possibility + genes_1_posibility + genes_2_possibility),</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        father_genes_possibility = self.father.get_genes_possibility()</span><br><span class="line">        mother_genes_possibility = self.mother.get_genes_possibility()</span><br><span class="line"></span><br><span class="line">        genes_2_possibility = father_genes_possibility[<span class="number">2</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * mother_genes_possibility[<span class="number">2</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>])</span><br><span class="line">        genes_2_possibility += father_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span> * mother_genes_possibility[<span class="number">2</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * <span class="number">2</span></span><br><span class="line">        genes_2_possibility += father_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span> * mother_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span></span><br><span class="line">        genes_2_possibility += father_genes_possibility[<span class="number">0</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>] * mother_genes_possibility[<span class="number">2</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * <span class="number">2</span></span><br><span class="line">        genes_2_possibility += father_genes_possibility[<span class="number">0</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>] * mother_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span> * <span class="number">2</span></span><br><span class="line">        genes_2_possibility += father_genes_possibility[<span class="number">0</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>] * mother_genes_possibility[<span class="number">0</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>]</span><br><span class="line"></span><br><span class="line">        genes_1_possibility = father_genes_possibility[<span class="number">2</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * mother_genes_possibility[<span class="number">2</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>] * <span class="number">2</span></span><br><span class="line">        genes_1_possibility += father_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span> * mother_genes_possibility[<span class="number">2</span>] * <span class="number">2</span></span><br><span class="line">        genes_1_possibility += father_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span> * mother_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span></span><br><span class="line">        genes_1_possibility += father_genes_possibility[<span class="number">0</span>] * mother_genes_possibility[<span class="number">2</span>] * <span class="number">2</span></span><br><span class="line">        genes_1_possibility += father_genes_possibility[<span class="number">0</span>] * mother_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span> * <span class="number">2</span></span><br><span class="line">        genes_1_possibility += father_genes_possibility[<span class="number">0</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>] * mother_genes_possibility[<span class="number">0</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        genes_0_possibility = father_genes_possibility[<span class="number">2</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>] * mother_genes_possibility[<span class="number">2</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>]</span><br><span class="line">        genes_0_possibility += father_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span> * mother_genes_possibility[<span class="number">2</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>] * <span class="number">2</span></span><br><span class="line">        genes_0_possibility += father_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span> * mother_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span></span><br><span class="line">        genes_0_possibility += father_genes_possibility[<span class="number">0</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * mother_genes_possibility[<span class="number">2</span>] * PROBS[<span class="string">&quot;mutation&quot;</span>] * <span class="number">2</span></span><br><span class="line">        genes_0_possibility += father_genes_possibility[<span class="number">0</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * mother_genes_possibility[<span class="number">1</span>] * <span class="number">0.5</span> * <span class="number">2</span></span><br><span class="line">        genes_0_possibility += father_genes_possibility[<span class="number">0</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>]) * mother_genes_possibility[<span class="number">0</span>] * (<span class="number">1</span> - PROBS[<span class="string">&quot;mutation&quot;</span>])</span><br><span class="line"></span><br><span class="line">        ren = &#123;</span><br><span class="line">            <span class="number">0</span>: genes_0_possibility / (genes_0_possibility + genes_1_possibility + genes_2_possibility),</span><br><span class="line">            <span class="number">1</span>: genes_1_possibility / (genes_0_possibility + genes_1_possibility + genes_2_possibility),</span><br><span class="line">            <span class="number">2</span>: genes_2_possibility / (genes_0_possibility + genes_1_possibility + genes_2_possibility),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(self.name) + <span class="string">&quot; genes possibility: &quot;</span> + <span class="built_in">str</span>(ren))</span><br><span class="line">    <span class="keyword">return</span> ren</span><br></pre></td></tr></table></figure><p>是不是比昨天的算法看起来清晰多了。</p><p>但是我的这个概率好像还是有点问题，就中间那一大块，我感觉有突变的算起来头太大了，我觉得我得先去看看遗传学相关的资料才能算对。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Uncertainty篇（四），让AI写福尔摩斯故事</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A010/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A010/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天玩太爽了，忘记要写，赶紧来补一篇。</p><p>今天给大家搞个好玩的，来让 AI 生成福尔摩斯小说，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h1><p>首先要生成马尔可夫链，n_gram&#x3D;2 来划分所有词（这边是两两一组），然后计算文本中从一组词转移到另一组词的概率，<strong>也就是说这样的转移在所有文本中出现的概率</strong>，如下图。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/23.jpeg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_markov_model</span>(<span class="params">cleaned_stories, n_gram=<span class="number">2</span></span>):</span><br><span class="line">    markov_model = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cleaned_stories)-n_gram-<span class="number">1</span>):</span><br><span class="line">        curr_state, next_state = <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n_gram):</span><br><span class="line">            curr_state += cleaned_stories[i+j] + <span class="string">&quot; &quot;</span></span><br><span class="line">            next_state += cleaned_stories[i+j+n_gram] + <span class="string">&quot; &quot;</span></span><br><span class="line">        curr_state = curr_state[:-<span class="number">1</span>]</span><br><span class="line">        next_state = next_state[:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> curr_state <span class="keyword">not</span> <span class="keyword">in</span> markov_model:</span><br><span class="line">            markov_model[curr_state] = &#123;&#125;</span><br><span class="line">            markov_model[curr_state][next_state] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> next_state <span class="keyword">in</span> markov_model[curr_state]:</span><br><span class="line">                markov_model[curr_state][next_state] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                markov_model[curr_state][next_state] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># calculating transition probabilities</span></span><br><span class="line">    <span class="keyword">for</span> curr_state, transition <span class="keyword">in</span> markov_model.items():</span><br><span class="line">        total = <span class="built_in">sum</span>(transition.values())</span><br><span class="line">        <span class="keyword">for</span> state, count <span class="keyword">in</span> transition.items():</span><br><span class="line">            markov_model[curr_state][state] = count/total</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> markov_model</span><br></pre></td></tr></table></figure><p>然后是根据马尔可夫链生成故事，这就和之前 PageRank 一样随机转移就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_story</span>(<span class="params">markov_model, limit=<span class="number">100</span>, start=<span class="string">&#x27;my god&#x27;</span></span>):</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    curr_state = start</span><br><span class="line">    next_state = <span class="literal">None</span></span><br><span class="line">    story = <span class="string">&quot;&quot;</span></span><br><span class="line">    story+=curr_state+<span class="string">&quot; &quot;</span></span><br><span class="line">    <span class="keyword">while</span> n&lt;limit:</span><br><span class="line">        next_state = random.choices(<span class="built_in">list</span>(markov_model[curr_state].keys()),</span><br><span class="line">                                    <span class="built_in">list</span>(markov_model[curr_state].values()))</span><br><span class="line">        </span><br><span class="line">        curr_state = next_state[<span class="number">0</span>]</span><br><span class="line">        story+=curr_state+<span class="string">&quot; &quot;</span></span><br><span class="line">        n+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> story</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i)+<span class="string">&quot;. &quot;</span>, generate_story(markov_model, start=<span class="string">&quot;dear holmes&quot;</span>, limit=<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i)+<span class="string">&quot;. &quot;</span>, generate_story(markov_model, start=<span class="string">&quot;my dear&quot;</span>, limit=<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i)+<span class="string">&quot;. &quot;</span>, generate_story(markov_model, start=<span class="string">&quot;i would&quot;</span>, limit=<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(generate_story(markov_model, start=<span class="string">&quot;the case&quot;</span>, limit=<span class="number">100</span>))</span><br></pre></td></tr></table></figure><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="状态转移概率"><a href="#状态转移概率" class="headerlink" title="状态转移概率"></a>状态转移概率</h2><p>给大家看一下 <strong>the game</strong> 后面下一组词的概率，每组词都有这样一个表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">All possible transitions from &#x27;the game&#x27; state: </span><br><span class="line"></span><br><span class="line">&#123;&#x27;is hardly&#x27;: 0.02702702702702703, &#x27;worth it&#x27;: 0.02702702702702703, &#x27;you are&#x27;: 0.02702702702702703, &#x27;i am&#x27;: 0.02702702702702703, &#x27;is up&#x27;: 0.06306306306306306, &#x27;now count&#x27;: 0.02702702702702703, &#x27;your letter&#x27;: 0.02702702702702703, &#x27;for all&#x27;: 0.06306306306306306, &#x27;is afoot&#x27;: 0.036036036036036036, &#x27;my own&#x27;: 0.02702702702702703, &#x27;at any&#x27;: 0.02702702702702703, &#x27;mr holmes&#x27;: 0.02702702702702703, &#x27;ay whats&#x27;: 0.02702702702702703, &#x27;my friend&#x27;: 0.02702702702702703, &#x27;fairly by&#x27;: 0.02702702702702703, &#x27;is not&#x27;: 0.02702702702702703, &#x27;was not&#x27;: 0.02702702702702703, &#x27;is and&#x27;: 0.036036036036036036, &#x27;was whist&#x27;: 0.036036036036036036, &#x27;for the&#x27;: 0.036036036036036036, &#x27;was in&#x27;: 0.02702702702702703, &#x27;may wander&#x27;: 0.02702702702702703, &#x27;now a&#x27;: 0.02702702702702703, &#x27;was up&#x27;: 0.09009009009009009, &#x27;would have&#x27;: 0.036036036036036036, &#x27;in their&#x27;: 0.036036036036036036, &#x27;in that&#x27;: 0.036036036036036036, &#x27;the lack&#x27;: 0.036036036036036036, &#x27;was afoot&#x27;: 0.036036036036036036&#125;</span><br></pre></td></tr></table></figure><h2 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h2><p>给大家看一下用 <strong>the case</strong> 开头然后限制100组词（也就是两百个词）的故事。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the case was concerned with an explosive energy which told me that i was at such a sight as that the cipher macdonald sat with his hands in a paroxysm of energy and he stretched his legs as he raced past and her refusal to take her there are few in that chair i can see terror in the coal district in the bare assembly room the men he is armed with a pair precisely but this is certainly a most extraordinary fashion a letter arrived on march his death in the same way i thought of my presence then with a head that was even greater than the obtrusive emotion of the clergyman he sat for some little time no said i only meant sir that sir charles was the elder man first the younger brother and i said i could rely upon my assistance in the enclosed official report it was quite against my wishes twice my boy jack baby dolores and mrs mason to bring news of the outside briarbrae just after sunset well i think we will walk down together to our left or to a small blue book which ascends to such rarefied heights of all the</span><br></pre></td></tr></table></figure><p>看看翻译后的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个案子与一种爆炸能量有关，它告诉我，我当时正处于这样一个景象中，即密码麦克唐纳双手坐在一阵能量中，当他飞驰而过时，他伸展双腿，而她拒绝带她，那把椅子上的人很少，我能看到恐怖，在煤炭区，在光秃秃的集会室里，他正拿着一对但这无疑是一种最不寻常的方式：一封信在三月到达，他的去世方式与我想到我的存在的方式相同，然后他的脑袋甚至比牧师的突兀情绪还要大，他坐了一小会儿，没有说，我只是说先生，查尔兹爵士首先是年长的弟弟，我说我可以依靠我在封闭官员中的帮助报告说，我的儿子杰克、宝贝、多洛雷斯和梅森夫人两次在日落后带来外面的布赖尔布雷的消息，这完全违背了我的意愿，我想我们会一起走到我们的左边，或者走到一本上升到如此罕见的蓝色小书前。</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>最后就让我们来探讨探讨这样的文章与咱们让 ChatGPT 写出来的有什么不同。</p><ol><li>首先很明显的第一点就是，这篇文章语法问题太多了。</li><li>然后是有点不明所以，感觉就是在乱说，缺少了故事核心。</li></ol><p>其实说白了就是少了对语言的理解能力，但是具体的还是等我们到最后一趴讲 Language 的时候再说吧。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Optimization篇（一），让AI解填字游戏</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A011/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A011/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>又忘写了，赶紧来补，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h1><p>虽然一般都会把优化问题分成下图三类，但是其实如果大家仔细思考一下，就会发现。</p><p>优化从本质上来说也是一种 Search，在限制下寻找可行解或者更优解。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/27.jpeg"></p><h2 id="Local-Search"><a href="#Local-Search" class="headerlink" title="Local Search"></a>Local Search</h2><p>OK，先给大家举个例子。</p><p>比如说，我们要从下图中找出最高的柱子，但是我们只知道我们目前的柱子和相邻的柱子。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/29.png"></p><p>那解这个问题最简单的方法就是比一比相邻的柱子，那边高就往那边爬，那如果都比现在低，那就不走了。</p><p>但是这样的话就很容易陷入局部最优解了，那具体如何解决，我们先按下不表，最后再来讲。</p><h2 id="Linear-Programming"><a href="#Linear-Programming" class="headerlink" title="Linear Programming"></a>Linear Programming</h2><p>线性规划相信大家肯定不陌生，都是初中的知识了。</p><p>一般线性规划都会分成两部分。</p><ol><li><p>目标函数（花费函数），也就是要优化的东西。</p></li><li><p>限制，一般都会有好几条。</p><p> 当然了，目标函数其实也可以有好几个，但是我们都会将它转换成一个。</p></li></ol><p>那大家应该发现了相比局部搜索，线性规划中我们的视角是全局的。</p><h2 id="Constraint-Satisfaction"><a href="#Constraint-Satisfaction" class="headerlink" title="Constraint Satisfaction"></a>Constraint Satisfaction</h2><p>那这听名字就知道这种问题是找可行解，同样也给大家举个例子。</p><p>就下面这个问题，每个圈代表一场考试，旁边的集合就是考试可以被安排的日期，限制条件是相连的节点日期不能相同，问怎么排。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/30.png"></p><p>这题目看着挺简单的吧，回溯算法秒解，跟八个皇后问题一样。</p><p>那如果更进一步，要求周一的考试尽可能的少呢？</p><p>其实还是一样，只要优先填周二和周三就好了。</p><p>那如果不算完整，而是只算一个可行解，会陷入局部最优解吗？</p><p>那必然是会的，所有的优化问题都有可能陷入局部最优，所以我们最后来讲讲怎么解决。</p><h2 id="智能算法"><a href="#智能算法" class="headerlink" title="智能算法"></a>智能算法</h2><p>一般我们说智能算法之所以智能是因为它可以逃离局部最优解，有更大的概率进入全局最优解，说白了就是不贪心。</p><p>但是本质上智能算法就是比普通算法多了下面这两样。</p><ol><li>保留解并继续探索。</li><li>多个初始状态同时寻找解。</li></ol><p>比如常见的退火算法就是保留解，蒙特卡洛模拟和蚁群算法就是多个初始状态。</p><p>当然具体算法后续的优化那就各不相同了。</p><ul><li>比如退火算法前期更大概率往小的走，后期则趋于平静。</li><li>蒙特卡洛模拟则是大范围随机初始状态。</li><li>而蚁群算法我记得好像是有个踪迹，就像蚂蚁走路会留下信号，吸引别的蚂蚁。</li></ul><p>OK，那除此之外，其实还有很多优化方法，比如说可以先舍弃一些限制寻找，然后再加上，不过这些都要具体问题具体分析了。</p><h1 id="填字游戏"><a href="#填字游戏" class="headerlink" title="填字游戏"></a>填字游戏</h1><p>这游戏相信大家肯定都不陌生，小时候都在杂志或者报纸上玩过。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/31.png"></p><pre><code>不过这里填的词不是根据要回答的问题来的，而是从一堆词里选。</code></pre><p>给大家举个例子，想想怎么来解，假设有下面这样的谜题。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/32.png"></p><p>要求从 {one, two, three, four, five, six, seven, eight, nine, ten} 中选词。</p><ol><li>首先我们可以将词表中不符合要求的词剔除（长度不对），然后再按照长度分成子集，{one, two, six, ten}，{three, seven, eight}，{four, five, nine}。</li><li>然后从可选词最少的空开始填，这里我们就会先填 three。</li><li>填完之后填和它有相同字母的空，这里会填 one，但是字母对不上，所以继续往下找到 two，另一边的话就会发现找不到，就会回溯，将 three 改成 seven。</li><li>然后重复第三步，直至全部填完或者遍历所有可能。</li></ol><p>那最后我们就会有如下解。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/33.png"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实即使是智能算法也会陷入局部最优，这是很正常的事情了，所以才会有数学建模，需要大家去针对性的改进智能算法。</p><p>那用 AI 呢？或者更确切的说用 Machine Learning 呢，也就是用数据集来优化。</p><p>怎么说呢，也许结果会更好，也许会更差，这取决于你的数据集和模型。</p><p>不过我们还有更进一步的强化学习，对抗式人工智能，这也许才能大大提高模型寻找最优解的可能性（但也不是所有问题都可以）。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning篇（一），用机器学习做分类任务</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A012/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A012/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不多说了，今天争取写两篇，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h1><p>先来讲讲监督学习。</p><p>监督学习最大的特点就是有数据标签，会有人告诉 AI 那个东西是什么，这样的话准确性肯定会高一些。</p><p>最常见的应用的话就是 Classification（分类），我们也来试一下，基本就是一通百通。</p><h1 id="预测用户是否购买"><a href="#预测用户是否购买" class="headerlink" title="预测用户是否购买"></a>预测用户是否购买</h1><p>在这个例子中我们将根据给出的数据来预测用户在网上购物时是否会购买商品，从而判断是否给它推广告。</p><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p>先来看看主函数。</p><ol><li>首先需要加载数据，并分成训练集和预测集。</li><li>然后的话就开始训练模型。</li><li>再让模型去预测集上跑一遍输出预测结果。</li><li>最后来算一算模型的 Sensitivity（真阳率）和 Specificity（真阴率）。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load data from spreadsheet and split into train and test sets</span></span><br><span class="line">    evidence, labels = load_data(<span class="string">&quot;./shopping/shopping.csv&quot;</span>)</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">        evidence, labels, test_size=TEST_SIZE <span class="comment"># TEST_SIZE = 0.4</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Train model and make predictions</span></span><br><span class="line">    model = train_model(X_train, y_train)</span><br><span class="line">    predictions = model.predict(X_test)</span><br><span class="line">    sensitivity, specificity = evaluate(y_test, predictions)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Correct: <span class="subst">&#123;(y_test == predictions).<span class="built_in">sum</span>()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Incorrect: <span class="subst">&#123;(y_test != predictions).<span class="built_in">sum</span>()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;True Positive Rate: <span class="subst">&#123;<span class="number">100</span> * sensitivity:<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;True Negative Rate: <span class="subst">&#123;<span class="number">100</span> * specificity:<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h2><p>数据类型还挺多的，正好给大家看看 Python 怎么加载 csv。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> csvfile:</span><br><span class="line">        reader = csv.DictReader(csvfile)</span><br><span class="line">        </span><br><span class="line">        evidence = []</span><br><span class="line">        labels = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">            evidence.append([</span><br><span class="line">                <span class="built_in">int</span>(row[<span class="string">&quot;Administrative&quot;</span>]),</span><br><span class="line">                <span class="built_in">float</span>(row[<span class="string">&quot;Administrative_Duration&quot;</span>]),</span><br><span class="line">                <span class="built_in">int</span>(row[<span class="string">&quot;Informational&quot;</span>]),</span><br><span class="line">                <span class="built_in">float</span>(row[<span class="string">&quot;Informational_Duration&quot;</span>]),</span><br><span class="line">                <span class="built_in">int</span>(row[<span class="string">&quot;ProductRelated&quot;</span>]),</span><br><span class="line">                <span class="built_in">float</span>(row[<span class="string">&quot;ProductRelated_Duration&quot;</span>]),</span><br><span class="line">                <span class="built_in">float</span>(row[<span class="string">&quot;BounceRates&quot;</span>]),</span><br><span class="line">                <span class="built_in">float</span>(row[<span class="string">&quot;ExitRates&quot;</span>]),</span><br><span class="line">                <span class="built_in">float</span>(row[<span class="string">&quot;PageValues&quot;</span>]),</span><br><span class="line">                <span class="built_in">float</span>(row[<span class="string">&quot;SpecialDay&quot;</span>]),</span><br><span class="line">                <span class="built_in">int</span>(datetime.strptime(row[<span class="string">&quot;Month&quot;</span>], <span class="string">&#x27;%b&#x27;</span>).month - <span class="number">1</span>) <span class="keyword">if</span> row[<span class="string">&quot;Month&quot;</span>] != <span class="string">&quot;June&quot;</span> <span class="keyword">else</span> <span class="number">5</span>,</span><br><span class="line">                <span class="built_in">int</span>(row[<span class="string">&quot;OperatingSystems&quot;</span>]),</span><br><span class="line">                <span class="built_in">int</span>(row[<span class="string">&quot;Browser&quot;</span>]),</span><br><span class="line">                <span class="built_in">int</span>(row[<span class="string">&quot;Region&quot;</span>]),</span><br><span class="line">                <span class="built_in">int</span>(row[<span class="string">&quot;TrafficType&quot;</span>]),</span><br><span class="line">                <span class="number">0</span> <span class="keyword">if</span> row[<span class="string">&quot;VisitorType&quot;</span>] == <span class="string">&quot;New_Visitor&quot;</span> <span class="keyword">else</span> <span class="number">1</span>,</span><br><span class="line">                <span class="number">0</span> <span class="keyword">if</span> row[<span class="string">&quot;Weekend&quot;</span>] == <span class="string">&quot;FALSE&quot;</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            ])</span><br><span class="line">            </span><br><span class="line">            labels.append(<span class="number">1</span> <span class="keyword">if</span> row[<span class="string">&quot;Revenue&quot;</span>] == <span class="string">&quot;TRUE&quot;</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> evidence, labels</span><br></pre></td></tr></table></figure><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>我这里写的很简单，基本都用的默认参数，给大家稍微讲一下。</p><p>首先是这个K近邻算法，就是对于每一个待分类的样本，找到离它最近的 n_neighbors 个邻居，它们的众数就是算法的预测结果。</p><p>这里默认的距离计算方式是欧拉距离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">evidence, labels</span>):</span><br><span class="line">    model = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line">    model.fit(evidence, labels)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h2 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h2><p>最后就是评估模型了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">labels, predictions</span>):</span><br><span class="line">    sensitivity = <span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels)) <span class="keyword">if</span> labels[i] == <span class="number">1</span> <span class="keyword">and</span> predictions[i] == <span class="number">1</span>]) / <span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">for</span> label <span class="keyword">in</span> labels <span class="keyword">if</span> label == <span class="number">1</span>])</span><br><span class="line">    specificity = <span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels)) <span class="keyword">if</span> labels[i] == <span class="number">0</span> <span class="keyword">and</span> predictions[i] == <span class="number">0</span>]) / <span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">for</span> label <span class="keyword">in</span> labels <span class="keyword">if</span> label == <span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sensitivity, specificity</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>给大家看看结果，咋一看貌似还行，毕竟真阴率有90%，但其实很垃圾，因为真阳率才是重要的。</p><p>真阳率低代表了客人想买但是模型觉得他们不买，那不完蛋了吗，销售额还要不要了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Correct: 4072</span><br><span class="line">Incorrect: 860</span><br><span class="line">True Positive Rate: 39.50%</span><br><span class="line">True Negative Rate: 90.84%</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h3><p>这一步基本是必要的，毕竟是要算距离，不标准化数据的话，结果就会被一些特征过度影响，导致都偏向一边，就像现在偏向给出 False 一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scaler = StandardScaler()</span><br><span class="line">X_train = scaler.fit_transform(X_train)</span><br><span class="line">X_test = scaler.transform(X_test)</span><br></pre></td></tr></table></figure><p>给大家再看看结果，是不是正确率还是有明显的提升的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Correct: 4153</span><br><span class="line">Incorrect: 779</span><br><span class="line">True Positive Rate: 44.03%</span><br><span class="line">True Negative Rate: 91.93%</span><br></pre></td></tr></table></figure><h3 id="筛选特征"><a href="#筛选特征" class="headerlink" title="筛选特征"></a>筛选特征</h3><p>那我们还可以剔除一些不必要的特征来减少噪声，这里我尝试选了10个最重要的特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selector = SelectKBest(score_func=f_classif, k=<span class="number">10</span>)</span><br><span class="line">X_train_selected = selector.fit_transform(X_train, y_train)</span><br><span class="line">X_test_selected = selector.transform(X_test)</span><br></pre></td></tr></table></figure><p>结果看上去又好了一些。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Correct: 4197</span><br><span class="line">Incorrect: 735</span><br><span class="line">True Positive Rate: 51.07%</span><br><span class="line">True Negative Rate: 91.64%</span><br></pre></td></tr></table></figure><h3 id="近邻数量"><a href="#近邻数量" class="headerlink" title="近邻数量"></a>近邻数量</h3><p>那我这边又试着改了一下 n_neighbors，毕竟 n_neighbors&#x3D;1 就代表最近的是啥我们就预测为啥，这肯定不行啊，所以我改成了5。</p><p>可以看到结果上真阳率略有降低，真阴率倒是提高了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Correct: 4329</span><br><span class="line">Incorrect: 603</span><br><span class="line">True Positive Rate: 48.43%</span><br><span class="line">True Negative Rate: 95.33%</span><br></pre></td></tr></table></figure><p>这说明什么？说明标签为 False 的数据很分散，所以我们可以再减少选取的特征，或者可以进行<strong>特征组合</strong>。</p><p>这边我尝试将特征减到了6个，基本已经不能再减了，结果比之前好了很多，说明原始数据噪声太多了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Correct: 4362</span><br><span class="line">Incorrect: 570</span><br><span class="line">True Positive Rate: 53.08%</span><br><span class="line">True Negative Rate: 95.24%</span><br></pre></td></tr></table></figure><h3 id="近邻权重"><a href="#近邻权重" class="headerlink" title="近邻权重"></a>近邻权重</h3><p>OK，最后我又试着调整了一下近邻权重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义权重函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_weight</span>(<span class="params">distances</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自定义权重函数，这里简单地将距离的倒数作为权重</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / distances</span><br><span class="line"></span><br><span class="line">model = KNeighborsClassifier(n_neighbors=<span class="number">5</span>, metric=<span class="string">&quot;euclidean&quot;</span>, weights=custom_weight)</span><br></pre></td></tr></table></figure><p>结果也基本大差不差。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Correct: 4326</span><br><span class="line">Incorrect: 606</span><br><span class="line">True Positive Rate: 53.33%</span><br><span class="line">True Negative Rate: 94.32%</span><br></pre></td></tr></table></figure><h3 id="修改模型"><a href="#修改模型" class="headerlink" title="修改模型"></a>修改模型</h3><p>这边又试着换成了决策树模型，基本也差不多，就不给看结果了，大家可以自己试试，然后改改参数说不定会更好。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>当然除了上面这些我们还有很多事情可以做，比如剔除离群值，修改评估函数，但这都是数据挖掘的知识了，大家可以自行了解。</p><h1 id="Semi-supervised-Learning"><a href="#Semi-supervised-Learning" class="headerlink" title="Semi-supervised Learning"></a>Semi-supervised Learning</h1><p>最后来提一嘴半监督学习，这主要是因为标注成本太高了，麻烦还不一定准，不如干脆让 AI 自己学。</p><p>具体的方法有自训练法，协同训练法，这些都以后再讲了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>那这样的话机器学习的分类也讲完了，下一篇就是强化学习了，今天争取赶出来。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Neural Networks篇（一），理解模型的结构并实战</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A014/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A014/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇说这篇要完善狼人杀的代码来着，后来感觉干脆等 Language 篇讲完再做会比较好一些。</p><p>所以今天就继续来讲神经网络，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h1><h2 id="一维输入"><a href="#一维输入" class="headerlink" title="一维输入"></a>一维输入</h2><p>神经网络在我眼里其实本质是<strong>泰勒展开</strong>，即<strong>所有连续函数</strong>都可以用一长串多项式来表示。</p><p>那至于不连续函数就需要请出<strong>激活函数</strong>了，通过激活函数我们可以做到截断一些函数再组合，从而实现特殊的图案。</p><p>给大家看个好玩的，如下图，我们现在要搭建一个模型来完成这个分类任务。</p><p>那目前我们只有输入层和输出层，也就是机器学习，很明显它没有办法把中间的蓝色包裹起来，只能划出一条斜线。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/37.png"></p><p>现在我们试着加入一层隐藏层，也就是中间层，可以看到当中间层有三个节点时，它就已经能完成分类任务了。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/38.png"></p><p>这三个节点的输出分别是三条线，如下。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/39.png"></p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/40.png"></p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/41.png"></p><p>这就是我上面所说的通过激活函数配合多项式来实现一些特殊图案，至此我们就理解了为什么 AI 能处理所有的一位数据，接下来我们来看看多维数据。</p><h2 id="多维输入"><a href="#多维输入" class="headerlink" title="多维输入"></a>多维输入</h2><p>多维数据中首当其冲的就是图像了，那我们该如何让 AI 处理这二维数据呢，或者说我们该如何讲二维数据转换成一维数据呢？</p><p>其实很简单，我们只要把二维图像展开不就好了。</p><p>但是这有个问题就是二维图像，很多数据是冗余的，比如我们要识别物体，我们根本就不需要它的颜色数据，因此我们需要卷积层以及池化层。</p><p>通过卷积层我们可以让下面第一张图转换成第二张，是不是很神奇，我们竟然将图像的边缘信息提取了出来。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/42.png"></p><p>紧接着通过池化层，我们可以压缩图像一倍的信息，再重复这两步，我们就可以将图像的像素点压缩到可接受范围内，从而展平为一维数据进行处理，如下图。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/44.png"></p><p>二维既然有二维卷积，那三维也会有三维卷积了，所以更高维我就不介绍了，而且也一般见不到，因为一般再往上就是时间维度了。</p><h2 id="序列输入"><a href="#序列输入" class="headerlink" title="序列输入"></a>序列输入</h2><p>带时间维度的数据我们都会称呼其为序列数据，这也意味着会有完全不同的处理方式，如下图。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/45.png"></p><p>再给大家看一看之前的模型长什么样。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/46.png"></p><p>可以看到多了很多的 Input 和 Network。</p><p>这一列 Input 就代表了按照时间顺序依次输入的信息，而其对应的 Network 则每次从之前的 Network 中收集信息并学习新的信息，最后由最后一个 Network 输出完整的信息。</p><p>那其实还有一种序列数据就是语言，语言中的每一句话都是相连的。</p><p>其实说白了，什么是序列数据，有<strong>上下文</strong>的就是。</p><h2 id="序列输出"><a href="#序列输出" class="headerlink" title="序列输出"></a>序列输出</h2><p>OK，来看看最后一种模型，就是它的输出是语言，或者直白点它的输出有上下文。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/47.png"></p><p>这应该很好理解吧，就不多赘述了。</p><h1 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h1><p>讲完了模型结构来看看模型怎么训练的。</p><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>因为我们需要根据结果来调整我们的模型，才能让模型变得更好，反向传播变应运而生了。</p><p>要想做到反向传播首先需要损失函数来判断预测的结果和真实结果的差距，然后再通过梯度下降计算各个节点的权重应该如何变化，那具体是怎么实现的呢？</p><p>首先的话，需要先计算出损失函数，那对于任何结果，我们可以计算出损失值如下。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/48.png"></p><p>其中左边那一列数据是当权重取到特定值得结果，如果不取特定值，而是将其转换成节点的公式（如下），我们就可以推出复杂的公式。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/49.png"></p><p>然后求每个权重的偏导数，我们就可以知道它的调整方向，具体步长，一般是初始就设定的，或者像退火算法一样越来越短。</p><p>但是如果每算一个结果就调整一次，不仅麻烦，而且结果也可能过拟合，所以我们可以把数据集分成好几个 batch，每个batch更新一次，如下。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/50.png"></p><h2 id="Dropout层"><a href="#Dropout层" class="headerlink" title="Dropout层"></a>Dropout层</h2><p>这就类似于深度搜索里的剪枝操作，每次计算时，丢掉一些神经元，防止模型过拟合，提高泛化能力。</p><h1 id="交通信号灯分类"><a href="#交通信号灯分类" class="headerlink" title="交通信号灯分类"></a>交通信号灯分类</h1><p>数据集的话在这 <a href="https://cdn.cs50.net/ai/2023/x/projects/5/gtsrb.zip%EF%BC%8C%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E4%B8%BB%E8%A6%81%E6%9D%A5%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%85%B6%E4%BB%96%E4%B8%9C%E8%A5%BF%E9%83%BD%E8%B7%9F%E4%B8%8A%E4%B8%80%E7%AF%87%E5%B7%AE%E4%B8%8D%E5%A4%9A%E3%80%82">https://cdn.cs50.net/ai/2023/x/projects/5/gtsrb.zip，然后我们主要来讲一下模型，其他东西都跟上一篇差不多。</a></p><p>卷积层就是用来提取特征的，因为你权重的初始时随机的，也就是说它们的梯度下降方向也是不同的，所以在计算时就很容易出现不同的特征，这边就在第一层提取出32种特征。</p><p>池化层就是用来压缩的，毕竟都提取出32种特征了，图像还要这么大干嘛，变小一些，专注于局部特征就好。</p><p>最后是全连接层，这里就相当于将所有局部特征组合成128个大特征，然后再组合成43种信号。</p><p>大家先看看流程图再看代码。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/51.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_model</span>():</span><br><span class="line">    model = tf.keras.models.Sequential([</span><br><span class="line">        tf.keras.layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(IMG_WIDTH, IMG_HEIGHT, <span class="number">3</span>)),</span><br><span class="line">        tf.keras.layers.MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)),</span><br><span class="line">        tf.keras.layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        tf.keras.layers.MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)),</span><br><span class="line">        tf.keras.layers.Flatten(),</span><br><span class="line">        tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        tf.keras.layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">        tf.keras.layers.Dense(NUM_CATEGORIES, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>, loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p>其中 model.compile() 里是模型用的一些优化器，损失函数和评估指标，大家可以自行了解。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>看着其实还是挺简单的对吧，毕竟这模型就这么小，以后做大的就复杂咯。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Language篇（一），让模型理解语法和语义</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A015/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A015/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>哈哈哈，终于来到我的专业领域了，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>大语言模型主要是需要解决两个问题，首先就是语法。</p><h2 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h2><p>那其中一种解决方法我们之前试过了，没错，就是当时用马尔可夫链生成福尔摩斯故事。</p><p>它的本质就是通过每组词的转移概率来分析语法，同时也可以起到预测下一组词的作用。</p><h2 id="上下文无关语法"><a href="#上下文无关语法" class="headerlink" title="上下文无关语法"></a>上下文无关语法</h2><p>除此之外我们也可以主动给 AI 提供语法，任何文本都可以用下面的语法树来表示。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/52.png"></p><p>不过这棵比较简单，实际情况遇到长难句会非常复杂，给大家看一句。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/53.png"></p><p>我输入的语法模型是这样的，不知道有没有穷尽，但是至少也分析出来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TERMINALS = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Adj -&gt; &quot;country&quot; | &quot;dreadful&quot; | &quot;enigmatical&quot; | &quot;little&quot; | &quot;moist&quot; | &quot;red&quot;</span></span><br><span class="line"><span class="string">Adv -&gt; &quot;down&quot; | &quot;here&quot; | &quot;never&quot;</span></span><br><span class="line"><span class="string">Conj -&gt; &quot;and&quot; | &quot;until&quot;</span></span><br><span class="line"><span class="string">Det -&gt; &quot;a&quot; | &quot;an&quot; | &quot;his&quot; | &quot;my&quot; | &quot;the&quot;</span></span><br><span class="line"><span class="string">N -&gt; &quot;armchair&quot; | &quot;companion&quot; | &quot;day&quot; | &quot;door&quot; | &quot;hand&quot; | &quot;he&quot; | &quot;himself&quot;</span></span><br><span class="line"><span class="string">N -&gt; &quot;holmes&quot; | &quot;home&quot; | &quot;i&quot; | &quot;mess&quot; | &quot;paint&quot; | &quot;palm&quot; | &quot;pipe&quot; | &quot;she&quot;</span></span><br><span class="line"><span class="string">N -&gt; &quot;smile&quot; | &quot;thursday&quot; | &quot;walk&quot; | &quot;we&quot; | &quot;word&quot;</span></span><br><span class="line"><span class="string">P -&gt; &quot;at&quot; | &quot;before&quot; | &quot;in&quot; | &quot;of&quot; | &quot;on&quot; | &quot;to&quot;</span></span><br><span class="line"><span class="string">V -&gt; &quot;arrived&quot; | &quot;came&quot; | &quot;chuckled&quot; | &quot;had&quot; | &quot;lit&quot; | &quot;said&quot; | &quot;sat&quot;</span></span><br><span class="line"><span class="string">V -&gt; &quot;smiled&quot; | &quot;tell&quot; | &quot;were&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">NONTERMINALS = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">S -&gt; NP VP | S ConjP S | S PP S</span></span><br><span class="line"><span class="string">NP -&gt; N | Det NP | AdjP NP</span></span><br><span class="line"><span class="string">VP -&gt; V | Adv VP | VP Adv | VP PP | VP NP | VP Conj VP</span></span><br><span class="line"><span class="string">ConjP -&gt; Conj | Conj NP | Conj VP</span></span><br><span class="line"><span class="string">PP -&gt; P NP | P S</span></span><br><span class="line"><span class="string">AdjP -&gt; Adj | Adj AdjP</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h1><p>没有语义那么语言也就没有了灵魂，就像之前福尔摩斯的生成文章一样，看着好像说了很多，但其实什么也没说。</p><h2 id="词袋模型"><a href="#词袋模型" class="headerlink" title="词袋模型"></a>词袋模型</h2><p>Bag-of-words 是一种将文本表示为无序单词集合的模型，此模型忽略语法，仅考虑句子中单词的含义。此方法在某些分类任务中非常有用，例如分类垃圾邮件。</p><p>具体的话就是说我这句话里正向词多就正向，负向词多情绪就是负向的。</p><p>那比如 ”我又开心又伤心“，那开心是正向，伤心是负向，正负各一个，这句话就是中性的了，除非我给某一个加个非常，很之类的。</p><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>朴素贝叶斯是一种可用于词袋模型的情绪分析的技术，对于一句话判断为某种情绪的概率我们可以用如下公式表示。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/54.png"></p><p>其中 b 代表情绪，a 代表那句话。</p><p>举个例子，”我的孙子爱它“，如果想计算它表达积极情绪的概率，就可以转为计算它们的联合概率，即。</p><p>$$P(正向，“我的”，“孙子”，“爱”，“它”) * P(正向)$$</p><p>但是，计算这个联合概率很复杂，因为每个单词的概率都取决于它前面的单词的概率，它要求我们计算 P(正) * P(“我的” | 正) * P(“孙” | 正，“我的”) * P(爱 | 正，“我的”，“孙子”) * P(“它” | 正，”我的“，“孙子”，“爱”)。</p><p>不过我们可以不考虑语法，也就是假设每个单词的概率独立于其他单词，也能得到不错的效果。</p><p>$$P(积极) * P(“我的” | 积极) * P(“孙子” | 积极) * P(“爱” | 积极) * P(“它” | 积极)$$</p><p>这并不难计算，其中 P(正) &#x3D; 所有正样本数除以总样本数，P(“爱” | 正向) 等于带有单词 “爱” 的正样本数除以正样本数，具体如下。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/55.png"></p><p>朴素贝叶斯的优势在于，它对一种句子中出现频率高于另一种句子的单词敏感。在我们的例子中，“爱” 这个词在肯定句中出现的频率要高得多，这使得整个句子更有可能是正面的而不是负面的。</p><h1 id="单词表示"><a href="#单词表示" class="headerlink" title="单词表示"></a>单词表示</h1><h2 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h2><p>在独热编码中，每个单词都用一个向量表示，该向量由与我们拥有的单词一样多的值组成，除了向量中等于 1 的单个值外，所有其他值都等于 0。</p><p>例如，“他写了一本书” 可以表示为四个向量。</p><ol><li>[1, 0, 0, 0]（他）。</li><li>[0, 1, 0, 0]（写了）。</li><li>[0, 0, 1, 0]（一本）。</li><li>[0, 0, 0, 1]（书）。</li></ol><p>但是当单词多起来之后，我们就很难用这种方法来表示了。</p><p>而且这种方法有个最致命的问题，就是没办法表示一些类似的单词，比如早饭和中饭两个词之间的距离，肯定应该比早饭和游泳之间的距离短。</p><p>再比如说如下图，男人到国王的距离应该是与女人到皇后的距离相等的，但是这些都不能在独热编码中体现出来。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/56.png"></p><h2 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h2><p>所以我们应该用更加小的维度，将它们表示成几个不同的数字，比如上面的例子，我们可以重新表示为。</p><ol><li>[-0.34, -0.08, 0.02, -0.18, …]（他）。</li><li>[-0.27, 0.40, 0.00, -0.65, …]（写了）。</li><li>[-0.12, -0.25, 0.29, -0.09, …]（一本）。</li><li>[-0.23, -0.16, -0.05, -0.57, …]（书）。</li></ol><p>Word2Vec 是一种用于生成单词的分布式表示的算法。它通过 Skip-Gram 架构来实现这一点，Skip-Gram 架构是一种神经网络架构，用于在给定目标词的情况下预测上下文。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/57.png"></p><p>在此体系结构中，神经网络的每个目标单词都有一个输入单元。较小的单个隐藏层（例如50&#x2F;100个单位）将生成表示单词的分布式表示的值，输出层将生成可能出现在与目标单词相似的上下文中的单词，而 Word2Vec 就是整个网络的副产物，它可以将任意一个单词表示成特定的向量。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>你能觉得关键看完还是不知道 AI 怎么就理解语意了，但是其实有上面的知识就足够了。</p><p>AI 已经能够补全你的想法了，也能够知道相似词，甚至能够回答问题（这个明天讲），所以说它理解了吗？我也不清楚，学界也还有争论，但是至少看上去理解了。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大语言模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Language篇（二），生成并观察注意力热力图</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A016/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A016/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是理论学习的最后一篇了，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h1><h2 id="序列模型"><a href="#序列模型" class="headerlink" title="序列模型"></a>序列模型</h2><p>先来讲讲模型结构吧，如果你之前的文章有认真看，肯定会想到可以用处理序列输入和输出的模型结构。</p><p>首先将文本如下按序输入进去。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/60.png"></p><p>然后当输入到 [end] 符时就生成第一个输出词，然后再把输出的词按序输入，就能得到完整的输出。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/59.png"></p><p>这样做确实可以，唯一的缺点就是不能并行，所以当数据量大的时候，消耗的时间和算力就会成倍上升。</p><h2 id="Transformers"><a href="#Transformers" class="headerlink" title="Transformers"></a>Transformers</h2><p>在 Transformers 中，我们可以做到让模型如下同时接收 Input 信息，然后处理生成 Output 信息。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/61.png"></p><p>但是该有的信息还是一个都不能少，所以我们首先就得补充顺序信息，如下就是通过添加位置编码来实现的。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/62.png"></p><p>有了信息之后我们可以通过自注意力机制分析不同词之间的关联度，从而让模型更加专注于有价值的内容，如下图就是一张学会了顺序信息的注意力热力图。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/63.png"></p><p>那最后为了在输出的过程中，让模型知道自己之前输出了什么，就需要将之前的未解码的输出重新输入进来并计算交叉注意力。</p><h1 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h1><h2 id="原理和实现"><a href="#原理和实现" class="headerlink" title="原理和实现"></a>原理和实现</h2><p>关于注意力的原理我非常推荐大家看看3B1B的视频 <a href="https://www.youtube.com/watch?v=eMlx5fFNoYc%EF%BC%8C%E6%88%91%E8%BF%99%E8%BE%B9%E5%B0%B1%E6%9D%A5%E5%B8%A6%E5%A4%A7%E5%AE%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%81%8D%EF%BC%8C%E8%AE%A9%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9C%8B%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%88%B0%E5%BA%95%E6%B3%A8%E6%84%8F%E4%BA%86%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%E3%80%82">https://www.youtube.com/watch?v=eMlx5fFNoYc，我这边就来带大家实现一遍，让大家看看注意力到底注意了什么东西。</a></p><p>主要给大家看一下主程序，因为都是调用，所以代码本身没什么难度，大家过一下就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pre-trained masked language model</span></span><br><span class="line">MODEL = <span class="string">&quot;bert-base-uncased&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Number of predictions to generate</span></span><br><span class="line">K = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Constants for generating attention diagrams</span></span><br><span class="line">FONT = ImageFont.truetype(<span class="string">&quot;./attention/assets/fonts/OpenSans-Regular.ttf&quot;</span>, <span class="number">28</span>)</span><br><span class="line">GRID_SIZE = <span class="number">40</span></span><br><span class="line">PIXELS_PER_WORD = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    text = <span class="built_in">input</span>(<span class="string">&quot;Text: &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Tokenize input</span></span><br><span class="line">    tokenizer = AutoTokenizer.from_pretrained(MODEL)</span><br><span class="line">    inputs = tokenizer(text, return_tensors=<span class="string">&quot;tf&quot;</span>)</span><br><span class="line">    mask_token_index = get_mask_token_index(tokenizer.mask_token_id, inputs)</span><br><span class="line">    <span class="keyword">if</span> mask_token_index <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        sys.exit(<span class="string">f&quot;Input must include mask token <span class="subst">&#123;tokenizer.mask_token&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use model to process input</span></span><br><span class="line">    model = TFBertForMaskedLM.from_pretrained(MODEL)</span><br><span class="line">    result = model(**inputs, output_attentions=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate predictions</span></span><br><span class="line">    mask_token_logits = result.logits[<span class="number">0</span>, mask_token_index]</span><br><span class="line">    top_tokens = tf.math.top_k(mask_token_logits, K).indices.numpy()</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> top_tokens:</span><br><span class="line">        <span class="built_in">print</span>(text.replace(tokenizer.mask_token, tokenizer.decode([token])))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Visualize attentions</span></span><br><span class="line">    visualize_attentions(inputs.tokens(), result.attentions)</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>注意力层并不总是符合我们对单词之间特定关系的期望，它们也并不总是对应于人类可解释的关系，但我们可以根据它们看起来对应的东西进行猜测。</p><p>除了上面学到的顺序信息，注意力机制还可以学习到词性。</p><p>大家如果自己跑了一遍可以看看 Attention_Layer4_Head11 这张图（如下），可以看到它似乎发现了 moved 和 slowly 之间的联系。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/64.png"></p><p>我们尝试交换动词和副词的顺序，情况也是如此，即使有很多噪音。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/65.png"></p><p>因此，我们可以合理地猜测，这个注意力机制已经学会了注意副词和它们修饰的词之间的关系。</p><p>剩下的特性就由大家自行探索了，如果你懒得跑代码，可以看我上传的图片 <a href="https://github.com/zong4/AILearning/tree/main/attention%E3%80%82">https://github.com/zong4/AILearning/tree/main/attention。</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如此，这个专栏就到尾声了，狼人杀应该会鸽掉，因为它还需要大语言模型的支持才算完整，有点超纲了，所以这个专栏也会在这一篇结束。</p><p>明天可能会休息一天，然后开始为大家每周带来一篇最新的 AI 研究的复现，尽情期待。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大语言模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Neural Networks篇（二），让AI分辨猫和狗并优化</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A018/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A018/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天再来做一个神经网络的分类任务，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>来看看比上次多了什么。</p><h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><p>首先是考虑到图像比较少，所以通过旋转缩放来生成新的图像供 AI 训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">train_image_generator = ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>,</span><br><span class="line">                                          rotation_range=<span class="number">45</span>,</span><br><span class="line">                                          width_shift_range=<span class="number">.15</span>,</span><br><span class="line">                                          height_shift_range=<span class="number">.15</span>,</span><br><span class="line">                                          horizontal_flip=<span class="literal">True</span>,</span><br><span class="line">                                          zoom_range=<span class="number">0.5</span>) <span class="comment"># Generator for our training data</span></span><br><span class="line"></span><br><span class="line">train_data_gen = train_image_generator.flow_from_directory(batch_size=batch_size,</span><br><span class="line">                                                     directory=train_dir,</span><br><span class="line">                                                     target_size=(IMG_HEIGHT, IMG_WIDTH),</span><br><span class="line">                                                     class_mode=<span class="string">&#x27;binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">augmented_images = [train_data_gen[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line">plotImages(augmented_images)</span><br></pre></td></tr></table></figure><p>效果如下。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/68.png"></p><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential([</span><br><span class="line">    Conv2D(<span class="number">16</span>, <span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(IMG_HEIGHT, IMG_WIDTH ,<span class="number">3</span>)),</span><br><span class="line">    MaxPooling2D(),</span><br><span class="line">    Conv2D(<span class="number">32</span>, <span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    MaxPooling2D(),</span><br><span class="line">    Conv2D(<span class="number">64</span>, <span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    MaxPooling2D(),</span><br><span class="line">    Flatten(),</span><br><span class="line">    Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    Dense(<span class="number">1</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><p>可以通过 model.summary() 来查看模型的结构。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/69.png"></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>这是没有 Dropout 层的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accuracy: 0.6516 - loss: 0.6097 - val_accuracy: 0.6931 - val_loss: 0.5868</span><br></pre></td></tr></table></figure><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/70.png"></p><p>加上 Dropout 层后，正确率变低了，说明之前的模型过拟合了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accuracy: 0.6129 - loss: 0.6371 - val_accuracy: 0.6618 - val_loss: 0.6068</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>又加了一层卷积，还是不够。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accuracy: 0.6103 - loss: 0.6333 - val_accuracy: 0.6808 - val_loss: 0.5937</span><br></pre></td></tr></table></figure><p>提了一下 epoch，正确率提高了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accuracy: 0.7266 - loss: 0.5674 - val_accuracy: 0.7199 - val_loss: 0.5659</span><br></pre></td></tr></table></figure><p>提供了更丰富的数据增强。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">train_datagen = ImageDataGenerator(</span><br><span class="line">    rescale=<span class="number">1.</span>/<span class="number">255</span>,</span><br><span class="line">    rotation_range=<span class="number">45</span>,  <span class="comment"># 增大旋转范围</span></span><br><span class="line">    width_shift_range=<span class="number">0.3</span>,  <span class="comment"># 增大水平平移范围</span></span><br><span class="line">    height_shift_range=<span class="number">0.3</span>,  <span class="comment"># 增大垂直平移范围</span></span><br><span class="line">    shear_range=<span class="number">0.3</span>,  <span class="comment"># 增大错切范围</span></span><br><span class="line">    zoom_range=[<span class="number">0.7</span>, <span class="number">1.3</span>],  <span class="comment"># 更宽的缩放范围</span></span><br><span class="line">    horizontal_flip=<span class="literal">True</span>,</span><br><span class="line">    vertical_flip=<span class="literal">True</span>,  <span class="comment"># 增加垂直翻转</span></span><br><span class="line">    fill_mode=<span class="string">&#x27;nearest&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>直接给训练集的正确率干飞掉了，过拟合无疑了。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/71.png"></p><p>引入批量归一化层（Batch Normalization）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential([</span><br><span class="line">    Conv2D(<span class="number">16</span>, <span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>, input_shape=(IMG_HEIGHT, IMG_WIDTH ,<span class="number">3</span>)),</span><br><span class="line">    BatchNormalization(),</span><br><span class="line">    Activation(<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    MaxPooling2D(),</span><br><span class="line">    Conv2D(<span class="number">32</span>, <span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>),</span><br><span class="line">    BatchNormalization(),</span><br><span class="line">    Activation(<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    MaxPooling2D(),</span><br><span class="line">    Conv2D(<span class="number">64</span>, <span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>),</span><br><span class="line">    BatchNormalization(),</span><br><span class="line">    Activation(<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    MaxPooling2D(),</span><br><span class="line">    Conv2D(<span class="number">128</span>, <span class="number">3</span>, padding=<span class="string">&#x27;same&#x27;</span>),</span><br><span class="line">    BatchNormalization(),</span><br><span class="line">    Activation(<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    MaxPooling2D(),</span><br><span class="line">    Flatten(),</span><br><span class="line">    Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    Dense(<span class="number">1</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>正确率直接烂掉了，应该是数据集太小了。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/72.png"></p><p>所以干脆和上一步合一起来训练，好像没什么变化，那我就没头绪了。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/73.png"></p><p>修改学习率调度器为余弦退火学习率调度器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cosine_annealing_lr</span>(<span class="params">epoch, lr, T_max=<span class="number">100</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.001</span> * <span class="number">0.5</span> * (<span class="number">1</span> + np.cos(np.pi * epoch / T_max))</span><br><span class="line">lr_scheduler = LearningRateScheduler(cosine_annealing_lr)</span><br></pre></td></tr></table></figure><p>看上去，epoch 不够，还在跳，不过貌似效果还可以。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/74.png"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>总之，现在对好多调参手段还没法说出个所以然，只能靠试，所以还是得进行更深入的理论学习，期待以后的文章吧。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning篇（三），让AI推荐书籍</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A019/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A019/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来写一个图书推荐引擎，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><p>主要是有三个表，给大家看一下。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/76.png"></p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/75.png"></p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/77.png"></p><p>先把数据提出来，画图就不画了，数据量有点大，给我电脑干卡了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">books_filename = <span class="string">&#x27;./book_recommendation/book-crossings/BX-Books.csv&#x27;</span></span><br><span class="line">ratings_filename = <span class="string">&#x27;./book_recommendation/book-crossings/BX-Book-Ratings.csv&#x27;</span></span><br><span class="line">users_filename = <span class="string">&#x27;./book_recommendation/book-crossings/BX-Users.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import csv data into dataframes</span></span><br><span class="line">df_books = pd.read_csv(</span><br><span class="line">    books_filename,</span><br><span class="line">    encoding = <span class="string">&quot;ISO-8859-1&quot;</span>,</span><br><span class="line">    sep=<span class="string">&quot;;&quot;</span>,</span><br><span class="line">    header=<span class="number">0</span>,</span><br><span class="line">    names=[<span class="string">&#x27;isbn&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;author&#x27;</span>],</span><br><span class="line">    usecols=[<span class="string">&#x27;isbn&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;author&#x27;</span>],</span><br><span class="line">    dtype=&#123;<span class="string">&#x27;isbn&#x27;</span>: <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;author&#x27;</span>: <span class="string">&#x27;str&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">df_ratings = pd.read_csv(</span><br><span class="line">    ratings_filename,</span><br><span class="line">    encoding = <span class="string">&quot;ISO-8859-1&quot;</span>,</span><br><span class="line">    sep=<span class="string">&quot;;&quot;</span>,</span><br><span class="line">    header=<span class="number">0</span>,</span><br><span class="line">    names=[<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;isbn&#x27;</span>, <span class="string">&#x27;rating&#x27;</span>],</span><br><span class="line">    usecols=[<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;isbn&#x27;</span>, <span class="string">&#x27;rating&#x27;</span>],</span><br><span class="line">    dtype=&#123;<span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;int32&#x27;</span>, <span class="string">&#x27;isbn&#x27;</span>: <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;rating&#x27;</span>: <span class="string">&#x27;float32&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">df_users = pd.read_csv(</span><br><span class="line">    users_filename,</span><br><span class="line">    encoding = <span class="string">&quot;ISO-8859-1&quot;</span>,</span><br><span class="line">    sep=<span class="string">&quot;;&quot;</span>,</span><br><span class="line">    header=<span class="number">0</span>,</span><br><span class="line">    names=[<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;age&#x27;</span>],</span><br><span class="line">    usecols=[<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;age&#x27;</span>],</span><br><span class="line">    dtype=&#123;<span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;int32&#x27;</span>, <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;float32&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h1 id="模型拟合"><a href="#模型拟合" class="headerlink" title="模型拟合"></a>模型拟合</h1><p>生成数据透视表，然后用 KNN 模型来推荐书籍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># function to return recommended books - this will be tested</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_recommends</span>(<span class="params">book = <span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="comment"># create a new dataframe with the books and their ratings</span></span><br><span class="line">    df = df_books.set_index(<span class="string">&#x27;isbn&#x27;</span>).join(df_ratings.set_index(<span class="string">&#x27;isbn&#x27;</span>))</span><br><span class="line">    <span class="comment"># print(df.iloc[:4])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># create a pivot table</span></span><br><span class="line">    df_pivot = df.pivot_table(index=<span class="string">&#x27;title&#x27;</span>, columns=<span class="string">&#x27;user&#x27;</span>, values=<span class="string">&#x27;rating&#x27;</span>).fillna(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(df_pivot.iloc[:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create a nearest neighbors model</span></span><br><span class="line">    model_knn = NearestNeighbors(metric=<span class="string">&#x27;cosine&#x27;</span>, algorithm=<span class="string">&#x27;brute&#x27;</span>, n_neighbors=<span class="number">20</span>)</span><br><span class="line">    model_knn.fit(df_pivot)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get the index of the book</span></span><br><span class="line">    query_index = df_pivot.index.get_loc(book)</span><br><span class="line">    distances, indices = model_knn.kneighbors(df_pivot.iloc[query_index, :].values.reshape(<span class="number">1</span>, -<span class="number">1</span>), n_neighbors=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [book, <span class="built_in">list</span>(df_pivot.index[indices.flatten()]), <span class="built_in">list</span>(distances.flatten())]</span><br></pre></td></tr></table></figure><p>生成的表就差不多长下面这样，我们就可以根据用户的打分来计算书籍之间的相似度了。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/78.png"></p><h1 id="优化1：特征提取"><a href="#优化1：特征提取" class="headerlink" title="优化1：特征提取"></a>优化1：特征提取</h1><p>线程都直接被 kill 了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsh: killed     python book_recommendation/test.py</span><br></pre></td></tr></table></figure><p>其实不同用户的打分根本没用，应该输入的数据是书名，而不是用户信息，所以我们不需要计算用户的相似度，所以我们只需要书籍的信息和打分就可以了。</p><p>所以我们就提取那么些特征来训练 KNN 模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># average rating and number of ratings for each book</span></span><br><span class="line">average_rating = df_ratings.groupby(<span class="string">&#x27;isbn&#x27;</span>)[<span class="string">&#x27;rating&#x27;</span>].mean()</span><br><span class="line">rating_count = df_ratings.groupby(<span class="string">&#x27;isbn&#x27;</span>)[<span class="string">&#x27;rating&#x27;</span>].count()</span><br><span class="line">df_ratings_avg = pd.DataFrame(&#123;<span class="string">&#x27;isbn&#x27;</span>: average_rating.index, <span class="string">&#x27;avg_rating&#x27;</span>: average_rating.values, <span class="string">&#x27;rating_count&#x27;</span>: rating_count.values&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a new dataframe with the books and their ratings</span></span><br><span class="line">df = df_books.set_index(<span class="string">&#x27;isbn&#x27;</span>).join(df_ratings_avg.set_index(<span class="string">&#x27;isbn&#x27;</span>))</span><br><span class="line"><span class="comment"># print(df.iloc[:4])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># One Hot Encoding</span></span><br><span class="line">author_encoder = LabelEncoder()</span><br><span class="line">df[<span class="string">&#x27;author_encoded&#x27;</span>] = author_encoder.fit_transform(df[<span class="string">&#x27;author&#x27;</span>])</span><br><span class="line"></span><br><span class="line">publisher_encoder = LabelEncoder()</span><br><span class="line">df[<span class="string">&#x27;publisher_encoded&#x27;</span>] = publisher_encoder.fit_transform(df[<span class="string">&#x27;publisher&#x27;</span>])</span><br><span class="line"></span><br><span class="line">features = df[[<span class="string">&#x27;author_encoded&#x27;</span>, <span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;publisher_encoded&#x27;</span>, <span class="string">&#x27;avg_rating&#x27;</span>, <span class="string">&#x27;rating_count&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a nearest neighbors model</span></span><br><span class="line">model_knn = NearestNeighbors(metric=<span class="string">&#x27;cosine&#x27;</span>, algorithm=<span class="string">&#x27;brute&#x27;</span>, n_neighbors=<span class="number">20</span>)</span><br><span class="line">model_knn.fit(features)</span><br></pre></td></tr></table></figure><p>结果报错了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: could not convert string to float: &#x27;John Peterman&#x27;</span><br></pre></td></tr></table></figure><h1 id="优化2：数据清洗"><a href="#优化2：数据清洗" class="headerlink" title="优化2：数据清洗"></a>优化2：数据清洗</h1><p>看了一眼，就是书名有分号，所以识别出了问题。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/79.png"></p><p>加了一行这个没什么用，毕竟 mac 自带的 csv 读取器也错了，只能手改了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quoting=csv.QUOTE_ALL</span><br></pre></td></tr></table></figure><p>算了太多了，直接把数据丢了吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create a new dataframe with the books and their ratings</span></span><br><span class="line">df = df_books.set_index(<span class="string">&#x27;isbn&#x27;</span>).join(df_ratings_avg.set_index(<span class="string">&#x27;isbn&#x27;</span>))</span><br><span class="line">df = df[df[<span class="string">&#x27;year&#x27;</span>].<span class="built_in">str</span>.isnumeric()]</span><br><span class="line">df = df.dropna()</span><br><span class="line">df[<span class="string">&#x27;year&#x27;</span>] = df[<span class="string">&#x27;year&#x27;</span>].astype(<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure><h1 id="优化3：数据编码"><a href="#优化3：数据编码" class="headerlink" title="优化3：数据编码"></a>优化3：数据编码</h1><p>给字符串数据进行编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Encoding</span></span><br><span class="line">author_encoder = LabelEncoder()</span><br><span class="line">publisher_encoder = LabelEncoder()</span><br><span class="line">df[<span class="string">&#x27;author_encoded&#x27;</span>] = author_encoder.fit_transform(df[<span class="string">&#x27;author&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;publisher_encoded&#x27;</span>] = publisher_encoder.fit_transform(df[<span class="string">&#x27;publisher&#x27;</span>])</span><br></pre></td></tr></table></figure><h1 id="优化4：数据标准化"><a href="#优化4：数据标准化" class="headerlink" title="优化4：数据标准化"></a>优化4：数据标准化</h1><p>输入是 “Where the Heart Is (Oprah’s Book Club (Paperback))”，结果还可以，找的都是同一个作者的书。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Where the Heart Is (Oprah&#x27;s Book Club (Paperback))&quot;: &#123;</span><br><span class="line">        &quot;The Honk and Holler Opening Soon&quot;: 0.0004220216524539744,</span><br><span class="line">        &quot;Where the Heart Is: A Novel&quot;: 0.0004329866196861598,</span><br><span class="line">        &quot;Where the Heart Is&quot;: 0.00045208676755403854,</span><br><span class="line">        &quot;Shoot the Moon&quot;: 0.00047166440227597306</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过感觉评分应该也不能加入相似性计算里，应该是找到了之后用评分排序比较好。</p><p>结果也是一样的，看来评分就没用，不过这相似度也太小了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Where the Heart Is (Oprah&#x27;s Book Club (Paperback))&quot;: &#123;</span><br><span class="line">        &quot;The Honk and Holler Opening Soon&quot;: 1.4160210781710703e-09,</span><br><span class="line">        &quot;Where the Heart Is&quot;: 5.6642790458028e-09,</span><br><span class="line">        &quot;Where the Heart Is: A Novel&quot;: 1.2744773680850585e-08,</span><br><span class="line">        &quot;Shoot the Moon&quot;: 5.097383926067067e-08</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试一下标准化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Standardization</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">features = df[[<span class="string">&#x27;author_encoded&#x27;</span>, <span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;publisher_encoded&#x27;</span>, <span class="string">&#x27;avg_rating&#x27;</span>, <span class="string">&#x27;rating_count&#x27;</span>]]</span><br><span class="line">features = scaler.fit_transform(features)</span><br></pre></td></tr></table></figure><p>结果也还是大差不差。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Where the Heart Is (Oprah&#x27;s Book Club (Paperback))&quot;: &#123;</span><br><span class="line">        &quot;Christmas Words: See-And-Say Fun for the Very Young&quot;: 5.922528489854528e-08,</span><br><span class="line">        &quot;The Scold&#x27;s Bridle&quot;: 7.66054157885776e-08,</span><br><span class="line">        &quot;The Void Captain&#x27;s Tale&quot;: 3.051218466776362e-07,</span><br><span class="line">        &quot;An Album of Voyager&quot;: 8.988488962025087e-07,</span><br><span class="line">        &quot;This Old House : The Best of Ask Norm&quot;: 1.0828802619045064e-06</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化5：特征拼接"><a href="#优化5：特征拼接" class="headerlink" title="优化5：特征拼接"></a>优化5：特征拼接</h1><p>感觉之前优化了个寂寞，现在仔细一想用户-书籍的评分矩阵，可以让AI学会在用户眼中，哪几本书会一起看，所以应该一起考虑，类似这样。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/80.png"></p><p>数据量真的很大啊，我电脑上跑不下，被迫把数据筛掉很多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INFO:root:count    340556.000000</span><br><span class="line">mean          3.376185</span><br><span class="line">std          12.436252</span><br><span class="line">min           1.000000</span><br><span class="line">25%           1.000000</span><br><span class="line">50%           1.000000</span><br><span class="line">75%           2.000000</span><br><span class="line">max        2502.000000</span><br><span class="line">Name: rating, dtype: float64</span><br></pre></td></tr></table></figure><p>主要是后来还用了独热编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_books = pd.get_dummies(df_books, columns=[<span class="string">&#x27;author&#x27;</span>])</span><br><span class="line">df_books = pd.get_dummies(df_books, columns=[<span class="string">&#x27;publisher&#x27;</span>])</span><br></pre></td></tr></table></figure><p>调整了挺多的，大家自己看吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># draw a bar chart of the number of books rated by each user</span></span><br><span class="line">ratings_per_user = df_ratings.groupby(<span class="string">&#x27;user&#x27;</span>)[<span class="string">&#x27;rating&#x27;</span>].count()</span><br><span class="line">ratings_per_book = df_ratings.groupby(<span class="string">&#x27;isbn&#x27;</span>)[<span class="string">&#x27;rating&#x27;</span>].count()</span><br><span class="line">logging.info(<span class="string">&quot;The distribution of ratings per book: &quot;</span>)</span><br><span class="line">logging.info(ratings_per_book.describe())</span><br><span class="line"></span><br><span class="line"><span class="comment"># average rating and number of ratings for each book</span></span><br><span class="line">average_rating = df_ratings.groupby(<span class="string">&#x27;isbn&#x27;</span>)[<span class="string">&#x27;rating&#x27;</span>].mean()</span><br><span class="line">rating_count = df_ratings.groupby(<span class="string">&#x27;isbn&#x27;</span>)[<span class="string">&#x27;rating&#x27;</span>].count()</span><br><span class="line">df_ratings_avg = pd.DataFrame(&#123;<span class="string">&#x27;isbn&#x27;</span>: average_rating.index, <span class="string">&#x27;avg_rating&#x27;</span>: average_rating.values, <span class="string">&#x27;rating_count&#x27;</span>: rating_count.values&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># process df_books</span></span><br><span class="line">df_books = df_books[df_books[<span class="string">&#x27;year&#x27;</span>].<span class="built_in">str</span>.isnumeric()]</span><br><span class="line">df_books[<span class="string">&#x27;year&#x27;</span>] = df_books[<span class="string">&#x27;year&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line">df_books = df_books.dropna()</span><br><span class="line"></span><br><span class="line"><span class="comment"># One-hot encoding</span></span><br><span class="line"><span class="comment"># df_books = pd.get_dummies(df_books, columns=[&#x27;author&#x27;])</span></span><br><span class="line"><span class="comment"># df_books = pd.get_dummies(df_books, columns=[&#x27;publisher&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># extract extra features</span></span><br><span class="line">extra_features = df_books.drop(columns=[<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;publisher&#x27;</span>, <span class="string">&#x27;author&#x27;</span>])</span><br><span class="line">logging.info(<span class="string">&quot;Extra features: &quot;</span>)</span><br><span class="line">logging.info(extra_features)</span><br><span class="line"></span><br><span class="line"><span class="comment"># join the dataframes</span></span><br><span class="line">df = df_books.set_index(<span class="string">&#x27;isbn&#x27;</span>).join(df_ratings.set_index(<span class="string">&#x27;isbn&#x27;</span>))</span><br><span class="line">df = df.groupby(<span class="string">&#x27;isbn&#x27;</span>).<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x) &gt;= <span class="number">100</span>)</span><br><span class="line">user_book_matrix = df.pivot_table(index=<span class="string">&#x27;isbn&#x27;</span>, columns=<span class="string">&#x27;user&#x27;</span>, values=<span class="string">&#x27;rating&#x27;</span>).fillna(<span class="number">0</span>)</span><br><span class="line">logging.info(<span class="string">&quot;User book matrix: &quot;</span>)</span><br><span class="line">logging.info(user_book_matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># concat by isbn</span></span><br><span class="line">extra_features.set_index(<span class="string">&#x27;isbn&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">combined_data = pd.concat([user_book_matrix, extra_features], axis=<span class="number">1</span>)</span><br><span class="line">combined_data = combined_data.dropna()</span><br><span class="line">combined_data = combined_data[combined_data[<span class="string">&#x27;year&#x27;</span>] != <span class="number">0</span>]</span><br><span class="line">logging.info(<span class="string">&quot;Combined data: &quot;</span>)</span><br><span class="line">logging.info(combined_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># train the knn model</span></span><br><span class="line">model_knn = NearestNeighbors(metric=<span class="string">&#x27;cosine&#x27;</span>, algorithm=<span class="string">&#x27;brute&#x27;</span>, n_neighbors=<span class="number">20</span>)</span><br><span class="line">model_knn.fit(combined_data.values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># function to return recommended books - this will be tested</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_recommends</span>(<span class="params">book = <span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="comment"># get the isbn of the book</span></span><br><span class="line">    isbn_index = df_books[df_books[<span class="string">&#x27;title&#x27;</span>] == book][<span class="string">&#x27;isbn&#x27;</span>].values[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get the index of the book in the combined data</span></span><br><span class="line">    logging.info(<span class="string">&quot;Book: &quot;</span> + book)</span><br><span class="line">    logging.info(<span class="string">&quot;ISBN index: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> isbn_index <span class="keyword">not</span> <span class="keyword">in</span> combined_data.index:</span><br><span class="line">        logging.info(<span class="string">&quot;Book not found.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    book_index = combined_data.index.get_loc(isbn_index)</span><br><span class="line"></span><br><span class="line">    distances, indices = model_knn.kneighbors(combined_data.iloc[book_index].values.reshape(<span class="number">1</span>, -<span class="number">1</span>), n_neighbors=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the format of the recommended books</span></span><br><span class="line">    <span class="comment"># &#123;</span></span><br><span class="line">    <span class="comment">#     book:</span></span><br><span class="line">    <span class="comment">#     &#123;</span></span><br><span class="line">    <span class="comment">#         [similar_book_1_isbn, similar_book_1_title]: distance_1,</span></span><br><span class="line">    <span class="comment">#         [similar_book_2_isbn, similar_book_2_title]: distance_2,</span></span><br><span class="line">    <span class="comment">#         [similar_book_3_isbn, similar_book_3_title]: distance_3,</span></span><br><span class="line">    <span class="comment">#         [similar_book_4_isbn, similar_book_4_title]: distance_4,</span></span><br><span class="line">    <span class="comment">#         [similar_book_5_isbn, similar_book_5_title]: distance_5</span></span><br><span class="line">    <span class="comment">#     &#125;</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line">    recommended_books = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(indices[<span class="number">0</span>])):</span><br><span class="line">        recommended_book_isbn = combined_data.iloc[indices[<span class="number">0</span>][i]].name</span><br><span class="line">        recommended_book_title = df_books.loc[df_books[<span class="string">&#x27;isbn&#x27;</span>] == recommended_book_isbn, <span class="string">&#x27;title&#x27;</span>].values[<span class="number">0</span>]</span><br><span class="line">        recommended_books[recommended_book_isbn + <span class="string">&quot; &quot;</span>+ recommended_book_title] = distances[<span class="number">0</span>][i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recommended_books</span><br></pre></td></tr></table></figure><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>还行，比之前好多了，就这样吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;042513699X Turtle Moon&quot;: 0.0026335611586064678,</span><br><span class="line">    &quot;0373825013 Whirlwind (Tyler, Book 1)&quot;: 0.00265084184906883,</span><br><span class="line">    &quot;0446365505 Pleading Guilty&quot;: 0.0026517030537067665,</span><br><span class="line">    &quot;0425150143 Tom Clancy&#x27;s Op-Center: Mirror Image (Tom Clancy&#x27;s Op Center (Paperback))&quot;: 0.0026543396062681524</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>怎么说呢，受益匪浅，但是确实处理数据太麻烦了，而且量太大了，我的电脑毕竟也只有16g内存。</p><p>其实还可以添加用户相似度的判断，这样就可以直接给新用户推荐书籍，大家可以自行尝试。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Neural Networks篇（三），用无监督学习让AI学会画圆</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A020/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A020/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前不是有说过，神经网络可以学会非线性关系，例如圆之类的，今天我们就来尝试一下，目标就是拟合出下面的圆，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/85.png"></p><h1 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h1><p>大家先自己过一下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成圆上的数据点</span></span><br><span class="line">num_points = <span class="number">1000</span></span><br><span class="line">theta = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, num_points)</span><br><span class="line">radius1 = <span class="number">1</span></span><br><span class="line">radius2 = <span class="number">2</span></span><br><span class="line">x1 = radius1 * np.cos(theta)</span><br><span class="line">y1 = radius1 * np.sin(theta)</span><br><span class="line">x2 = radius2 * np.cos(theta)</span><br><span class="line">y2 = radius2 * np.sin(theta)</span><br><span class="line"></span><br><span class="line">data = np.column_stack((np.concatenate((x1, x2)), np.concatenate((y1, y2))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">train_size = <span class="built_in">int</span>(<span class="number">0.8</span> * num_points)</span><br><span class="line">train_data = data[:train_size]</span><br><span class="line">test_data = data[train_size:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建模型</span></span><br><span class="line">model = keras.Sequential([</span><br><span class="line">    layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">2</span>,)),</span><br><span class="line">    layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    layers.Dense(<span class="number">2</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=keras.optimizers.Adam(<span class="number">0.001</span>), loss=<span class="string">&#x27;mse&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_data_x = radius1 * np.cos(theta) * <span class="number">0.5</span></span><br><span class="line">test_data_y = radius1 * np.sin(theta) * <span class="number">0.5</span></span><br><span class="line">test_data = np.column_stack((test_data_x, test_data_y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">history = model.fit(train_data, train_data, epochs=<span class="number">100</span>, verbose=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行预测</span></span><br><span class="line">predictions = model.predict(test_data)</span><br></pre></td></tr></table></figure><p>细心的朋友应该发现了，这里的最后一层网络居然是2个神经元，而且模型训练时居然没有输入训练集标签，也就是要预测的数据。</p><p>这也是无监督学习最大的特点，就是<strong>输入数据同时作为输入和目标（标签）</strong>，模型的任务是学习数据之间的关系，所以最后一层网络中的两个神经元就分别代表x和y。</p><h2 id="自编码器原理"><a href="#自编码器原理" class="headerlink" title="自编码器原理"></a>自编码器原理</h2><p>自编码器是一种无监督学习模型，其目标是将输入数据重构为输出数据。</p><p>它由两部分组成：编码器（Encoder）和解码器（Decoder），编码器将输入数据压缩成低维表示，解码器则将这个低维表示重构为与输入数据相似的输出。</p><pre><code>有点类似于对抗式生成网络（GAN），但GAN的目标是生成与真实数据相似的数据，而自编码器的目标是重构输入数据。</code></pre><h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><p>同样的问题，我们也可以用监督学习来做，只需把最后一层网络改成1个神经元，也就是y，然后训练时同时输入标签数据就行了，大家就自行尝试吧。</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>以下分别是无监督学习学习一个圆和学习两个圆的结果。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/81.png"></p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/82.png"></p><p>以及同样的条件下监督学习学习的结果。</p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/83.png"></p><p><img src="/img/AI%E5%AD%A6%E4%B9%A0/84.png"></p><p>loss 我忘记了，大家就自己品吧。</p><ol><li>看上去无监督学习随着数据的增加效果变好了，说明是真的有在学习关系（函数表达式）。</li><li>而监督学习却随着数据的增加效果反而变差了，说明它没法理解这种嵌套圆的数据，也可以说是模型限制，但是要搭出一个能学习这种数据的模型也是挺麻烦的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Language篇（三），让AI识别垃圾邮件</title>
      <link href="/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A021/"/>
      <url>/2025/02/25/AI/AI%E5%AD%A6%E4%B9%A0/AI%E5%AD%A6%E4%B9%A021/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天是最后一个 Project 了，完整代码见 <a href="https://github.com/zong4/AILearning%E3%80%82">https://github.com/zong4/AILearning。</a></p><h1 id="词袋模型（Bag-of-Words）"><a href="#词袋模型（Bag-of-Words）" class="headerlink" title="词袋模型（Bag-of-Words）"></a>词袋模型（Bag-of-Words）</h1><p>之前的文章有提到词袋模型做垃圾邮件分类效果挺好的，所以先用这方法，核心代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取特征</span></span><br><span class="line">vectorizer = CountVectorizer()</span><br><span class="line">X_train = vectorizer.fit_transform(train_data[<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line">X_test = vectorizer.transform(test_data[<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line"></span><br><span class="line">y_train = train_data[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">y_test = test_data[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model = MultinomialNB()</span><br><span class="line">model.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><h2 id="构建词汇表"><a href="#构建词汇表" class="headerlink" title="构建词汇表"></a>构建词汇表</h2><p>遍历训练集中的所有邮件文本，统计出现的所有不重复的词汇，这些词汇构成了词汇表（Vocabulary）。</p><p>例如，训练集中的邮件文本包含 “hello”、“world”、“spam”、“offer” 等词汇，将这些词汇收集起来形成词汇表，词汇表的大小决定了后续文本向量的维度。</p><h2 id="文本向量化"><a href="#文本向量化" class="headerlink" title="文本向量化"></a>文本向量化</h2><p>对于训练集中的每一封邮件，统计词汇表中每个词汇在该邮件中出现的次数，将这些次数按照词汇表中词汇的顺序排列，形成一个向量，这个向量就是该邮件的词袋表示。</p><p>例如，词汇表为 [“hello”, “world”, “spam”, “offer”]，某封邮件中 “hello” 出现了 2 次，“world” 出现了 1 次，“spam” 出现了 0 次，“offer” 出现了 3 次，那么该邮件的词袋向量就是 [2, 1, 0, 3]。</p><p>通常，由于词汇表可能非常大，而大部分邮件中只会包含其中一小部分词汇，因此词袋向量是一个稀疏向量，在实际应用中，常使用稀疏矩阵来存储这些向量，以节省内存。</p><h2 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h2><p>基于贝叶斯定理和特征条件独立假设，计算每个词汇在正常邮件和垃圾邮件中出现的概率，从而对新邮件进行分类。</p><h1 id="Word-Embedding"><a href="#Word-Embedding" class="headerlink" title="Word Embedding"></a>Word Embedding</h1><p>由于词袋模型不考虑语义，只是单纯的计算词频，所以自然还会有一种靠语义来判断的方法，那就是词嵌入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数计算文本的 CLS 嵌入，使用 bert_model</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cls_embedding</span>(<span class="params">text</span>):</span><br><span class="line">    inputs = tokenizer(text, return_tensors=<span class="string">&#x27;pt&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        outputs = bert_model(**inputs)</span><br><span class="line">    cls_embedding = outputs.last_hidden_state[:, <span class="number">0</span>, :].numpy()</span><br><span class="line">    <span class="keyword">return</span> cls_embedding</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算训练集和测试集的嵌入</span></span><br><span class="line">train_embeddings = [get_cls_embedding(text).flatten() <span class="keyword">for</span> text <span class="keyword">in</span> train_data[<span class="string">&#x27;message&#x27;</span>]]</span><br><span class="line">test_embeddings = [get_cls_embedding(text).flatten() <span class="keyword">for</span> text <span class="keyword">in</span> test_data[<span class="string">&#x27;message&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(test_embeddings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和验证集</span></span><br><span class="line">X_train = train_embeddings</span><br><span class="line">y_train = train_data[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">X_test = test_embeddings</span><br><span class="line">y_test = test_data[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练逻辑回归模型，使用一个不同的变量名，比如 logreg_model</span></span><br><span class="line">logreg_model = LogisticRegression()</span><br><span class="line">logreg_model.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><p>因为需要的是句子的语义，而不是每个单词的语义，所以需要计算文本的 CLS 嵌入。</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>词袋模型的结果如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">              precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">           0       0.99      0.99      0.99      1205</span><br><span class="line">           1       0.96      0.95      0.95       187</span><br><span class="line"></span><br><span class="line">    accuracy                           0.99      1392</span><br><span class="line">   macro avg       0.97      0.97      0.97      1392</span><br><span class="line">weighted avg       0.99      0.99      0.99      1392</span><br></pre></td></tr></table></figure><p>词嵌入模型的结果如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">              precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">           0       0.99      1.00      0.99      1205</span><br><span class="line">           1       0.98      0.95      0.96       187</span><br><span class="line"></span><br><span class="line">    accuracy                           0.99      1392</span><br><span class="line">   macro avg       0.99      0.97      0.98      1392</span><br><span class="line">weighted avg       0.99      0.99      0.99      1392</span><br></pre></td></tr></table></figure><p>看上去词嵌入模型的效果更好一些，但是当我输入这样一句话 “you have won £1000 cash! call to claim your prize.”，词嵌入模型的预测结果是有效邮件，而词袋模型的预测结果是垃圾邮件。</p><p>为什么会出现这种情况呢？因为词嵌入模型是基于语义的，而这句话中的 “won”、“prize” 等词汇在正常邮件中也可能出现，所以词嵌入模型无法准确判断这句话是垃圾邮件。</p><p>而词袋模型是基于词频的，这句话中的 “won”、“prize” 等词汇在垃圾邮件中出现的概率更高，所以词袋模型能够准确判断这句话是垃圾邮件。</p><p>词袋模型就适合这种有敏感词汇的场景，宁可错杀，不可放过。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 大语言模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集成学习，改良随机森林算法，预测缺失数据集</title>
      <link href="/2025/02/25/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B901/"/>
      <url>/2025/02/25/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B901/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个专栏的核心是阅读《机器学习》这本书，同时也会结合 Kaggle 等实战项目，加深对机器学习的理解。</p><p>这次是第8章，集成学习，用 Kaggle 的泰坦尼克号生存预测来举例，代码见 <a href="https://www.kaggle.com/code/zzoonngk/titanic%E3%80%82">https://www.kaggle.com/code/zzoonngk/titanic。</a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>集成学习（ensemble learning）通过构建并结合多个学习器来完成学习任务，有时也被称为多分类器系统（multi-classifier system）、基于委员会的学习（committee-based learning）等，一般可以被简化为如下结构。</p><p><img src="/img/AI%E7%9F%A5%E8%AF%86%E7%82%B9/1.png"></p><pre><code>其中这些个体学习器可以用相同的算法，也可以用不同的算法。</code></pre><p>那么集成学习是如何做到比单个学习器更好的呢？来看一组图。</p><p><img src="/img/AI%E7%9F%A5%E8%AF%86%E7%82%B9/2.png"></p><pre><code>这里默认的结合方法是“少数服从多数”，可以发现只有情况a可以集成提升性能。</code></pre><p>基于此，我们可以得出集成个体应该“好而不同“，如果大家不好就可能会是情况c，如果大家都好但是一样就可能会是情况b。</p><p>由此引申出了个体学习器的<strong>准确性</strong>与<strong>多样性</strong>。</p><h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><p>Boosting 是一种串行集成学习方法，核心思路是不断提高个体学习器的准确性。</p><p>算法原理：先从初始训练集训练出一个基学习器，再根据基学习器的表现调整训练集，使得后续的基学习器更关注前面学习器分类错误的样本，最后将所有基学习器进行加权结合。</p><pre><code>具体数学推导的话推荐大家去看书，我现在的水平也解释不太清楚。</code></pre><p>Python 实现 AdaBoost 的话也不复杂，核心就这么几句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 AdaBoost 分类器</span></span><br><span class="line">base_estimator = DecisionTreeClassifier(max_depth=<span class="number">1</span>)</span><br><span class="line">model = AdaBoostClassifier(estimator=base_estimator, n_estimators=<span class="number">100</span>, random_state=<span class="number">1</span>)</span><br><span class="line">model.fit(X, y)</span><br></pre></td></tr></table></figure><pre><code>其中这里的基学习器是二层决策树，总共迭代学习100次，也就是说最后的预测结果是这100个学习器的加权和。</code></pre><p>大家也可以试试换别的基学习器，我这边用了二层决策树（上面）和三层决策树（下面），结果如下。</p><!-- ![](/img/AI知识点/3.png) --><pre><code>可以发现在这个场景中，二层决策树的效果更好，猜测是在迭代过程中，三层决策树过拟合了，这也说明了为什么 Boosting 适合弱学习器。</code></pre><h1 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h1><p>相比于 Boosting 在准确性上下功夫，Bagging 更关注多样性，那么如何实现多样性呢？</p><p>算法原理：通过随机采样训练集，训练出多个基学习器，最后将所有基学习器进行加权结合。</p><pre><code>这里的采样方法是自助采样法（bootstrap sampling），即从训练集中有放回地采样出和原训练集一样大小的新训练集，最合大约有63.2%的样本被采样到。</code></pre><p>实现代码都差不多，就换了个名字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = BaggingClassifier(estimator=base_classifier, n_estimators=<span class="number">100</span>, random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这次我比对了一下二层，三层，四层，发现三层的效果最好，同样是0.77511。</p><p>值得一提的是由于 Bagging 的采样方法，每个基学习器都是在不同的训练集上训练的，所以可以通过 OOB（Out-of-Bag）误差来评估模型的泛化能力。</p><pre><code>OOB 误差是指在训练过程中，对于每个基学习器，都有一部分样本没有被采样到，这部分样本就是 OOB 样本，可以用来评估模型的泛化能力。</code></pre><h1 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h1><p>相比于 Bagging 的样本多样性，随机森林又加了一条：<strong>特征多样性</strong>。</p><p>算法原理：在 Bagging 的基础上，每次训练基学习器时，随机选择一部分特征训练决策树。</p><pre><code>具体每次选几个特征，一般会选 log2(d) 个，其中 d 是特征总数，感觉log2确实是个很神奇的数。</code></pre><p>但是决策树的深度毕竟不等于使用的特征数量，所以还是得自己测试。</p><h1 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h1><h2 id="平均法-x2F-投票法"><a href="#平均法-x2F-投票法" class="headerlink" title="平均法&#x2F;投票法"></a>平均法&#x2F;投票法</h2><p>其实结合策略我看下来还是最普通的平均法&#x2F;投票法比较好用，因为每个学习器的权重是比较难评估的。</p><pre><code>我想这也是为什么即使再需要多样性，也不会让这些基学习器用不同的算法，因为这样就意味着必须得加权计算了。</code></pre><h1 id="学习法"><a href="#学习法" class="headerlink" title="学习法"></a>学习法</h1><p>除此之外就是学习法，有点类似于神经网络，具体思路是通过训练一个元学习器，来学习如何结合多个基学习器。</p><p>大家感兴趣的话可以自行研究，我感觉不如平均法&#x2F;投票法来得直接，搞不好还会过拟合。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>有随机森林，那就会有随机神经网络堆，大家可以自行研究，我这边就不展开了。</p><h1 id="实战优化"><a href="#实战优化" class="headerlink" title="实战优化"></a>实战优化</h1><p>最后来看一下实战，之所以正确率一直上不去，就是因为我们没有用那些<strong>虽然缺失了数据但是很重要的特征</strong>。</p><p>所以我们可以改良随机森林，思路就是在训练时遇到缺失数据就剔除这个样本，预测时遇到缺失数据就用其他学习器的预测结果来投票。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImprovedRandomForest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_estimators=<span class="number">100</span>, max_depth=<span class="literal">None</span>, random_state=<span class="literal">None</span></span>):</span><br><span class="line">        self.n_estimators = n_estimators</span><br><span class="line">        self.max_depth = max_depth</span><br><span class="line">        self.random_state = random_state</span><br><span class="line">        self.trees = []</span><br><span class="line">        self.used_features = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X, y</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(X, pd.DataFrame):</span><br><span class="line">            <span class="comment"># 分离数值类型和布尔类型的列</span></span><br><span class="line">            numerical_cols = X.select_dtypes(include=[np.number]).columns</span><br><span class="line">            boolean_cols = X.select_dtypes(include=[<span class="built_in">bool</span>]).columns</span><br><span class="line">            X_numerical = X[numerical_cols].values</span><br><span class="line">            X_boolean = X[boolean_cols].values</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(y, pd.Series):</span><br><span class="line">            y = y.values</span><br><span class="line">            </span><br><span class="line">        np.random.seed(self.random_state)</span><br><span class="line">        n_samples, n_num_features = X_numerical.shape</span><br><span class="line">        _, n_bool_features = X_boolean.shape</span><br><span class="line">        all_features_count = n_num_features + n_bool_features</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.n_estimators):</span><br><span class="line">            <span class="comment"># 随机选择特征，同时考虑数值和布尔特征</span></span><br><span class="line">            feature_indices = np.random.choice(all_features_count, size=<span class="built_in">int</span>(np.sqrt(all_features_count)), replace=<span class="literal">False</span>)</span><br><span class="line">            num_indices = [i <span class="keyword">for</span> i <span class="keyword">in</span> feature_indices <span class="keyword">if</span> i &lt; n_num_features]</span><br><span class="line">            bool_indices = [i - n_num_features <span class="keyword">for</span> i <span class="keyword">in</span> feature_indices <span class="keyword">if</span> i &gt;= n_num_features]</span><br><span class="line"></span><br><span class="line">            X_num_subset = X_numerical[:, num_indices]</span><br><span class="line">            X_bool_subset = X_boolean[:, bool_indices]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查数值特征是否有缺失值</span></span><br><span class="line">            <span class="keyword">if</span> num_indices:</span><br><span class="line">                missing_mask_num = np.isnan(X_num_subset).<span class="built_in">any</span>(axis=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                missing_mask_num = np.zeros(n_samples, dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 布尔特征通常无缺失值，这里假设无缺失</span></span><br><span class="line">            missing_mask_bool = np.zeros(n_samples, dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 剔除包含缺失值的行</span></span><br><span class="line">            missing_mask = missing_mask_num | missing_mask_bool</span><br><span class="line">            <span class="keyword">if</span> missing_mask.<span class="built_in">any</span>():</span><br><span class="line">                X_num_clean = X_num_subset[~missing_mask]</span><br><span class="line">                X_bool_clean = X_bool_subset[~missing_mask]</span><br><span class="line">                X_clean = np.hstack((X_num_clean, X_bool_clean))</span><br><span class="line">                y_clean = y[~missing_mask]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                X_clean = np.hstack((X_num_subset, X_bool_subset))</span><br><span class="line">                y_clean = y</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 训练决策树</span></span><br><span class="line">            tree = DecisionTreeClassifier(max_depth=self.max_depth)</span><br><span class="line">            tree.fit(X_clean, y_clean)</span><br><span class="line">            self.trees.append(tree)</span><br><span class="line">            self.used_features.append(feature_indices)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(X, pd.DataFrame):</span><br><span class="line">            <span class="comment"># 分离数值类型和布尔类型的列</span></span><br><span class="line">            numerical_cols = X.select_dtypes(include=[np.number]).columns</span><br><span class="line">            boolean_cols = X.select_dtypes(include=[<span class="built_in">bool</span>]).columns</span><br><span class="line">            X_numerical = X[numerical_cols].values</span><br><span class="line">            X_boolean = X[boolean_cols].values</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化预测结果矩阵，初始值都设为 np.nan</span></span><br><span class="line">        n_samples = X_numerical.shape[<span class="number">0</span>]</span><br><span class="line">        predictions = np.full((n_samples, self.n_estimators), np.nan)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_estimators):</span><br><span class="line">            feature_indices = self.used_features[i]</span><br><span class="line">            num_indices = [idx <span class="keyword">for</span> idx <span class="keyword">in</span> feature_indices <span class="keyword">if</span> idx &lt; <span class="built_in">len</span>(numerical_cols)]</span><br><span class="line">            bool_indices = [idx - <span class="built_in">len</span>(numerical_cols) <span class="keyword">for</span> idx <span class="keyword">in</span> feature_indices <span class="keyword">if</span> idx &gt;= <span class="built_in">len</span>(numerical_cols)]</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span> sample_idx <span class="keyword">in</span> <span class="built_in">range</span>(n_samples):</span><br><span class="line">                sample_num = X_numerical[sample_idx, num_indices]</span><br><span class="line">                sample_bool = X_boolean[sample_idx, bool_indices]</span><br><span class="line">    </span><br><span class="line">                <span class="comment"># 检查数值特征是否有缺失值</span></span><br><span class="line">                has_missing = np.isnan(sample_num).<span class="built_in">any</span>() <span class="keyword">if</span> num_indices <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> has_missing:</span><br><span class="line">                    sample = np.hstack((sample_num, sample_bool)).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">                    prediction = self.trees[i].predict(sample)</span><br><span class="line">                    predictions[sample_idx, i] = prediction[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">        final_predictions = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> predictions:</span><br><span class="line">            valid_predictions = row[~np.isnan(row)]</span><br><span class="line">            <span class="keyword">if</span> valid_predictions.size &gt; <span class="number">0</span>:</span><br><span class="line">                final_predictions.append(np.bincount(valid_predictions.astype(<span class="built_in">int</span>)).argmax())</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> np.array(final_predictions)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模型评估与选择，理解AUC和ROC</title>
      <link href="/2025/02/25/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B902/"/>
      <url>/2025/02/25/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B902/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我总是觉得，光看书很难理解知识，因为人们在写书时似乎总是把知识写得很官方，全然不讲那些知识是如何被想出来的。</p><h1 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h1><p>从咱们的定义上来说，这就是一条真正例率（TPR）和假正例率（FPR）的关系曲线。</p><p><img src="/img/AI%E7%9F%A5%E8%AF%86%E7%82%B9/4.png"></p><p>至于这条线是怎么画出来的，就是通过不停的调整分类阈值，然后计算出每个阈值下的TPR和FPF。</p><p>所以其实在我眼里，y轴也可以被替换为分类阈值。</p><p>也就是说这本质上可以理解为一条假正例率关于分类阈值的变化曲线。</p><p>所以 AUC 的本质作用就是用来寻找合适的分类阈值。</p><p>那自然我们也可以根据我们的实际需要，比如真负例率（TNR）更重要，那么我们就可以画出另一条 ”AUC“（到时候就不叫这个名字了），来帮助我们挑选合适的分类阈值。</p><h1 id="ROC"><a href="#ROC" class="headerlink" title="ROC"></a>ROC</h1><p>ROC 呢其实没太多需要解释的，看书就行了。</p><p><img src="/img/AI%E7%9F%A5%E8%AF%86%E7%82%B9/5.png"></p><p>被包裹了自然就说明另一个模型更好，毕竟假正例率一样的时候，真正例率更高的模型自然更好。</p><p>但是要是说面积更大的模型更好，那我就不敢苟同了，毕竟你模型提交上去的时候阈值就定下来了。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>决策树，处理缺失值</title>
      <link href="/2025/02/25/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B903/"/>
      <url>/2025/02/25/AI/AI%E7%9F%A5%E8%AF%86%E7%82%B9/AI%E7%9F%A5%E8%AF%86%E7%82%B903/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>像基本流程，划分选择，剪枝处理，我这边就不讲了，直接看后面的重点。</p><h1 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h1><p>我之前一直以为决策树是不能处理缺失值的，所以我之前那篇集成学习才会自己实现随机森林的缺失值处理，这次给大家看看能处理缺失值的决策树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecisionTreeClassifierWithMissing</span>(<span class="title class_ inherited__">DecisionTreeClassifier</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_split_node</span>(<span class="params">self, X, y, sample_weight, depth, impurity, n_node_samples,</span></span><br><span class="line"><span class="params">                    weighted_n_node_samples, feature, threshold</span>):</span><br><span class="line">        left_indices = []</span><br><span class="line">        right_indices = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> np.isnan(X[i, feature]):</span><br><span class="line">                left_indices.append(i)</span><br><span class="line">                right_indices.append(i)</span><br><span class="line">            <span class="keyword">elif</span> X[i, feature] &lt;= threshold:</span><br><span class="line">                left_indices.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_indices.append(i)</span><br><span class="line"></span><br><span class="line">        left_indices = np.array(left_indices)</span><br><span class="line">        right_indices = np.array(right_indices)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sample_weight <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            left_sample_weight = np.ones(left_indices.shape[<span class="number">0</span>])</span><br><span class="line">            right_sample_weight = np.ones(right_indices.shape[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left_sample_weight = sample_weight[left_indices]</span><br><span class="line">            right_sample_weight = sample_weight[right_indices]</span><br><span class="line"></span><br><span class="line">        left_child = <span class="built_in">super</span>()._split_node(X[left_indices], y[left_indices],</span><br><span class="line">                                         left_sample_weight, depth + <span class="number">1</span>,</span><br><span class="line">                                         impurity, n_node_samples,</span><br><span class="line">                                         weighted_n_node_samples, feature, threshold)</span><br><span class="line">        right_child = <span class="built_in">super</span>()._split_node(X[right_indices], y[right_indices],</span><br><span class="line">                                          right_sample_weight, depth + <span class="number">1</span>,</span><br><span class="line">                                          impurity, n_node_samples,</span><br><span class="line">                                          weighted_n_node_samples, feature, threshold)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left_child, right_child</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        predictions = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X.shape[<span class="number">0</span>]):</span><br><span class="line">            node_id = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> self.tree_.children_left[node_id] != self.tree_.children_right[node_id]:</span><br><span class="line">                feature = self.tree_.feature[node_id]</span><br><span class="line">                threshold = self.tree_.threshold[node_id]</span><br><span class="line">                <span class="keyword">if</span> np.isnan(X[i, feature]):</span><br><span class="line">                    left_node_id = self.tree_.children_left[node_id]</span><br><span class="line">                    right_node_id = self.tree_.children_right[node_id]</span><br><span class="line">                    left_pred = self._predict_from_node(X[i], left_node_id)</span><br><span class="line">                    right_pred = self._predict_from_node(X[i], right_node_id)</span><br><span class="line">                    votes = [left_pred, right_pred]</span><br><span class="line">                    classes, counts = np.unique(votes, return_counts=<span class="literal">True</span>)</span><br><span class="line">                    prediction = classes[np.argmax(counts)]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> X[i, feature] &lt;= threshold:</span><br><span class="line">                    node_id = self.tree_.children_left[node_id]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node_id = self.tree_.children_right[node_id]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                value = self.tree_.value[node_id][<span class="number">0</span>]</span><br><span class="line">                prediction = np.argmax(value)</span><br><span class="line">            predictions.append(prediction)</span><br><span class="line">        <span class="keyword">return</span> np.array(predictions)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_predict_from_node</span>(<span class="params">self, x, node_id</span>):</span><br><span class="line">        <span class="keyword">while</span> self.tree_.children_left[node_id] != self.tree_.children_right[node_id]:</span><br><span class="line">            feature = self.tree_.feature[node_id]</span><br><span class="line">            threshold = self.tree_.threshold[node_id]</span><br><span class="line">            <span class="keyword">if</span> np.isnan(x[feature]):</span><br><span class="line">                left_node_id = self.tree_.children_left[node_id]</span><br><span class="line">                right_node_id = self.tree_.children_right[node_id]</span><br><span class="line">                left_pred = self._predict_from_node(x, left_node_id)</span><br><span class="line">                right_pred = self._predict_from_node(x, right_node_id)</span><br><span class="line">                votes = [left_pred, right_pred]</span><br><span class="line">                classes, counts = np.unique(votes, return_counts=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">return</span> classes[np.argmax(counts)]</span><br><span class="line">            <span class="keyword">elif</span> x[feature] &lt;= threshold:</span><br><span class="line">                node_id = self.tree_.children_left[node_id]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node_id = self.tree_.children_right[node_id]</span><br><span class="line">        value = self.tree_.value[node_id][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> np.argmax(value)</span><br></pre></td></tr></table></figure><ol><li>_split_node：如果遇到缺失值，就不管它，同时分配给左右子树。</li><li>_predict_from_node：遇到缺失值就同时走左右子树，最后投票决定归属。</li></ol><p>为什么要让模型带着缺失值训练？</p><p>因为如果单纯的把带缺失值的数据剔除，有可能会错过一些信息。</p><p>不过在随机森林中，不需要调用这个能处理缺失值的决策树，用正常的决策树就行了。</p><p>因为随机森林是通过随机选择特征来训练的，所以即使在某些决策树中剔除了一些数据，也会有其他决策树学习到那些数据。</p><p>这个随机森林也是要自己实现的，具体就看我之前那一篇就行了。</p><h1 id="多变量决策树"><a href="#多变量决策树" class="headerlink" title="多变量决策树"></a>多变量决策树</h1><p>这一块怎么说呢，这个组合变量其实更应该算是数据挖掘的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
