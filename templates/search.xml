<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DX12渲染管线学习笔记</title>
      <link href="/2025/09/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/"/>
      <url>/2025/09/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>零散的笔记，是我在学习过程中的思考，自认为简单的东西并不会记录在内。</p><h1 id="Direct3D-基础"><a href="#Direct3D-基础" class="headerlink" title="Direct3D 基础"></a>Direct3D 基础</h1><h2 id="初始化-D3D"><a href="#初始化-D3D" class="headerlink" title="初始化 D3D"></a>初始化 D3D</h2><h3 id="Factory-和-Device"><a href="#Factory-和-Device" class="headerlink" title="Factory 和 Device"></a>Factory 和 Device</h3><p>说实话 <strong>DirectX</strong> 中的架构思路真的值得去学习，这里的工厂和驱动都是蕴含了很多的设计思想的，但我目前还不能真正的理解。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/InitializeD3D.jpg"></p><h3 id="WRAP"><a href="#WRAP" class="headerlink" title="WRAP"></a><a href="https://learn.microsoft.com/en-us/windows/win32/direct3darticles/directx-warp">WRAP</a></h3><p>应该不需要去写它的意义吧，猜猜就知道了。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>个人感觉 <strong>CommandList</strong> 类似于资源描述符，而 <strong>CommandAllocator</strong> 类似于缓冲区，将 <strong>CommandList</strong> 中的命令传入 <strong>CommandQueue</strong> 中，但是 <strong>CommandAllocator</strong> 还是原来的，这也是为什么在 <strong>CommandQueue</strong> 的命令被执行完前不能重置 <strong>CommandAllocator</strong>。</p><h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><p>目前这里指的就是普通的光栅化流水线。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/RenderingPipeline.jpg"></p><p>这里特地拍了一张我在书上的笔记，是想展示一下数据的流向。</p><h3 id="Step1-内存数据流向显存"><a href="#Step1-内存数据流向显存" class="headerlink" title="Step1 内存数据流向显存"></a>Step1 内存数据流向显存</h3><p>可以先到后面看一下流水线状态，可以发现主要就是绑定根签名表和 <strong>Shader</strong>，缓冲区都是在创建时绑定的，当然绑定的都是描述符，绑定数据的话带宽直接废掉了。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/BindBuffer.jpg"></p><p>书里也说得很清楚了绑定的时候 <strong>GPU</strong> 会自动创建描述符和堆，<strong>GPU</strong> 会在需要用到数据的时候将数据存入显存中（闲时存入，减少带宽消耗）。</p><p><strong>Vertex Buffer</strong>、<strong>Index Buffer</strong> 和 <strong>Constant Buffer</strong> 的创建与提交在第六章都有详细介绍，阅读之前一定要对描述符、视图、描述表以及描述堆等名词有足够的理解。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E9%BE%99%E4%B9%A6%E9%98%85%E8%AF%BB/VertexBuffer.jpg"></p><p>关于为什么 <strong>RTV</strong> 不用绑定，个人认为应该是直接封装在 <strong>CreateRenderTargetView</strong> 里了。</p><h3 id="Step2-显存数据流向显存"><a href="#Step2-显存数据流向显存" class="headerlink" title="Step2 显存数据流向显存"></a>Step2 显存数据流向显存</h3><p>由于在曲面细分阶段、域着色阶段和几何着色阶段中，顶点数据会被扩展，所以要把新数据加入显存中，之后再提出来着色。</p><p>这也是传冲渲染管线相较于 <strong>Mesh Pipeline</strong> 的缺点。</p><h3 id="Step3-显存数据流向显存"><a href="#Step3-显存数据流向显存" class="headerlink" title="Step3 显存数据流向显存"></a>Step3 显存数据流向显存</h3><p>这里主要是像比如将光照存入纹理中这样的操作，就需要把纹理存在显存中，以便后续的使用。</p><h3 id="Step4-显存数据流向内存"><a href="#Step4-显存数据流向内存" class="headerlink" title="Step4 显存数据流向内存"></a>Step4 显存数据流向内存</h3><p>说实话也不一定是流向内存，可能只是放在了全局显存里，让 <strong>CPU</strong> 自己去读取。</p><p>关于对显存中数据的驻留，<strong>DX12</strong> 也是提供了底层的 <strong>API</strong> 供程序员主动管理，但是龙书中并没有说明具体的操作方法，详细的资料可以阅读《Residency（驻留）》或者去看官方的 <strong>API</strong>，这应该能带来不小的优化。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏引擎架构阅读笔记</title>
      <link href="/2025/09/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/"/>
      <url>/2025/09/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不只是阅读《游戏引擎架构》的笔记，更多的是做引擎时的心得。</p><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><p>版本控制、项目构建等等其它方面的工具自选就行，好用就完事了。</p><h1 id="引擎核心层"><a href="#引擎核心层" class="headerlink" title="引擎核心层"></a>引擎核心层</h1><h2 id="引擎入口"><a href="#引擎入口" class="headerlink" title="引擎入口"></a>引擎入口</h2><p>建立 <strong>Engine</strong> 的基类，同时在 <strong>main&#x2F;WinMain</strong> 中创建 <strong>Engine</strong>，将其编译成 <strong>Lib</strong> 库后暴露给编辑器，编辑器通过继承 <strong>Engine</strong> 类以实现对引擎的配置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Editor</span> : <span class="keyword">public</span> Engine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Editor</span>() &#123;&#125;;</span><br><span class="line">~<span class="built_in">Editor</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Engine* <span class="title">CreateEngine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Editor *editor = <span class="keyword">new</span> <span class="built_in">Editor</span>();</span><br><span class="line"><span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例化引擎顺序"><a href="#实例化引擎顺序" class="headerlink" title="实例化引擎顺序"></a>实例化引擎顺序</h2><p>书里面说要注意，但我觉得还好，不容易崩，实在不行就用书里面的优先级队列吧。</p><p>不过引用友元也是会初始化的，所以最好还是在 <strong>PreInit</strong> 或者 <strong>Init</strong>中完成。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h2 id="日志管理和计时器"><a href="#日志管理和计时器" class="headerlink" title="日志管理和计时器"></a>日志管理和计时器</h2><p>这种都是自己想怎么弄都行，不会消耗太多性能，不同的日志和计时器和效果也不一样。</p><h2 id="内存管理、GC-和字符流"><a href="#内存管理、GC-和字符流" class="headerlink" title="内存管理、GC 和字符流"></a>内存管理、GC 和字符流</h2><p>建议自己写，不过不用这么早，放到后面当优化点行，字符流也可以考虑用 <strong>QString</strong>。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>自己写工作量太大了，以优化 <strong>STL</strong> 为主（增加算法）。</p><h1 id="引擎资源层"><a href="#引擎资源层" class="headerlink" title="引擎资源层"></a>引擎资源层</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/Database.jpg"></p><h2 id="模型导入"><a href="#模型导入" class="headerlink" title="模型导入"></a>模型导入</h2><p>看看这张图吧。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/assimp_structure.png"></p><p>直接从<a href="https://learnopengl-cn.github.io/03%20Model%20Loading/01%20Assimp/">这里</a>复制了。</p><ul><li><p>和材质和网格(Mesh)一样，所有的场景&#x2F;模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。</p></li><li><p>场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。</p></li><li><p>一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。</p></li><li><p>一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见你好，三角形）。</p></li><li><p>最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。</p></li></ul><h1 id="引擎功能层"><a href="#引擎功能层" class="headerlink" title="引擎功能层"></a>引擎功能层</h1><p>在这里核心层和功能层的分界并不明确，比如渲染功能的接口是要在核心层（平台层）封装的，而调用则在功能层。</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h3 id="渲染架构"><a href="#渲染架构" class="headerlink" title="渲染架构"></a>渲染架构</h3><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/RenderingArchitecture.png"></p><h3 id="渲染层级"><a href="#渲染层级" class="headerlink" title="渲染层级"></a>渲染层级</h3><p>需要一个渲染 <strong>Layer</strong> 以及一个储存 <strong>Layer</strong> 的容器，比如栈或者优先级队列。</p><p>渲染层级很重要，有了它才可以绘制透明物体，制作特效以及 <strong>UI</strong> 等等。</p><h3 id="渲染管道"><a href="#渲染管道" class="headerlink" title="渲染管道"></a>渲染管道</h3><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/RenderingPipeline1.jpg"></p><p>这样的渲染管线示意图对程序员更友好。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/RenderingPipeline2.jpg"></p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E9%98%85%E8%AF%BB/PVS.jpg"></p><h1 id="引擎工具层"><a href="#引擎工具层" class="headerlink" title="引擎工具层"></a>引擎工具层</h1><p>最重要的就是反射（数据解析）了。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于OpenGL的光栅化渲染管线</title>
      <link href="/2025/09/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
      <url>/2025/09/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在写游戏引擎，在这里将主要记录一下如何架构跨平台的 <strong>Rendering Pipeline</strong>。</p><p>在大部分人眼中，这就是 <strong>Rendering Pipeline</strong>，但是其实这只能说是 <strong>Shader Pipeline</strong>，真正的渲染管线远比这更加复杂。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/Pipeline.jpg"></p><h1 id="光栅化的渲染管线"><a href="#光栅化的渲染管线" class="headerlink" title="光栅化的渲染管线"></a>光栅化的渲染管线</h1><h2 id="固定的渲染管线"><a href="#固定的渲染管线" class="headerlink" title="固定的渲染管线"></a>固定的渲染管线</h2><p>这是早期架构的渲染管线，因为引擎的交互还不完善，所以暂时不需要考虑动态的情况。</p><pre><code>Rendering/    RenderingInterface.hpp    Platform/        Windows/            WindowsRenderingPipeline.hpp            WindowsRenderingPipelineState.hpp            DirectXInterface.hpp        Android/            AndroidRenderingPipeline.hpp            AndroidRenderingPipelineState.hpp            OpenGLInterface.hppGameObject/    GOManage.hpp    Mesh/        StaticMesh.hpp</code></pre><h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h3><p>对于引擎来说，渲染模块将只暴露出以下几个接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PreInit</span>();</span><br><span class="line"><span class="built_in">Init</span>();</span><br><span class="line"><span class="built_in">PostInit</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Tick</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">InitExit</span>();</span><br><span class="line"><span class="built_in">Exit</span>();</span><br><span class="line"><span class="built_in">PostExit</span>();</span><br></pre></td></tr></table></figure><h4 id="WindowsRenderingPipeline-hpp"><a href="#WindowsRenderingPipeline-hpp" class="headerlink" title="WindowsRenderingPipeline.hpp"></a>WindowsRenderingPipeline.hpp</h4><p>继承 <strong>RenderingInterface</strong> 同时调用 <strong>DirectXInterface</strong> 中提供的 <strong>API</strong>。</p><h5 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h5><p>主要是根据 <strong>Windows</strong> 传入的命令对 <strong>DirectX</strong> 进行初始化。</p><p>具体有创建驱动器和工厂（保证创建出驱动器），再用驱动去创建围栏（同步 <strong>CPU</strong> 和 <strong>GPU</strong>），命令队列，堆（存储视图，视图记录了数据在相应缓冲中的偏移地址和长度，是一种数据标识符）以及交换链。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/Init.jpg"></p><p>之后再调用 <strong>WindowsRenderingPipelineState</strong> 创建管线状态对象（<strong>PSO</strong>）。</p><h5 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h5><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/Tick.jpg"></p><p><strong>Tick</strong> 其实没什么要讲的，就跟画画一样，清除、绘制和等待。</p><p>就是绘制之前要更新数据，关于 <strong>GPU</strong> 和 <strong>CPU</strong> 在读写数据时怎么保证安全就是另外的问题了。</p><h5 id="Exit"><a href="#Exit" class="headerlink" title="Exit"></a>Exit</h5><h4 id="WindowsRenderingPipelineState-hpp"><a href="#WindowsRenderingPipelineState-hpp" class="headerlink" title="WindowsRenderingPipelineState.hpp"></a>WindowsRenderingPipelineState.hpp</h4><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%BC%80%E5%8F%91/PostInit.jpg"></p><ol><li><p>创建根签名，绑定常量缓冲区描述表的起始地址到寄存器中。</p></li><li><p>构建 <strong>Shader</strong>。</p></li><li><p>提交模型数据至 <strong>buffer</strong> 中需要遍历 <strong>GOManage.hpp</strong> 中储存 <strong>GameObject</strong> 的数组获得顶点数据和索引，用 <strong>OpenGL</strong> 的话说就是 <strong>VAO</strong>，<strong>VBO</strong>和<strong>IBO</strong>。</p></li><li><p>构建常量描述堆（存放常量缓冲区视图）。</p></li><li><p>构建常量缓冲区，目前来说，所有的 <strong>GameObject</strong> 共用一个常量缓冲区，通过为每一个 <strong>GameObject</strong> 创建一个常量缓冲区视图来分割常量缓冲区，相机的视角投影矩阵单独存放在一个常量缓冲区中。</p></li><li><p>最后是一些设置，包括配置光栅化状态，混合模式等等。</p></li></ol><h2 id="动态的渲染管线"><a href="#动态的渲染管线" class="headerlink" title="动态的渲染管线"></a>动态的渲染管线</h2><p>动态的渲染管线估计会参考<a href="https://www.gamedeveloper.com/programming/designing-a-modern-cross-platform-low-level-graphics-library">这篇文章</a>和<a href="https://github.com/DiligentGraphics/DiligentEngine">他们的引擎</a>。</p><h1 id="光线追踪的渲染管线"><a href="#光线追踪的渲染管线" class="headerlink" title="光线追踪的渲染管线"></a>光线追踪的渲染管线</h1><h1 id="Mesh-Pipeline"><a href="#Mesh-Pipeline" class="headerlink" title="Mesh Pipeline"></a>Mesh Pipeline</h1>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Games101学习笔记</title>
      <link href="/2025/09/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/09/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>感觉自己一开始没有认真学，所以现在基础有点差，最近打算重学一遍，该手推就手推，不偷懒了。</p><p>这次主要是跟着 <a href="https://space.bilibili.com/512313464"><strong>GAMES-Webinar</strong></a> 的课程学习，所以如果你想要看懂这份笔记，我建议先去学习相应的课程。</p><h1 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h1><h2 id="View-transformation"><a href="#View-transformation" class="headerlink" title="View transformation"></a>View transformation</h2><p>相机需要设置的参数。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/CameraSetting.jpg"></p><p>将相机平移至原点并同时将 <strong>look at</strong> 和 <strong>up</strong> 及其叉乘共三个向量同时对其标准坐标轴的矩阵即为 <strong>View matrix</strong>。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ViewTransformation.jpg"></p><p>唯一要注意的就是由于直接计算旋转矩阵比较复杂（从任意向量变换到标准坐标轴），所以先计算其逆矩阵（从标准坐标轴变换到任意向量）。</p><h2 id="Projection-transformation"><a href="#Projection-transformation" class="headerlink" title="Projection transformation"></a>Projection transformation</h2><p>其实只要求从四棱台压缩到矩形的矩阵就行了。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(1).jpg"></p><p>直觉上其实很容易得出结论，难点在于求出相应的变换矩阵。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(2).jpg"></p><p>为了计算出来就得补充两个假设。</p><blockquote><p>Any point on the near plane will not change<br>Any point’s z on the far plane will not change</p></blockquote><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(3).jpg"><br><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(4).jpg"></p><p>解方程后也能求出来最后的投影矩阵（还需要用 <strong>FOV</strong> 和长宽比进行参数替代）。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(5).jpg"></p><p>最后再通过正交矩阵映射到 <strong>NDC</strong> 空间。</p><p>补充一点，如果不出意外的话四棱台向长方体的挤压方向是这样的。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ProjectionTransformation(6).jpg"></p><p>因为如果不做出第二条假设，所有的点都会向法线（垂直边方向）挤压，第二条假设的存在使挤压形变变少，速度变慢。</p><h2 id="欧拉角，旋转矩阵和四元数"><a href="#欧拉角，旋转矩阵和四元数" class="headerlink" title="欧拉角，旋转矩阵和四元数"></a>欧拉角，旋转矩阵和四元数</h2><h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/EulerAngle.jpg"></p><p>万向锁就是旋转过程中，任意两轴重合，导致旋转轴的缺失。</p><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/Matrix.jpg"></p><p>唯一的缺点就是不方便插值。</p><h3 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h3><p>四元数的话就看 <strong>3B1B</strong> 的视频吧。</p><blockquote><p>四元数是一种具有四个实数分量的超复数。四元数也可以用于表示三维空间中的旋转，其中三个实数分量表示旋转轴的方向，第四个实数分量表示旋转的角度大小。四元数在旋转计算中具有很多优点，例如不存在万向锁问题，计算量小，而且可以很容易地插值和球面插值。然而，使用四元数需要对其进行规范化处理，而且理解四元数可能需要更多的数学知识。</p></blockquote><h1 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h1><p>光栅化的本质就是采样（没有配图是因为希望每次看到这句话的时候都能自己去想象这张图片）。</p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><blockquote><p>在采样过程中，每个像素的颜色值是由周围像素颜色值插值得到的，因此如果周围像素颜色值发生了剧烈变化，那么插值得到的像素颜色值就会出现锯齿状的边缘。这种锯齿现象是因为高频分量没有被滤波掉导致的。</p></blockquote><h3 id="MSAA-和-FXAA"><a href="#MSAA-和-FXAA" class="headerlink" title="MSAA 和 FXAA"></a>MSAA 和 FXAA</h3><ul><li><p>实现方式：FXAA是一种基于像素的反走样技术，它使用特定的颜色滤波器对像素进行处理，从而实现反走样的效果。而 MSAA 则是一种基于多个采样点的反走样技术，它在采样点周围绘制多个采样点，然后对采样点进行平均化处理，从而实现反走样的效果。</p></li><li><p>渲染速度</p></li><li><p>效果质量：FXAA 相对于 MSAA 来说效果稍逊一些，因为它只是对像素进行颜色滤波处理，容易出现图像过度平滑和模糊等问题。而 MSAA 则可以更好地保留图像的细节和清晰度，但是需要更多的计算资源。</p></li><li><p>适用范围</p></li></ul><blockquote><p>特定的颜色滤波器是指针对图像中特定类型的边缘和锯齿问题而设计的一种颜色滤波器。在 FXAA 中，采用了一种基于 Luma 值（亮度）的颜色滤波器，通过计算像素周围的亮度值来检测出可能的边缘和锯齿，并将其进行平滑处理，从而达到反走样的效果。</p><p>这种颜色滤波器主要是通过将图像中相邻的像素进行比较，并根据它们之间的颜色和亮度差异来判断是否存在边缘和锯齿，并对这些像素进行颜色和亮度的平滑处理，从而消除图像中的锯齿和边缘问题。这种处理方式不需要对图像进行多次采样或绘制额外的像素，因此可以在较短的时间内完成反走样处理，并且对于移动设备、游戏主机和低端PC等设备来说具有很好的适用性。</p></blockquote><h3 id="TAA-Temporal-Anti-Aliasing"><a href="#TAA-Temporal-Anti-Aliasing" class="headerlink" title="TAA(Temporal Anti-Aliasing)"></a>TAA(Temporal Anti-Aliasing)</h3><blockquote><p>传统的空域反走样技术往往会导致图像失去一些细节和清晰度，而时域反走样技术可以利用前一帧和当前帧之间的信息来进行反走样处理，从而避免这种问题。</p><p>TAA 通过利用前一帧和当前帧之间的运动信息，以及图像的深度信息等，计算出运动向量，并将当前帧的像素颜色与前一帧进行混合，从而得到一个平滑的图像。具体来说，它将前一帧的像素颜色投影到当前帧上，并计算出两帧之间的运动向量，然后将当前帧的像素颜色与投影的像素颜色进行混合，从而得到反走样效果。</p><p>TAA 不仅可以减少锯齿状边缘和走样等问题，还可以增强图像的清晰度和细节。但是，它也会带来一些副作用，比如图像可能会出现闪烁和模糊等问题。因此，使用 TAA 需要进行适当的调节和优化，以平衡反走样效果和图像质量。</p></blockquote><h2 id="超采样"><a href="#超采样" class="headerlink" title="超采样"></a>超采样</h2><h3 id="DLSS-Deep-Learning-Super-Sampling"><a href="#DLSS-Deep-Learning-Super-Sampling" class="headerlink" title="DLSS(Deep Learning Super Sampling)"></a>DLSS(Deep Learning Super Sampling)</h3><h1 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h1><h2 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h2><p>求三角形三点坐标对重心的贡献系数。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/TextureMapping(1).jpg"></p><p>根绝贡献系数就可以实现纹理映射了，不过对于三维坐标（比如深度），就只能在三维空间内插值计算好后再映射到二维空间，因为重心从三维映射到二维后相对坐标会发生偏移。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/TextureMapping(2).jpg"></p><p>三线性插值，猜猜哪来的三个维度？</p><h3 id="纹理过小"><a href="#纹理过小" class="headerlink" title="纹理过小"></a>纹理过小</h3><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/BilinearInterpolation.jpg"></p><h3 id="纹理过大"><a href="#纹理过大" class="headerlink" title="纹理过大"></a>纹理过大</h3><p>由于每个屏幕像素只插值纹理上的一个像素点（即使覆盖了很多像素，也只是像素平均后的一个点），所以会导致走样。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/Mipmap(1).jpg"></p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/Mipmap(2).jpg"></p><h2 id="三维纹理"><a href="#三维纹理" class="headerlink" title="三维纹理"></a>三维纹理</h2><p>核磁共振中会用到。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/3dtexture.jpg"></p><h2 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h2><p>从光源看一遍并把深度值存下来，再从相机看一遍，深度一样就是可见。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ShadowMapping(1).jpg"></p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ShadowMapping(2).jpg"></p><p>就是阴影太硬了，还需要用算法优化。</p><h1 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h1><h2 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h2><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/BezierCurve(1).jpg"></p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/BezierCurve(2).jpg"></p><p>三阶贝塞尔曲线（四个控制点）满足 <strong>C1</strong> 连续，所以是平滑的。</p><h2 id="网格体"><a href="#网格体" class="headerlink" title="网格体"></a>网格体</h2><h3 id="曲面细分"><a href="#曲面细分" class="headerlink" title="曲面细分"></a>曲面细分</h3><p>曲面细分本质就是寻找新的顶点，具体顶点的位置就像平均卷积一样，有周围的点控制。</p><h3 id="曲面简化"><a href="#曲面简化" class="headerlink" title="曲面简化"></a>曲面简化</h3><p>去掉一些点，同时让信息量的变化最少（一个度量函数）。</p><h1 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h1><p>其实同样的模型对于不同的渲染方法，出来的结果也是不一样的。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/ShadingFrequence.jpg"></p><h2 id="局部光照"><a href="#局部光照" class="headerlink" title="局部光照"></a>局部光照</h2><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/LocalShading(1).jpg"></p><p>主要就是分成漫反射光，镜面反射光和环境光三部分。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/LocalShading(2).jpg"></p><h3 id="Diffuse-Term-Lambertian"><a href="#Diffuse-Term-Lambertian" class="headerlink" title="Diffuse Term(Lambertian)"></a>Diffuse Term(Lambertian)</h3><h3 id="Specular-Term-Blinn-Phong"><a href="#Specular-Term-Blinn-Phong" class="headerlink" title="Specular Term(Blinn-Phong)"></a>Specular Term(Blinn-Phong)</h3><p>加指数项，可以控制高光的大小（提高阈值）。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/DiffuseReflection(2).jpg"></p><h3 id="Ambient-Term"><a href="#Ambient-Term" class="headerlink" title="Ambient Term"></a>Ambient Term</h3><h2 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h2><h3 id="Whitted-Style-Ray-Tracing"><a href="#Whitted-Style-Ray-Tracing" class="headerlink" title="Whitted-Style Ray Tracing"></a>Whitted-Style Ray Tracing</h3><p>用以下式子表示任一光线。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RayEquation.jpg"></p><h4 id="光线和物体求交"><a href="#光线和物体求交" class="headerlink" title="光线和物体求交"></a>光线和物体求交</h4><p>先粗判断。</p><p><strong>AABB</strong> 包围盒。</p><p>关于如何划分包围盒有许多方案，但目前主要就是这两种。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/Partitions.jpg"></p><p><strong>BVH</strong> 的伪代码如下。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/BVHTraversal.jpg"></p><p>再细判断。</p><p>隐式表达式可以直接代入求。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RayIntersection(1).jpg"></p><p>显示表达式可以转换成求直线与平面的交点。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RayIntersection(2).jpg"></p><h4 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h4><p>我建议看一下<a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/#_1">这篇文章</a>，讲的还是很好的，这里就直接给出公式了。</p><p>主要是要弄清楚辐射通量，辐射度和辐射率的区别。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RenderingEquation(1).jpg"></p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RenderingEquation(2).jpg"></p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RenderingEquation(3).jpg"></p><p>其实如果把左边的 <strong>L</strong> 看作 <strong>Li</strong>，右边的看成 <strong>Li-1</strong> 会比较好理解。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RenderingEquation(5).jpg"></p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/RenderingEquation(4).jpg"></p><p>这也是为什么光线追踪是全局光照的原因（事实上一次项的 <strong>PBR</strong> 就是局部光照）。</p><h3 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h3><p>优化光线追踪，通过概率（蒙特卡洛，俄罗斯轮盘赌）来降低计算量，同时保持期望值不变。</p><p>继续优化的话就是采样光源而不是采样物体。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/PathTracing1.jpg"></p><p>将光分成两部分，直接光用改写后的方程计算，间接光用优化后的光线追踪方法计算。</p><p><img src="/img/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0/PathTracing2.jpg"></p><p>还讲了许多优化路径追踪的渲染方法。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Where is my life? 我的人生在哪里</title>
      <link href="/2025/03/31/%E5%93%B2%E5%AD%A6/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
      <url>/2025/03/31/%E5%93%B2%E5%AD%A6/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>他，23岁，一事无成，但是找到了自己的路。</p><p>很久没有写文章了，前段时间一直很迷茫，我总是想为我所做的事情赋予一些意义，说服我自己去完成它，真让我感觉非常痛苦。</p><p>明知它是没有意义的，但我却要不停的相信它是有意义的，这甚至让我有点精神分裂。</p><p>直到昨天，我洗澡的时候在想，为什么我不干脆直接承认所有的一切都是无意义的呢？</p><p>将我的人生比作游戏，不断地发起挑战。</p><p>也许这样的人生态度可以支撑我走的更远。</p><p>这不禁让我想起了《西西弗斯神话》，加缪说我们应该想象西西弗斯是快乐的，在那一刻我终于理解了他，西西弗斯应该是快乐的，他也许就在不断地挑战着他自己。</p><p>更快，更高，更持久。</p><p>从今年2月到现在，9个月的时光，我一直在思考这个问题，很庆幸我现在终于有了自己的答案，终于可以更加坦然的面对自己。</p><p>为了纪念，于第二天（2024&#x2F;11&#x2F;15）写下这篇文章，同时也会在今年将其做成视频，希望能给有相同困境的朋友们一些启发。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>What is the meaning of life? Everyone has their own answers, maybe eating everything, traveling around the world or just be a common and common person.</p><p>人生的意义是什么？我想每个人都有各自的答案：吃遍天下美食？旅游？事业？老有所终……</p><p>However, if i ask you does the life really has its meaning? Can you answer the same as you last reply?</p><p>但是如果换个问题，人生真的有意义吗？现在又还有多少人能做出与上个问题相同的回答呢？</p><p>当人生有意义这个大前提被移除，我们才能真正直面自己的人生，去思考我们所向往的人生意义是否真的是我们所向往的，还是说只是在活出别人向往的人生。</p><p>There is only one heroism in the world: to love life after having understood its true meaning.</p><p>正如罗曼罗兰所说，世界上只有一种真正的英雄主义，那就是在认清了生活的真相后还依然热爱它。</p><p>The only real thing in our lives is there is no meaning and only after you accept this terrible truth, you can find you own spirt.</p><p>同样的，也许只有当我们承认了人生的无意义，才能活出真正的人生。</p><p>Holy shit, 你知道承认人生的无意义意味着什么吗，这甚至在说我敲下这篇文章，你观看这个视频都是在浪费时间，根本就没有意义！</p><p>确实，承认人生的无意义是一件非常非常困难的事情，它会让你茫然，不知所措，甚至是恐惧，但是其实强迫自己，让自己坚信人生是有意义的又何尝不是一种酷刑。</p><p>不过我们还有一味解药，就是游戏人生，此游戏人生非彼游戏人生。</p><p>此游戏人生是要你像玩游戏一样过人生。</p><p>其实如果我们认真思考游戏，就会发现游戏也是无意义的，俄罗斯方块里的分数有什么意义吗，无伤通关Boss然后呢，包括我最爱的LOL，就算我有一天打到了王者又能怎么样呢？</p><p>但是我们为什么如此热衷于游戏呢？</p><p>其实，如果你读过游戏设计相关的书籍，你就会发现，游戏拆解到最后不过是，一个目标，一段曲折或者说是一场挑战。</p><p>所以，以自我为中心，尝试用挑战填满人生，不断地欢愉自己，这是人类在对抗荒谬时最后的倔强。</p><p>我想西西弗斯确实是快乐的。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
